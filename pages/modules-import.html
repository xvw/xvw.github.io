<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>xvw - OCaml, modules et sch√©mas d&apos;importation</title>
    <meta name="description" content="Utilisation du langage de modules et des ouvertures pour reproduire des sch√©mas d&apos;importations usuels dans d&apos;autres langages." />
    <meta name="keywords" content="capsule, programmation, ocaml, modules" />
    <meta name="author" content="Xavier Van de Woestyne" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="/css/hl.css" />
    <link rel="stylesheet" href="/css/default.css" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="alternate" type="application/atom+xml" href="/atom.xml" />
    <link rel="alternate" type="application/atom+xml" href="/journal.xml" />
    <link rel="alternate" type="application/atom+xml" href="/pages.xml" />
    <link rel="alternate" type="application/atom+xml" href="/addresses.xml" />
    <script src="/js/hell.js"></script>
    <script src="/js/capsule.js"></script>
  </head>
  <body>
    <main class="container"><section class="header">
  <nav class="breadcrumb">
    <ol>
      <li>
        <a href="/">Accueil</a>
      </li><li>
        <a href="/programming.html">Programmation</a>
      </li><li>
        <a href="/programming.html#index-bribes--encodages">Bribes &amp; Encodages</a>
      </li></ol>
  </nav>

  <h1>OCaml, modules et sch√©mas d&apos;importation</h1><time class="published-at" datetime="2023-10-31">
    2023-10-31
  </time></section><section class="synopsis"><p>Le langage de modules de <a href="https://ocaml.org">OCaml</a> peut √™tre intimidant, et il implique g√©n√©ralement l'utilisation de beaucoup de mots-cl√©s, par exemple <code>open</code> et <code>include</code> qui  permettent d'importer des d√©finitions dans un module. Depuis la version <code>4.08</code> du langage, la primitive <code>open</code> a √©t√© <em>g√©n√©ralis√©e</em> pour permettre l'ouverture <strong>d'expression de module arbitraire</strong>. Dans cet article, nous allons observer comment utiliser cette g√©n√©ralisation pour reproduire une pratique commune dans d'autres langages, que j'appelle, <em>un peu pompeusement</em>, des strat√©gies d'importation, d√©crivant, par exemple, ce genre de d'importation <code>import {a, b as c} from K</code> sans d√©pendre d'un langage d√©di√© √† l'importation.</p>
</section><section class="table-of-contents"><ul>
<li><ul>
<li><a href="#importation-de-composants-de-modules">Importation de composants de modules</a>
<ul>
<li><a href="#ouverture-de-modules">Ouverture de modules</a>
<ul>
<li><a href="#ouverture-locale-de-modules">Ouverture locale de modules</a>
</li>
</ul>
</li>
<li><a href="#inclusion-de-modules">Inclusion de modules</a>
</li>
<li><a href="#ouverture-vs-inclusion-avant-ocaml-408">Ouverture VS inclusion avant OCaml <code>4.08</code></a>
</li>
<li><a href="#un-premier-bnfice">Un premier b√©n√©fice</a>
</li>
</ul>
</li>
<li><a href="#schmas-dimportation">Sch√©mas d'importation</a>
<ul>
<li><a href="#importation-non-qualifie">Importation non-qualifi√©e</a>
</li>
<li><a href="#qualification-renomme">Qualification renomm√©e</a>
<ul>
<li><a href="#prsence-du-module-renomm">Pr√©sence du module renomm√©</a>
</li>
<li><a href="#renommage-imbriqu">Renommage imbriqu√©</a>
</li>
</ul>
</li>
<li><a href="#importation-slective">Importation s√©lective</a>
<ul>
<li><a href="#importation-slective-avec-renommage">Importation s√©lective avec renommage</a>
</li>
</ul>
</li>
<li><a href="#importation-par-exclusion">Importation par exclusion</a>
<ul>
<li><a href="#le-type-somme-vide">Le type somme vide</a>
</li>
<li><a href="#suppression-de-fonctions">Suppression de fonctions</a>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a>
</li>
</ul>
</li>
</ul>
</section><article><p>La g√©n√©ralisation des ouvertures a √©t√© document√©e dans le papier <a href="https://www.cl.cam.ac.uk/~jdy22/papers/extending-ocamls-open.pdf">&quot;<em>Extending
OCaml's</em>
<code>open</code>&quot;</a>,
pr√©sent√© au <a href="https://ocaml.org/workshops/ocaml-users-and-developers-workshop-2017">OCaml Workshp
2017</a>, et
impl√©ment√© ‚Äî pour la version <code>4.08</code> de OCaml ‚Äî via les soumissions
<a href="https://github.com/ocaml/ocaml/pull/1506"><code>#1506</code></a> et
<a href="https://github.com/ocaml/ocaml/pull/2147"><code>#2147</code></a> (adjoint, probablement, de
quelques correctifs suivant la fusion de l'impl√©mentation). Cette g√©n√©ralisation
augmente grandement la flexibilit√© du terme <code>open</code>, rendant possible la mise en
place de quelques astuces pour contr√¥ler finement l'importation de <em>composants
de modules</em> dans un autre module.</p>
<blockquote>
<p>Certaines des astuces pr√©sent√©es sont reprises telles qu'elles du papier qui,
en plus de pr√©senter les strat√©gies d'impl√©mentations, pr√©sente quelques cas
d'usages (dont certains n'√©tant pas pertinents dans le cadre de cet article
car ils ne concernent pas les strat√©gies d'importations).</p>
</blockquote>
<p>Il est probable qu'une grande partie des <em>astuces</em> pr√©sent√©es ne deviennent pas
<em>idiomatiques</em> dans les bases de code OCaml. Selon moi, leur pr√©sentation met
essentiellement en lumi√®re l'accroissement de flexibilit√© de la primitive <code>open</code>
sans devoir se reposer sur une <strong>extension gramaticale sp√©cifique</strong> d√©di√©e √†
l'importation de composants, tout en pr√©sentant quelques encodages un peu
<em>capilotract√©s</em> ... pour le plaisir de la d√©monstration.</p>
<h2 id="importation-de-composants-de-modules">Importation de composants de modules</h2>
<p>Quand on d√©crit un programme OCaml, on construit des collections de modules qui
exportent des composants (des types, des <em>sous-modules</em>, des exceptions et des
fonctions). Il est donc crucial de contr√¥ler finement leurs accessibilit√©s
depuis d'autres modules, pour cela, on dispose de deux primitives ‚Äî <code>open</code> et
<code>include</code> ‚Äî dont la diff√©rence est subtile. Pour d√©crire correctement les
diff√©rences entre les deux primitive, nous allons nous baser sur ce module
(un peu artificiel) que nous utiliserons dans les exemples qui suivent :</p>
<div class="md-multicols">
<pre><code class="language-ocaml">module A = struct
  type a = T_a
  let a_a = 1
  let a_b = T_a
  module B = struct
    type b = T_b
    let b_a = T_b
    let b_b = T_a
  end
end
</code></pre>
<pre><code class="language-ocaml">module A : sig
  type a = T_a
  val a_a : int
  val a_b : a
  module B : sig
    type b = T_b
    val b_a : b
    val b_b : a
  end
end
</code></pre>
</div>
<p>Comme vous pouvez le remarquer, l'impl√©mentation ‚Äî et <em>de facto</em>, la signature ‚Äî
du module n'est pas tr√®s int√©ressant, il ne servira qu'a illustrer mon propos.
Ce que l'on voudra, c'est utiliser, dans un fichier <code>c.ml</code> (qui d√©notera le
module <code>C</code>), les composants d√©crits dans <code>A</code>.</p>
<p>La premi√®re approche, et la plus √©vidente, est d'utiliser leurs noms complets
(un appel <strong>totalement qualifi√©</strong>) en utilisant le <strong>chemin</strong> du module. Par
exemple, cr√©ons un couple de <code>int</code> et de <code>A.a</code> :</p>
<pre><code class="language-ocaml">let c_a = (A.a_a, A.B.b_b)
</code></pre>
<p>Par contre, il arrive que le fait d'utilis√© les chemins complets puisse √™tre
<em>r√©barbatif</em> (voire totalement illisible). C'est pour √ßa que nous allons voir
comment <strong>importer les composants du module <code>A</code> dans le module <code>C</code></strong>. Cependant,
comme le but de l'article n'est pas d'√™tre un didacticiel sur l'ouverture et
l'inclusion, mais d'explorer les ouvertures g√©n√©ralis√©es pour d√©crire des
sch√©mas d'importations, nous ne nous √©tendrons pas sur ces deux fonctionnalit√©s
qui sont d√©j√† fortemment d√©crites dans le <a href="https://v2.ocaml.org/releases/5.1/htmlman/index.html">manuel du
langage</a> ‚Äî dans les
sections d√©di√©es <a href="https://v2.ocaml.org/releases/5.1/htmlman/moduleexamples.html">aux
modules</a>, <a href="https://v2.ocaml.org/releases/5.1/htmlman/overridingopen.html">√† la
surcharge li√©e aux
ouvertures</a> et
<a href="https://v2.ocaml.org/releases/5.1/htmlman/generalizedopens.html">aux ouvertures
g√©n√©ralis√©es</a>.</p>
<h3 id="ouverture-de-modules">Ouverture de modules</h3>
<p>La primitive <code>open</code> permet <em>d'importer</em> les composants d'un module dans un autre
module, <strong>sans re-exporter</strong> ces derni√®res dans le module courant. Par exemple,
utilisons <code>open</code> pour r√©√©crire la fonction <code>c_a</code> :</p>
<div class="md-multicols">
<pre><code class="language-ocaml">open A

let c_a = (a_a, B.b_b)
</code></pre>
<pre><code class="language-ocaml">val c_a : int * A.a
</code></pre>
</div>
<p>Comme on peut le voir dans la signature (inf√©r√©e), <strong>n'exporte pas</strong> les
<em>composants</em> du module <code>A</code> et r√©f√©rence le type <code>a</code> par son chemin complet. Il
serait aussi possible d'ouvrir <code>A.B</code> en utilisant <code>open A.B</code> ou encore <code>open B</code>
(car <code>A</code> est d√©j√† ouvert).</p>
<p>De la m√™me mani√®re qu'il est possible d'ouvrir des modules dans
<em>l'impl√©mentation</em>, il est aussi possible d'ouvrir des modules dans <em>la
signature</em>, permettant de r√©duire le chemin pour d√©crire des types (ou des
modules).</p>
<h4 id="ouverture-locale-de-modules">Ouverture locale de modules</h4>
<p>Les cas d'ouvertures que nous avons observ√©s pr√©c√©demment √©taient <strong>globales</strong>
au module dans lequelle elles √©taient invoqu√©es, ce qui peut √™tre un peu
contraignant quand on veut ouvrir plusieurs modules ‚Äî exposant, par exemple, des
op√©rateurs arithm√©tiques. Heureusement, il est possible d'ouvrir <strong>au niveau de
l'expression</strong>, de deux mani√®res diff√©rentes :</p>
<ul>
<li>
<p><code>let open Module in ...</code> o√π dans l'expression suivant ce bloc ‚Äî donc
lexicalement born√© ‚Äî <code>Module</code> sera ouvert <em>localement</em>. Ce qui est tr√®s utile
pour n'ouvrir un module que dans une fonction ;</p>
</li>
<li>
<p><code>Module.(...)</code> o√π <code>Module</code> ne sera ouvert ‚Äî lexicalement born√© aussi ‚Äî
uniquement entre les parenth√®ses. Ce qui est tr√®s utile pour n'ouvrir un
module que dans une expression, par exemple, imaginons que le module <code>Float</code>
expose un module <code>Infix</code>, exposant les op√©rateurs arithm√©tiques usuels pour
l'arithm√©tique, il serait possible de d√©crire une op√©ration entre des
flottants de cette mani√®re :<br />
<code>let x = Float.Infix.(1.2 + 3.14 + 1.68)</code>.</p>
</li>
</ul>
<p>L'absence d'ouverture locale peut √™tre tr√®s handicapant. Par exemple, le langage
<a href="https://fsharp.org/"><code>F#</code></a> ne permet que des <a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/import-declarations-the-open-keyword">ouvertures
globales</a>
ce qui rend la d√©finition d'op√©rateurs dans un module d√©di√© laborieuse,
pr√©conisant l'utilisation de <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading">surcharge
d'op√©rateurs</a>
(ou encore de <a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/statically-resolved-type-parameters">Statically Resolved Type
Parameters</a>)
engendrant parfois beaucoup de complexit√©.</p>
<h3 id="inclusion-de-modules">Inclusion de modules</h3>
<p>La primitive <code>include</code> ressemble tr√®s fort √† la primitive <code>open</code> sauf qu'elle ‚Äî
comme son <em>nom</em> l'indique ‚Äî inclus le contenu du module cibl√© dans le corps du
module o√π elle est appel√©e. Par exemple, si nous avions utilis√© <code>include</code> au
lieu de <code>open</code> dans notre exemple pr√©c√©dent, observons l'incidence sur la
signature inf√©r√©e :</p>
<div class="md-multicols">
<pre><code class="language-ocaml">include A

let c_a = (a_a, B.b_b)
</code></pre>
<pre><code class="language-ocaml">type a = A.a = T_a
val a_a : int
val a_b : a
module B = A.B
val c_a : int * A.a
</code></pre>
</div>
<p>M√™me si la signature <em>varie l√©g√®rement</em> de celle que nous avions d√©finie en
introduction ‚Äî il y a quelques subtilit√©s concernant les propagations
<strong>d'√©galit√©s de types et de modules</strong>, d√©crites dans la section <a href="https://v2.ocaml.org/releases/5.1/htmlman/moduletypeof.html">&quot;Recovering the
type of a module&quot;</a>,
li√©es au
<a href="https://discuss.ocaml.org/t/extend-existing-module/1389/7">renforcement</a> ‚Äî on
peut observer que le contenu du module <code>A</code> a √©t√© <em>inclus</em>, <em>ajout√©</em> au module
<code>C</code>. Au contraire de l'ouverture, il n'est <strong>pas possible de faire de
l'inclusion locale</strong>, ce qui est parfaitement logique parce que <strong>de l'inclusion
au niveau local aurait exactement le m√™me effet qu'une ouverture</strong>.</p>
<p>De mon exp√©rience personnelle, je retire g√©n√©ralement deux cas d'usages
sp√©cfiques √† l'utilisation de <code>include</code> :</p>
<ul>
<li>
<p>l'extension d'un module existant (par exemple, ajouter une fonction au module
<code>List</code> dans le cadre de mon projet, ou pour faire une extension √† la
biblioth√®que standard) ;</p>
</li>
<li>
<p>l'inclusion de sous-modules dans un module parent. Par exemple, il est assez
courant que dans un module, on retrouve des op√©rateurs (o√π des <a href="https://v2.ocaml.org/releases/5.1/htmlman/bindingops.html#start-section">op√©rateurs de
liaison</a>)
qu'il est assez courant de <em>confiner</em> dans des sous-modules d√©di√©s
(g√©n√©ralement <code>Infix</code> et <code>Syntax</code>). Pour des raisons d'API, les re-exporter au
niveau du <em>module m√®re</em> peut √™tre une bonne id√©e. C'est d'ailleurs
<a href="https://github.com/xvw/preface/blob/master/lib/preface_specs/indexed_functor.mli#L72">intensivement utilis√© dans
Preface</a>.</p>
</li>
</ul>
<p>Les inclusions sont un outils puissant d'extension, mais aussi du mutualisation
de code et il y a <strong>beaucoup √† dire</strong> car √ßa peut souvent impliquer la pr√©sence
de <em>substitution</em>, <em>substitution d√©structive</em> ou de renforcement, ce qui
impliquerait la r√©daction d'un article d√©di√© !</p>
<h3 id="ouverture-vs-inclusion-avant-ocaml-408">Ouverture VS inclusion avant OCaml <code>4.08</code></h3>
<p>Avant la fusion de la proposition de la <strong>g√©n√©ralisation des ouvertures</strong>, il
existait une diff√©rence <strong>sensible</strong> dans l'usage des <code>open</code> contre <code>include</code> :
le param√®tre que prenait les deux primitives.</p>
<ul>
<li>
<p><code>open</code> prenait <a href="https://v2.ocaml.org/releases/4.07/htmlman/names.html#module-path">un chemin de
module</a>,
par exemple : <code>A</code> ou encore <code>A.B.C</code></p>
</li>
<li>
<p><code>include</code> prenait <a href="https://v2.ocaml.org/releases/4.07/htmlman/modules.html#module-expr">une expression de
module</a>,
par exemple : des chemins comme <code>A</code> ou <code>A.B.C</code>, mais aussi des applications de
foncteurs comme <code>F(X)</code>, des modules contraints par des signatures : <code>(M : S)</code>
ou directement le corps d'un module : <code>struct ... end</code>.</p>
</li>
</ul>
<p>Cette diff√©rence de flexibilit√© impliquait l'utilisation de d√©tours assez
g√©nants pour atteindre le m√™me niveau d'expressivit√© pour les ouvertures en
comparaison aux inclusions. En effet, pour permettre aux ouvertures de composer
avec des applications de foncteurs ou des contraintes, il fallait passer par des
modules interm√©diaires.</p>
<p>Dans le cas de l'utilisation d'un chemin, les deux appels sont ‚Äî en terme
d'expressivit√© ‚Äî identiques, parce qu'un chemin peut aussi √™tre une expression
de module :</p>
<div class="md-multicols">
<pre><code class="language-ocaml">include A.B.C
</code></pre>
<pre><code class="language-ocaml">open A.B.C
</code></pre>
</div>
<p>Par contre, d√®s que l'on essaie d'ouvrir des cas un peu plus complexes,
nativement support√©s par <code>include</code>, on devait rapidement introduire des modules
interm√©diaires :</p>
<div class="md-multicols">
<pre><code class="language-ocaml">include F(X)
include (M : S)
include struct
  let x = 10
end
</code></pre>
<pre><code class="language-ocaml">module A = F(X)
open A

module B : S = M
open B

module C = struct
  let x = 10
end
open C
</code></pre>
</div>
<p>M√™me si, aux premiers abords, √ßa peut ne pas sembler dramatique, l'introduction
de modules interm√©diaires impose de ne pas les exporter dans la signature du
module qui les ouvres (dans son <code>mli</code> ou sa signature). En compl√©ment, alors que
<code>open</code> et <code>include</code> sont souvent pr√©sent√©s sym√©triquement, on ne pouvait que
d√©plorer leur absence de sym√©trie dans les param√®tres qu'ils prenaient.
Heureusement, depuis <code>4.08</code> (qui a tout de m√™me √©t√© <strong>lib√©r√©e en Juin 2019</strong>),
gr√¢ce √† la g√©n√©ralisation des ouvertures, <code>open</code> prend maintenant une expression
de module arbitraire, exactement comme <code>include</code>, nous permettant de l'utiliser
pour mimer ces fameux sch√©mas d'importation, √©voqu√©s en introduction de cet
article.</p>
<h3 id="un-premier-bnfice">Un premier b√©n√©fice</h3>
<p>Le fait que la primitive <code>open</code> puisse prendre des expressions de modules
arbitraires offre un premier b√©n√©fice ‚Äî <em>probablement futile quand on aime
√©crire les signatures de ses modules</em> : <strong>la d√©finition d'expressions locales</strong>.
En effet, l'ouverture d'un module n'exporte pas son contenu, il est donc
possible de d√©crire tr√®s facilement des valeurs <em>top-level</em> non-export√©e en les
d√©finissant dans une expression <code>open struct ... end</code>. Par exemple :</p>
<div class="md-multicols">
<pre><code class="language-ocaml">open struct
  let x = 10
  let y = 20
end
let z = x + y
</code></pre>
<pre><code class="language-ocaml">val z : int
</code></pre>
</div>
<p>Les fonctions <code>x</code> et <code>y</code> sont <strong>confin√©es dans une ouverture</strong>, elles ne sont
donc pas export√©es, ce qui peut √™tre tr√®s utiles quand on veut d√©finir des
valeurs (des types ou des modules) localement. De plus comme <strong>une structure
peut √™tre contrainte par une signature</strong>, il est aussi, par exemple, possible
d'encapsuler un √©tat mutable partag√© dans l'ouverture locale, <strong>ne s'√©chappant
pas du p√©rim√®tre de son ouverture</strong>. Voici deux exemples dans lesquels il est
impossible de modifier la cellule de r√©f√©rence sans passer par les <em>combinateurs
export√©s</em>, le premier utilisant une contrainte, le second en utilisant des
ouvertures locales imbriqu√©es :</p>
<div class="md-multicols">
<pre><code class="language-ocaml">open (
  struct
    let cell = ref 0
    let incr () = cell := !cell + 1
    let decr () = cell := !cell - 1
  end :
    sig
      val incr : unit -&gt; unit
      val decr : unit -&gt; unit
    end)
</code></pre>
<pre><code class="language-ocaml">open struct
  open struct 
    let cell = ref 0 
  end
  let incr () = cell := !cell + 1
  let decr () = cell := !cell - 1
end

</code></pre>
</div>
<p>M√™me si l'approche classique utilis√©e par un d√©veloppeur OCaml est d'utiliser
des signatures pour des probl√©matiques <strong>d'encpasulation</strong>, utilis√©e comme
telle, l'ouverture g√©n√©ralis√©e de modules permet de cacher, de mani√®re
relativement √©l√©gante, certains <em>√©l√©ments de plomberies</em> n√©c√©ssaires √† la
construction d'un module (qui lui, devrait exposer une API publique au moyen
d'une signature).</p>
<p>Maintenant que nous avons observ√© <em>des exemples</em> d'utilisation de l'ouverture
g√©n√©ralis√©e, voyons de quelle mani√®re elle rend la pr√©sence d'un langage d√©di√©
aux sch√©mas d'importations <strong>discutablement utiles</strong>.</p>
<h2 id="schmas-dimportation">Sch√©mas d'importation</h2>
<p>Depuis que la <strong>modularit√©</strong> est devenue un des cheveaux de bataille de la
conception de logiciels ‚Äî JavaScript a d'ailleurs <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">empil√© les
propositions</a>
en faisant d√©pendre la strat√©gie de modularisation, et d'importation, du
<em>cadriciel</em> ou du syst√®me de construction utilis√© ‚Äî les langages (comme
<a href="https://www.python.org/">Python</a> ou encore <a href="https://www.haskell.org/">Haskell</a>)
ont propos√© des fonctionnalit√©s similaires √† la primitive <code>open</code> de OCaml pour
importer des composants dans le module courant. G√©n√©ralement, ces directives
d'importation sont <em>un tout petit langage √† part enti√®re</em>, r√©git par ses propres
r√®gles et sa propre grammaire. Depuis que <code>open</code> est g√©n√©ralis√©, on peut
<em>encoder</em> une grande partie des constructions d'importation usuelles ‚Äî m√™me si
nous verrons que certaines, propos√©es par Haskell, peuvent √™tre un peu verbeuse
√† encoder.</p>
<p>Pour l'exemple, nous utiliserons le module suivant comme cible d'importation :</p>
<pre><code class="language-ocaml">module Foo : sig
  val x : int
  val y : string
  val z : char
end
</code></pre>
<p>Il existe cependant une <strong>nuance essentielle</strong> sur la notion <strong>d'importation
qualifi√©e</strong>, en effet, en Haskell, pour √™tre utilis√©, un module <strong>doit √™tre
import√©</strong>, alors qu'en OCaml, c'est la description du sch√©ma de compilation qui
indique la pr√©sence ou non d'un module. Dans nos diff√©rents exemples, nous
supposerons que le module <code>Foo</code>, que nous avons d√©crit pr√©c√©demment, est pr√©sent
dans notre sch√©ma de compilation. De ce fait, pour les importations qualifi√©e ‚Äî
o√π les termes sont toujours pr√©fix√©es par leur cheminm de module, il n y a
aucune c√©r√©monie aditionnelle n√©c√©ssaire. Il est importer de garder √† l'esprit
que les astuces pr√©sent√©es ci-dessous peuvent se composer pour construit des
sch√©mas d'importations tr√®s sp√©cifiques (et probablement irr√©alistes),
d√©montrant que, au coup d'un peu de verbosit√©, l'approche <em>langage</em> permet
encore plus de flexibilit√© qu'un <em>DSL</em> d√©di√© √† l'importation rigide.</p>
<h3 id="importation-non-qualifie">Importation non-qualifi√©e</h3>
<p>La premi√®re directive consiste simplement √† importer les d√©finition de <code>Foo</code>
dans le module courant, les fonctions <code>x</code>, <code>y</code> et <code>z</code> :</p>
<div class="md-multicols">
<pre><code class="language-haskell">import * from Foo
</code></pre>
<pre><code class="language-ocaml">open Foo
</code></pre>
</div>
<p>Il n y a pas de subtilit√©, importer toutes les termes expos√©s par <code>Foo</code> consiste
simplement √† l'ouvrir. Il n y a pas grand chose √† dire de plus, on ne tire ici
partit d'aucune subtilit√© du langage.</p>
<h3 id="qualification-renomme">Qualification renomm√©e</h3>
<p>Une autre directive commune consiste √† renommer le module, par exemple, importer
<code>Foo</code> sous le nom <code>Bar</code> en rendant accessible dans le module <code>Bar.x</code>, <code>Bar.y</code> et
<code>Bar.z</code>, pour cela, on peut utiliser <a href="https://v2.ocaml.org/releases/5.1/htmlman/modulealias.html">alias de module
<em>type-level</em></a>.</p>
<div class="md-multicols">
<pre><code class="language-haskell">import Foo as Bar
</code></pre>
<pre><code class="language-ocaml">open struct module Bar = Foo end
</code></pre>
</div>
<p>On utilise la construction <code>open struct ... end</code> pour ne pas √©chapper notre
alias dans l'API publique de notre module ‚Äî m√™me si, en pr√©sence d'une
signature, cette coquetterie n'est pas n√©c√©ssaire car il suffit de ne pas
exporter le module <code>Bar</code> dans la signature.</p>
<h4 id="prsence-du-module-renomm">Pr√©sence du module renomm√©</h4>
<p>Le fait d'utiliser un <strong>alias de module</strong> laisse le module <code>Foo</code> accessible, et
dans certains cas, on voudrait le rendre inaccessible. La solution la plus
simple est de simplement <em>vider le module</em> et pour clarifier l'erreur li√© √† son
utilisation non-d√©sir√©e, on peut ajouter une
<a href="https://v2.ocaml.org/releases/5.1/htmlman/alerts.html#start-section">alerte</a>
indiquant que le module a √©t√© supprim√© :</p>
<pre><code class="language-ocaml">open struct
  module Bar = Foo
  module Foo = struct end [@@alert erased]
end
</code></pre>
<p>Rendant l'exploitation du module <code>Foo</code>, dans le module courant, impossible.
Cependant, comme il est d'usage de fournir des signatures de modules ‚Äî et donc
d'en contr√¥ler son API publique, on trouvera plus r√©guli√®rement des renommages
de cette forme : <code>module Bar = Foo</code>. De plus, je ne suis pas convaincu que l'interdiction d'acc√®s au</p>
<h4 id="renommage-imbriqu">Renommage imbriqu√©</h4>
<p>On pourrait imaginer ce genre de renommage : <code>import Foo as Bar.Baz</code>, mais OCaml
ne permet pas de d√©crire des chemins complets de cette forme <code>module Bar.Baz = Foo</code>, il faut donc d√©crire la hi√©rarchie d'imbrication des modules, de cette
mani√®re, rendant les fonctions <code>Bar.Baz.x</code>, <code>Bar.Baz.y</code> et <code>Bar.Baz.z</code>
disponibles dans le module courant :</p>
<pre><code class="language-ocaml">open struct 
  module Bar = struct 
    module Baz = Foo 
  end 
end
</code></pre>
<p>Ce qui est, je vous l'accorde, un peu verbeux, mais si pour des raisons
obscures, vous voudriez renommer un module existant avec un chemin compos√©, vous
pouvez, en d√©clarant la hi√©rarchie des modules.</p>
<h3 id="importation-slective">Importation s√©lective</h3>
<p>Il arrive parfois que l'importation <strong>compl√®te</strong> du module soit excessive et que
l'on ne voudrait que quelques composants expos√©s par ce dernier. C'est pour √ßa
qu'il est possible de n'importer qu'une partie d'un module. Dans cet exemple, ne
nous voudrions n'importer que <code>x</code> et <code>y</code> :</p>
<div class="md-multicols">
<pre><code class="language-haskell">import {x, y} from Foo
</code></pre>
<pre><code class="language-ocaml">open struct
  let x = Foo.x
  let y = Foo.y
end
</code></pre>
</div>
<p>M√™me si cette approche est, elle aussi, un peu verbeuse, elle n'importe, dans le
module courant, que les fonctions <code>x</code> et <code>y</code>. Il est possible de simplifier
cette √©criture en utilisant des <em>n-uplet</em> et des ouvertures locales :</p>
<pre><code class="language-ocaml">open struct
  let (x, y) = Foo.(x, y)
end
</code></pre>
<p>Sinon, il est aussi possible de <strong>contraindre l'ouverture</strong> au moyen d'une
signature, ce qui implique de devoir le type des fonctions √† exporter :</p>
<pre><code class="language-ocaml">open (Foo : sig
  val x : int
  val y : string end)
</code></pre>
<p>Plusieurs propositions (<a href="https://github.com/ocaml/ocaml/pull/10013"><code>#10013</code></a> et
<a href="https://github.com/ocaml/ocaml/issues/11558#issuecomment-1255946104"><code>#11558</code></a>)
ont √©t√© faites pour permettre d'utiliser du
<a href="https://v2.ocaml.org/releases/5.1/htmlman/bindingops.html#ss%3Aletops-punning"><em>let-punning</em></a>
rendant la syntaxe moins lourde, cependant dans la premi√®re a √©t√© d√©lest√©e du
<em>punning</em> pour les membres de modules et la seconde est toujours au stade de
l'issue.</p>
<h4 id="importation-slective-avec-renommage">Importation s√©lective avec renommage</h4>
<p>Comme les deux premi√®res propositions laissent √† l'utilisateurs un contr√¥le sur
le nom (ce n'est que de la <em>red√©finition</em> de fonction), on peut trivialement
int√©grer le renommage. Dans cet exemple, on expose <code>x</code> et <code>new_y_name</code>, qui
appelle <code>Foo.y</code> :</p>
<div class="md-multicols">
<pre><code class="language-haskell">import {x, y as new_y_name} from Foo
</code></pre>
<pre><code class="language-ocaml">open struct
  let (x, new_y_name) = Foo.(x, y)
end
</code></pre>
</div>
<p>Sans surprise, le renommage est assez simple, par contre, si l'on voulait
utiliser l'approche par signature, il faudrait utiliser un peu plus d'astuce en
couplant une ouverture et une inclusion :</p>
<pre><code class="language-ocaml">open (struct
    include Foo
    let new_y_name = y
  end : sig
    val x : int
    val new_y_name : string end)
</code></pre>
<p>Cependant, cette derni√®re proposition est tellement verbeuse qu'elle en devient
un peu irrationnelle ‚Äî surtout en comparaison avec la pr√©c√©dente ‚Äî que j'imagine
que c'est le genre de code que l'on ne verra jamais ‚Äî ou du moins, que l'on ne
voudrait jamais voir ‚Äî dans une base de code r√©guli√®re. En revanche, m√™me si la
proposition est lourde, je trouve qu'elle montre tout de m√™me assez
explicitement comment <strong>il est possible de composer les diff√©rentes
constructions et outils vu pr√©c√©demment</strong>.</p>
<h3 id="importation-par-exclusion">Importation par exclusion</h3>
<p>Haskell poss√®de un modificateur d'importation un peu particulier dont j'ai
longuement h√©sit√© √† parler parce que je n'avais aucune id√©e de comment
l'impl√©menter, mais c'√©tait sans compter, une fois de plus, sur l'inestimable
aide de <a href="https://github.com/Octachron">@octachron</a> et de
<a href="https://github.com/xhtmlboi">@xhtmlboi</a> qui m'ont tout deux donn√©,
<em>approximativement</em>, la m√™me solution . Ce modificateur permet d'importer tout
un module, except√© une liste de composant. Dans cet exemple, <code>x</code> et <code>y</code> seront
import√© parce que l'on importe <strong>tout le module <code>Foo</code></strong>, except√© la fonction
<code>z</code>.</p>
<pre><code class="language-haskell">import Foo hidding (z)
</code></pre>
<p>OCaml ne dipose pas, nativement, la possibilit√© de construire des
<strong>intersections</strong> ou des <strong>diff√©rences</strong> de modules. La solution propos√©e par
<a href="https://github.com/Octachron">@octachron</a> et
<a href="https://github.com/xhtmlboi">@xhtmlboi</a> repose sur de la r√©ecriture de
fonction, adjoint √† l'utilisation d'une alerte, d'une mani√®re un peu similaire √†
ce que nous avions fait pour √©vincer un module renomm√©. Par contre, avant
d'observer la solution propos√©e, faisons un petit d√©tour par le variant vide.</p>
<h4 id="le-type-somme-vide">Le type somme vide</h4>
<p>En OCaml, il est possible de d√©finir un type somme qui ne contient aucun
constructeur, en utilisant <a href="https://v2.ocaml.org/releases/5.1/htmlman/emptyvariants.html#start-section"><strong>le variant
vide</strong></a>
et qui permet, dans les grandes lignes, de <em>d√©crire des valeurs non
repr√©sentables</em>. Pour le d√©finir, il suffit de construire une somme avec une
branche vide (qui, <strong>attention</strong>, n'est pas le <a href="https://en.wikipedia.org/wiki/Bottom_type">type
bottom</a>, not√© <code>‚ä•</code>) :</p>
<pre><code class="language-ocaml">type empty = |
</code></pre>
<p>Pour se convaincre que le compilateur peut r√©futer les cas contenant une valeur
de type <code>empty</code>, on peut tr√®s facilement l'exp√©rimenter avec de la
correspondance de motifs, dans l'exemple qui suit, le compilateur ne l√®ve aucun
avertissement car les motifs sont exhaustifs. Comme il n'est pas possible de
construire une valeur de type <code>empty</code> (sauf en trichant, en utilisant, par
exemple de la sorcellerie comme l'in√©narrable fonction <code>Obj.magic</code>), on peut
<em>r√©futer</em> le traitement du cas d'erreur :</p>
<pre><code class="language-ocaml">let f : ('a, empty) result -&gt; 'a = function
  | Ok x -&gt; x
</code></pre>
<p>Mais dans notre cas d'usage, ce n'est pas la r√©futation qui va nous int√©resser
mais plut√¥t le fait qu'il n'est pas possible de d√©crire une valeur de type
<code>empty</code> pour permettre l'√©viction de fonctions.</p>
<h4 id="suppression-de-fonctions">Suppression de fonctions</h4>
<p>La solution qui m'a √©t√© propos√©e consiste √† rendre les fonctions que l'on veut
expulser du module <strong>impossible √† appeler</strong>. Pour √ßa, nous allons d'abord cr√©er
une fonction <em>placeholder</em> que nous utiliserons pour √©craser une fonction
existante :</p>
<pre><code class="language-ocaml">type empty = |
let expelled : empty -&gt; unit = fun _ -&gt; ()
</code></pre>
<p>A priori, notre fonction <code>expelled</code> est impossible √† appeler car on ne peut la
provisionner d'une valeur de type <code>empty</code>, cette derni√®re √©tant impossible √†
produire. Nous allons donc pouvoir <strong>inclure le module que l'on veut refiner</strong>
et ensuite <strong>substituer les fonctions que l'on veut exclure</strong> avec notre
fonction <code>expelled</code>, et nous les associerons √† une alerte pour clarifier
l'erreur que l'utilisation d'une fonction √©vinc√©e produira :</p>
<pre><code class="language-ocaml">open struct
  include Foo
  let (z [@alert expelled]) = expelled
end
</code></pre>
<p><em>Et voila</em>, on peut √™tre √† peu pr√®s s√ªr que l'utilisation de <code>z</code> provoquera une
erreur de compilation, et la compilation d'un module qui l'exploite soul√®vera un
avertissement. En revanche, la solution est loin d'√™tre parfait car elle
<strong>n'√©limine pas</strong> le composant du module. Pour √™tre tr√®s honn√™te, j'ai <strong>tr√®s
rarement</strong> eu l'occasion de regretter l'absence de cette fonctionnalit√©,
nativement. De mon point de vue, l'importation s√©l√®ctive suffit g√©n√©ralement
largement.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Je pense sinc√®rement que, dans une utilisation quotidienne de OCaml, nous sommes
tr√®s rarement confront√© √† ce genre de besoins. L'objectif de l'article √©tait,
<em>essentiellement</em>, de montrer comment utiliser certaines primitives li√©es au
langage de modules en compl√©ment de la <em>g√©n√©ralisation des ouvertures</em> pour
d√©montrer qu'avoir des primitives expressives et composables permet de
reproduire, parfois trivialement (et parfois moins trivialement), des sch√©mas
d'importations classiques, pr√©sents dans d'autres langages de programmation. Il
existe probablement d'autres encodages <em>rigolos</em> ‚Äî probablement √† base de
<em>foncteurs</em> ‚Äî et n'h√©sitez pas √† me les faire parvenirs pour que je puisse
compl√©ter cet article !</p>
<p>Pour terminer, j'ajouterai que m√™me si j'ai fi√®rement <em>fanfaronn√©</em> en pr√©tendant
que ce n'√©tait pas commun de programmer de cette mani√®re en OCaml, la pr√©sence
de paquet comme <a href="https://ocaml.org/p/ppx_import/latest">ppx_import</a> ou
<a href="https://github.com/johnyob/ppx-open">ppx_open</a> indique que quelques all√®gement
syntaxique ne serait pas de trop, notamment pour les importation s√©lectives.</p>
</article>
</main>
    <footer>
      <div class="container">
        <p>
          Diffus√© sous licence
          <a href="https://creativecommons.org/licenses/by-sa/4.0/">
            <strong>CC BY-SA</strong>
          </a>
        </p>
        <p>
          Honteuseument g√©n√©r√© par
          <a href="https://github.com/xhtmlboi/yocaml">
            <strong>YOCaml</strong>
          </a>
        </p>
        <p class="feed-icons"><a href="/feeds.html">üÆæ</a></p>
      </div>
    </footer>
    <script>
      capsule.mount();
    </script>
  </body>
</html>
