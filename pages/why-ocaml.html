<!doctype html>
<html>
  <head><meta charset="utf-8"><meta name="keywords" content="programmation, ocaml, opinion" /><meta name="description" content="Une explication détaillée de pourquoi j&apos;ai fais le choix de OCaml pour langage de programmation &quot;par défaut&quot; pour chaque projet." /><meta name="generator" content="YOCaml" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:title" content="Sur le choix d&apos;OCaml" /><meta name="og:title" content="Sur le choix d&apos;OCaml" /><meta name="twitter:description" content="Une explication détaillée de pourquoi j&apos;ai fais le choix de OCaml pour langage de programmation &quot;par défaut&quot; pour chaque projet." /><meta name="og:description" content="Une explication détaillée de pourquoi j&apos;ai fais le choix de OCaml pour langage de programmation &quot;par défaut&quot; pour chaque projet." /><meta name="og:site_name" content="xvw.lol" /><meta name="og:type" content="article" /><meta name="og:article:published_time" content="2024-08-25 00:00:00" /><meta name="og:article:section" content="programmation" /><meta name="og:article:tag" content="programmation" /><meta name="og:article:tag" content="ocaml" /><meta name="og:article:tag" content="opinion" /><meta name="author" content="xvw, Xavier Van de Woestyne" /><meta name="twitter:site" content="@vdwxv" /><meta name="twitter:creator" content="@vdwxv" /><meta name="og:profile:username" content="xvw" /><meta name="og:profile:first_name" content="Xavier" /><meta name="og:profile:last_name" content="Van de Woestyne" /><meta name="og:image" content="https://xvw.lol/images/xvw-cover.png" /><meta name="og:image:url" content="https://xvw.lol/images/xvw-cover.png" /><meta name="og:image:type" content="image/png" /><meta name="og:image:width" content="1200" /><meta name="og:image:height" content="630" /><meta name="og:image:alt" content="Cover image xvw.lol" /><meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="/css/capsule.css" rel="stylesheet">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="me" href="https://x.com/vdwxv"><link rel="manifest" href="/site.webmanifest">
    <link rel="canonical" href="https://xvw.lol/pages/why-ocaml.html">
    <link rel="alternate" type="application/atom+xml" href="/atom.xml" />
    <link rel="alternate" type="application/atom+xml" href="/pages.xml" />
    <script>
      /* see:
       * https://stackoverflow.com/questions/21147149/flash-of-unstyled-content-fouc-in-firefox-only-is-ff-slow-renderer*/
      let FF_FOUC_FIX;
    </script>
    <title>xvw.lol - Sur le choix d&apos;OCaml</title>
  </head>
  <body>
    <header>
      <div id="header-content">
        <div><h3><a href="/">xvw.lol</a></h3></div>
        <div>
          <nav class="set breadcrumb">
            <a href="/">Index</a><a href="/programming.html">Programmation</a><a href="/programming.html#index-opinions">Opinions</a></nav>
        </div>
      </div>
    </header>
    <main>
      <div id="main-content" class="fr-content"><h1>Sur le choix d&apos;OCaml</h1><div class="set publication-date"><time class="date-repr"
        data-prefix="publié le"
        datetime="2024-08-25 00:00:00">
    2024-08-25
  </time></div><article class="synopsis"><p>J'ai commencé à utiliser régulièrement le langage <a href="https://ocaml.org">OCaml</a> vers 2012, et depuis, mon intérêt et mon engouement pour ce langage n'ont cessé de croître. Il est devenu mon choix de prédilection pour presque tous mes projets personnels, influençant également mes choix professionnels.
Depuis 2014, je participe activement aux conférences grand public dédiées à la programmation et à la construction de logiciels, où j'exprime souvent mon enthousiasme pour OCaml de manière parfois excessive (mais toujours passionnée). Cela m'a valu, de manière amicale, le surnom <em>d'évangéliste d'OCaml</em>, une appellation qui, je l'avoue, me flatte énormément.
Convaincu que mon intérêt pour OCaml est justifié, je prends souvent plaisir à énumérer les nombreux avantages de cette technologie. J'ai donc décidé de coucher par écrit les raisons pour lesquelles je considère OCaml comme un excellent choix pour divers types de projets. Cette page me permettra de partager facilement mes arguments et d'expliquer pourquoi OCaml mérite attention et intérêt.
De plus, je ne suis pas seul à penser cela. Malgré l'idée reçue que OCaml ne serait pas un choix pragmatique pour l'industrie, de grandes entreprises telles que <a href="https://engineering.fb.com/?s=ocaml">Meta</a>, <a href="https://www.microsoft.com/en-us/research/project/slam/?from=https://research.microsoft.com/en-us/projects/slam/&amp;type=exact">Microsoft</a>, <a href="https://tech.ahrefs.com/tagged/ocaml">Ahref</a>, <a href="https://tarides.com">Tarides</a>, <a href="https://ocamlpro.com/">OCamlPro</a>, <a href="https://www.bloomberg.com/company?s=ocaml">Bloomberg</a>, <a href="https://github.com/moby/vpnkit">Docker</a>, <a href="https://www.janestreet.com/technology/">Janestreet</a>, <a href="https://xapi-project.github.io/">Citrix</a>, <a href="https://tezos.com">Tezos</a>, et <a href="https://ocaml.org/industrial-users">bien d'autres</a> l'utilisent activement.</p>
</article><section class="toc"><ul><li><a href="#avant-propos" data-toc-target="avant-propos">Avant-propos</a><ul><li><a href="#autres-ressources" data-toc-target="autres-ressources">Autres ressources</a></li></ul></li><li><a href="#ocaml-en-tant-que-langage" data-toc-target="ocaml-en-tant-que-langage">OCaml en tant que langage</a><ul><li><a href="#sur-la-vérification-statique-des-types" data-toc-target="sur-la-vérification-statique-des-types">Sur la vérification statique des types</a></li><li><a href="#fonctionnalités-du-langage" data-toc-target="fonctionnalités-du-langage">Fonctionnalités du langage</a><ul><li><a href="#un-langage-multi-paradigmes" data-toc-target="un-langage-multi-paradigmes">Un langage multi-paradigmes</a><ul><li><a href="#syntaxe-à-la-ml" data-toc-target="syntaxe-à-la-ml">Syntaxe à la ML</a></li><li><a href="#étroitement-lié-à-la-recherche" data-toc-target="étroitement-lié-à-la-recherche">Étroitement lié à la recherche</a></li></ul></li><li><a href="#types-algébriques" data-toc-target="types-algébriques">Types algébriques</a></li><li><a href="#programmation-modulaires-et-langage-de-modules" data-toc-target="programmation-modulaires-et-langage-de-modules">Programmation modulaires et langage de modules</a></li><li><a href="#injection-et-inversion-de-dépendances" data-toc-target="injection-et-inversion-de-dépendances">Injection et inversion de dépendances</a><ul><li><a href="#par-le-biais-de-modules" data-toc-target="par-le-biais-de-modules">Par le biais de modules</a></li><li><a href="#par-le-biais-deffets-définis-par-lutilisateur" data-toc-target="par-le-biais-deffets-définis-par-lutilisateur">Par le biais d'effets définis par l'utilisateur</a></li></ul></li></ul></li><li><a href="#concernant-le-futur" data-toc-target="concernant-le-futur">Concernant le futur</a></li><li><a href="#points-faibles" data-toc-target="points-faibles">Points faibles</a></li><li><a href="#pour-conclure-sur-le-langage" data-toc-target="pour-conclure-sur-le-langage">Pour conclure sur le langage</a></li></ul></li><li><a href="#ocaml-en-tant-quécosystème" data-toc-target="ocaml-en-tant-quécosystème">OCaml en tant qu'écosystème</a><ul><li><a href="#compilation-runtimes-et-cibles-additionnelles" data-toc-target="compilation-runtimes-et-cibles-additionnelles">Compilation, runtimes, et cibles additionnelles</a><ul><li><a href="#un-petit-détour-par-mirageos" data-toc-target="un-petit-détour-par-mirageos">Un petit détour par MirageOS</a></li></ul></li><li><a href="#la-plateforme-ocaml" data-toc-target="la-plateforme-ocaml">La plateforme OCaml</a><ul><li><a href="#opam-le-gestionnaire-de-paquets" data-toc-target="opam-le-gestionnaire-de-paquets">OPAM, le gestionnaire de paquets</a></li><li><a href="#dune-le-build-system" data-toc-target="dune-le-build-system">Dune, le build-system</a><ul><li><a href="#sur-le-choix-des-s-expression" data-toc-target="sur-le-choix-des-s-expression">Sur le choix des S-expression</a></li><li><a href="#contribution-à-létat-de-lart-selective-applicative-functor" data-toc-target="contribution-à-létat-de-lart-selective-applicative-functor">Contribution à l'état de l'art: Selective Applicative Functor</a></li><li><a href="#alternatives" data-toc-target="alternatives">Alternatives</a></li></ul></li><li><a href="#lsp-et-merlin-pour-les-éditeurs" data-toc-target="lsp-et-merlin-pour-les-éditeurs">LSP et Merlin pour les éditeurs</a><ul><li><a href="#avènement-de-vscode-lsp-comme-standard" data-toc-target="avènement-de-vscode-lsp-comme-standard">Avènement de VSCode, LSP comme standard</a></li></ul></li><li><a href="#odoc-le-générateur-de-documentation" data-toc-target="odoc-le-générateur-de-documentation">Odoc, le générateur de documentation</a></li></ul></li><li><a href="#bibliothèques-disponibles" data-toc-target="bibliothèques-disponibles">Bibliothèques disponibles</a><ul><li><a href="#aparté-sur-la-bibliothèque-standard" data-toc-target="aparté-sur-la-bibliothèque-standard">Aparté sur la bibliothèque standard</a></li></ul></li><li><a href="#conclusion-de-lécosystème" data-toc-target="conclusion-de-lécosystème">Conclusion de l'écosystème</a></li></ul></li><li><a href="#sur-la-communauté" data-toc-target="sur-la-communauté">Sur la communauté</a></li><li><a href="#quelques-mythes-liés-à-ocaml" data-toc-target="quelques-mythes-liés-à-ocaml">Quelques mythes liés à OCaml</a><ul><li><a href="#ocaml-et-f" data-toc-target="ocaml-et-f">OCaml et F#</a></li><li><a href="#les-opérateurs-doublés-pour-les-flottants" data-toc-target="les-opérateurs-doublés-pour-les-flottants">Les opérateurs doublés pour les flottants</a></li><li><a href="#sur-la-séparation-entre-ml-et-mli" data-toc-target="sur-la-séparation-entre-ml-et-mli">Sur la séparation entre ml et mli</a><ul><li><a href="#gérer-lencapsulation-sans-mli" data-toc-target="gérer-lencapsulation-sans-mli">Gérer l'encapsulation sans mli</a></li><li><a href="#exprimer-linterface-depuis-le-ml" data-toc-target="exprimer-linterface-depuis-le-ml">Exprimer l'interface depuis le ml</a></li><li><a href="#pour-conclure-sur-la-séparation" data-toc-target="pour-conclure-sur-la-séparation">Pour conclure sur la séparation</a></li></ul></li></ul></li><li><a href="#pour-conclure" data-toc-target="pour-conclure">Pour conclure</a></li></ul></section><article><p>Dans ce <em>billet d'opinion</em>, je vais essayer de présenter brièvement ma
rencontre avec le langage, et d'énumérer ses avantages — répartis en
plusieurs rubriques portant sur <em>le langage lui-même</em>, son écosystème
et sa communauté. Je tâcherai également de <em>débunker</em> certains mythes
(ou idées reçues) populaires sur Internet. Par souci de transparence,
il est important de préciser qu'à l'heure où j'écris ces lignes, mon
<a href="https://tarides.com">activité professionnelle</a> consiste <strong>à
travailler pour et sur l'écosystème OCaml</strong>. Cependant, les lecteurs
qui me suivent depuis plusieurs années pourront témoigner que je
faisais la promotion du langage bien avant d'être rémunéré pour
travailler sur l'écosystème OCaml, parfois de manière immodérée.</p>
<h2 id="avant-propos"><a class="anchor" aria-hidden="true" href="#avant-propos"></a>Avant-propos</h2>
<p>Premièrement, cet article expliquera pourquoi je trouve
<strong>personnellement</strong> qu'OCaml est un choix pertinent dans de nombreux
contextes. Mon but n'est pas particulièrement de vous convaincre —
même si cela serait un <em>effet de bord</em> tout à fait bénéfique — et il
est fort probable que beaucoup des arguments que je présenterai
s'appliquent aussi à d'autres langages !</p>
<p>Ensuite, très souvent, quand je propose OCaml à des gens qui
souhaitent découvrir de nouveaux langages ou encore des solutions
écrites en OCaml, on me fait gentiment remarquer que <em>je fais toujours
la promotion d'OCaml</em>. Il est amusant de constater que lorsque les
propositions concernent des langages adoptés _<em>par défaut</em> comme
JavaScript ou des langages plus récents comme
<a href="https://www.rust-lang.org/">Rust</a> ou <a href="https://go.dev/">Go</a>, cela
suscite souvent moins de réactions. Probablement parce que l'on pense
<em>implicitement</em> que la proposition d'un langage <em>moins connu</em> tend
vers l'irrationalité et les préférences personnelles. De mon point de
vue, <strong>proposer OCaml est, dans beaucoup de cas où le contrôle mémoire
fin n'est pas nécessaire, aussi pertinent que proposer Rust</strong> (et
probablement plus).</p>
<p>Pour terminer cet avant-propos, beaucoup de personnes ont été
confrontées à OCaml (ou <a href="https://caml.inria.fr/caml-light/release.fr.html">Caml
Light</a>) en licence
ou en classes préparatoires, l'utilisant dans des contextes souvent
très éloignés de l'industrie. Pour ma part, j'ai commencé à
m'intéresser à OCaml bien avant, grâce au <a href="http://sdz.tdct.org/">Site du
Zéro</a>, où une petite communauté de programmeurs
férus de fonctionnel faisait la promotion de langages moins
<em>mainstream</em> comme <a href="https://ocaml.org">OCaml</a>,
<a href="https://www.erlang.org/">Erlang</a> et
<a href="https://www.haskell.org/">Haskell</a>. Mon interaction avec OCaml à
l'université n'était <strong>que du bonus</strong>.</p>
<h3 id="autres-ressources"><a class="anchor" aria-hidden="true" href="#autres-ressources"></a>Autres ressources</h3>
<p>Je ne suis pas le premier à avoir documenté les raisons qui poussent à
choisir OCaml. Il existe de nombreuses alternatives qui, selon moi,
valent aussi le coup d'être consultées et qui démontrent que les
utilisateurs d'OCaml en sont généralement très satisfaits, les
motivant à communiquer sur <em>comment et pourquoi</em> nous avons fait le
choix du langage comme technologie principale :</p>
<ul>
<li>
<p><a href="https://dev.realworldocaml.org/prologue.html#why-ocaml">&quot;<strong>Why
OCaml?</strong>&quot;</a>,
prologue du livre <a href="https://dev.realworldocaml.org/toc.html">Real World
OCaml</a>, qui présente des
avantages factuels à l'utilisation d'OCaml (et dont l'introduction
propose une frise chronologique). Même si le livre est excellent sur
de nombreux aspects, j'ai pris l'habitude de ne pas le recommander
car je le trouve très biaisé dans son usage, proposant l'utilisation
de bibliothèques, par défaut, qui ne font pas spécialement
l'unanimité dans la communauté.</p>
</li>
<li>
<p><a href="https://cs3110.github.io/textbook/chapters/intro/intro.html">&quot;<strong>Better Programming Through
OCaml</strong>&quot;</a>,
prologue du livre (accompagné de vidéos) <a href="https://cs3110.github.io/textbook/cover.html">OCaml Programming:
Correct + Efficient +
Beautiful</a> qui
présente essentiellement en quoi l'apprentissage d'OCaml peut
améliorer les compétences d'un développeur dans d'autres
technologies plus populaires. Le livre est assez récent et c'est
celui que <strong>j'ai pris l'habitude de recommander comme ressource de
base</strong> pour appréhender OCaml.</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=v1CmGbOGb2I"><strong>Conférence &quot;Why
OCaml?&quot;</strong></a>, une
conférence de <a href="https://twitter.com/yminsky">Yaron Minsky</a>, le <em>CTO</em>
de l'entreprise <a href="https://blog.janestreet.com/">Jane Street</a> — un
utilisateur industriel d'OCaml faisant partie des <em>leaders</em> mondiaux
de la finance. Yaron est aussi l'un des auteurs de <em>Real World
OCaml</em> et la personne à qui l'on doit la très populaire phrase, dans
le monde des langages de programmation à vérification statique des
types, &quot;<em>Make illegal states unrepresentable</em>&quot;. La conférence donne
beaucoup d'informations sur les motivations du choix d'OCaml chez
Jane Street.</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=TxuLrsQZprE">&quot;<strong>OCaml for Fun &amp; Profit: An Experience
Report</strong>&quot;</a>, présentée
par <a href="https://lambdafoo.com/">Tim McGilchrist</a> durant la conférence
<a href="https://yowcon.com/melbourne-2023">Yow 2023</a>, qui, après une
présentation riche du langage, expose certains cas d'usages très
concrets de l'utilisation d'OCaml en production, <em>avec fun et
profit</em>.</p>
</li>
<li>
<p><a href="https://roscidus.com/blog/blog/categories/0install/">&quot;<strong>Replacing Python for
0Install</strong>&quot;</a>
par <a href="https://roscidus.com/blog/">Thomas Leonard</a>. Cette série
d'articles est, de mon point de vue, <strong>incroyablement
intéressante</strong>. En effet, l'auteur de
<a href="https://0install.net/">0Install</a>, un système d'installation de
logiciels décentralisé et multiplateforme (une alternative très
légèrement plus ancienne que <a href="https://nixos.org/">Nix</a>), cherche un
autre langage que <a href="https://www.python.org/">Python</a> pour
l'implémentation d'une nouvelle version (le remplacement de Python
est, lui aussi,
<a href="https://roscidus.com/blog/blog/2013/06/09/choosing-a-python-replacement-for-0install/#why-replace-python">documenté</a>)
et procède très consciencieusement à la comparaison méthodique de
plusieurs candidats :
<a href="https://www.cs.bu.edu/~hwxi/atslangweb/">ATS</a>,
<a href="https://learn.microsoft.com/en-us/dotnet/csharp/">C#</a>,
<a href="https://www.haskell.org/">Haskell</a>, <a href="https://go.dev">Go</a>,
<a href="https://www.rust-lang.org/">Rust</a> et <a href="https://ocaml.org">OCaml</a>
avec Python.  Plusieurs années après, je suis toujours émerveillé
par la rigueur et la nuance de cette série que je <strong>recommande très
fortement</strong>.</p>
</li>
</ul>
<p>Il existe probablement d'autres ressources et témoignages, notamment
sur le <a href="https://ocaml.org/">site officiel</a> qui propose des témoignages
<a href="https://ocaml.org/industrial-users">industriels</a> et
<a href="https://ocaml.org/academic-users">académiques</a>. De même qu'il existe
des articles témoignant du dépit que peut provoquer OCaml. Je suis
conscient qu'OCaml n'est pas parfait — je pense qu'il n'existe pas de
technologie parfaite. Il est probable que j'évoque (implicitement ou
explicitement) certains de ces articles dans la section dédiée aux
<em>mythes</em> et en conclusion, où je tâcherai d'expliquer dans quels
contextes je ne trouve pas l'utilisation d'OCaml pertinente.</p>
<h2 id="ocaml-en-tant-que-langage"><a class="anchor" aria-hidden="true" href="#ocaml-en-tant-que-langage"></a>OCaml en tant que langage</h2>
<p>Avant de rentrer dans les <strong>fonctionnalités</strong> offertes par le langage,
j'aimerais commencer par un point qui, selon moi, est essentiel. OCaml
est un langage de programmation issu <a href="https://ocaml.org/about#history">de la
recherche</a>, utilisé par des
<a href="https://ocaml.org/industrial-users">utilisateurs industriels</a>. Cette
dualité est importante car elle offre au langage deux choses :</p>
<ul>
<li>
<p>Une guidance sur les fonctionnalités <em>désirables</em> comme objet de
langage intéressant, supportées par une recherche poussée. Par
exemple, à ma connaissance, OCaml est le premier langage
<em>mainstream</em> proposant un support natif des <a href="https://v2.ocaml.org/manual/effects.html">effets définis par
l'utilisateur</a>
(<em>user-defined effects</em>), qui est le fruit d'une recherche avancée,
illustrée par beaucoup de
<a href="https://arxiv.org/search/cs?searchtype=author&amp;query=Sivaramakrishnan,+K">publications</a>.</p>
</li>
<li>
<p>Une guidance sur les fonctionnalités <em>désirables</em> comme outil pour
l'industrialisation, aussi supportées par une recherche poussée et
motivées par des cas d'usages. Par exemple, depuis peu, <a href="https://blog.janestreet.com/">Jane
Street</a>, un des utilisateurs
industriels très importants de OCaml, a proposé l'intégration de
<em>sessions affines</em> permettant un <a href="https://blog.janestreet.com/search/?query=oxidizing">contrôle linéaire des
ressources</a> (un
peu <em>à la Rust</em>).</p>
</li>
</ul>
<p>Cet entrelacement entre des motivations industrielles et académiques
permet à OCaml de proposer une collection de fonctionnalités solides,
utiles et clairement définies. En d'autres termes, OCaml est un
langage <strong>vivant</strong> et depuis que je m'en sers, j'ai eu l'occasion
d'être témoin de nombreuses évolutions et ajouts très — de mon point
de vue — désirables et qui <em>débunkent</em> une assertion très courante en
défaveur de OCaml : <strong>le langage ne sert que pour de la théorie ou
pour l'implémentation de <a href="https://coq.inria.fr/">Coq/Rocq</a></strong>.  Même
si, historiquement, c'était vrai, les motivations apportées par les
utilisateurs industriels justifient le titre &quot;<em>An industrial-strength
functional programming language with an emphasis on expressiveness and
safety</em>&quot;. La <em>Keynote</em> d'ouverture du <a href="https://ocaml.org/conferences/ocaml-workshop-2021">OCaml Workshop
2021</a> de <a href="https://xavierleroy.org/">Xavier
Leroy</a>, &quot;<a href="https://watch.ocaml.org/w/tU8wR9EcAcyFHHVcX4GS46"><em>25 Years Of
OCaml</em></a>&quot; présente
une frise chronologique exhaustive de la conception continue de OCaml,
montrant les différentes phases d'évolutions par lesquelles est passé
le langage.</p>
<p>Dans les grandes lignes, OCaml est un langage de programmation de la
famille <a href="https://en.wikipedia.org/wiki/ML_(programming_language)">ML</a>,
<strong>haut-niveau</strong> (ici, à lire comme étant doté d'un <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">glâneur de
cellules</a>),
<strong>statiquement typé</strong> (dont les types sont vérifiés à la compilation
et ne font pas de conversions implicites), avec de la <strong>synthèse de
types</strong> (aussi appelée <a href="https://en.wikipedia.org/wiki/Type_inference"><em>inférence de
types</em></a>, laissant la
main au compilateur, dans une majorité de cas, de déduire le type
d'une expression) permettant de programmer dans un style
<a href="https://en.wikipedia.org/wiki/Functional_programming"><strong>fonctionnel</strong></a>
et
<a href="https://en.wikipedia.org/wiki/Imperative_programming"><strong>impératif</strong></a>. Il
dispose aussi d'un modèle de <strong>programmation par objets</strong> et d'un
<strong>langage de modules</strong> très riche. OCaml dispose de deux schémas de
compilation : <code>ocamlc</code>, qui permet de compiler vers un <em>bytecode</em>
interprétable par une <strong>machine virtuelle</strong> (portable et efficace), et
<code>ocamlopt</code>, qui compile vers du <strong>code machine</strong> (exécutable dans une
grande <a href="https://github.com/ocaml/ocaml?tab=readme-ov-file#overview">diversité
d'architectures</a>).
De plus, OCaml permet la <strong>conversion de son <em>bytecode</em> en
JavaScript</strong> au moyen de
<a href="https://ocsigen.org/js_of_ocaml/latest/manual/overview">Js_of_ocaml</a>,
permettant une interopérabilité <em>très rapide</em> avec l'écosystème OCaml
(je l'utilise d'ailleurs <em>massivement</em> sur ce site web). La <a href="https://github.com/ocaml-wasm/wasm_of_ocaml">même
approche est utilisée pour produire du
WebAssembly</a>. Pour une
interopérabilité plus poussée avec l'écosystème JavaScript,
<a href="https://melange.re/">Melange</a> utilise une approche sensiblement
différente de Js_of_ocaml pour produire du JavaScript robuste.</p>
<p>OCaml est un langage <strong>très versatile</strong> et maintenant, je vais tâcher
de présenter les fonctionnalités et apports du langage qui en font —
<em>pour moi</em> — un outil idéal pour la construction de projets personnels
et professionnels, en commençant par un petit détour sur le typage
statique.</p>
<h3 id="sur-la-vérification-statique-des-types"><a class="anchor" aria-hidden="true" href="#sur-la-vérification-statique-des-types"></a>Sur la vérification statique des types</h3>
<p>Quand je préparais, avec <a href="https://twitter.com/bibear">Bruno</a>,
l'épisode <a href="https://www.ifttd.io/liste-des-episodes">If This Then Dev</a>
dédié à OCaml, qui, au final, a été
<a href="https://www.ifttd.io/episodes/le-langage-de-tous-les-langages">enregistré</a>
avec <a href="https://github.com/d-plaindoux">Didier</a>, il m'a posé une
question que j'ai trouvée surprenante :</p>
<blockquote>
<p>Est-ce que ça vaut vraiment la peine de s'embêter avec des types
quand on fait un <em>projet perso</em>, rapidement ? Même si, pour de la
<em>prod</em>, je vois parfaitement l'intérêt, pour un <em>projet personnel</em>,
ça me semble être une perte de temps.</p>
</blockquote>
<p>Je pense qu'il y a deux axes de réponse. Le premier, et le plus
évident, c'est que, dans l'absolu, <strong>je ne vois pas pourquoi un projet
personnel devrait être moins hygiénique qu'un projet
professionnel</strong>. Quand j'écris un logiciel <em>pour moi</em>, je peux
effectivement me contenter de ne pas le faire se heurter aux <em>corner
cases</em> de mon implémentation, certes. Mais ce n'est probablement pas
ce que j'ai envie de faire. Donc, si un langage et son compilateur me
permettent de tendre des filets de sécurité pour me forcer à prendre
en compte tous les cas d'un logiciel, <em>je prends</em> — de la même manière
que rédiger des <em>tests unitaires</em> <strong>facilite mon développement</strong> et je
ne les vois pas comme une contrainte.</p>
<p>Mais au-delà des considérations sur l'hygiène que l'on souhaite
apporter à un projet personnel, je pense que, généralement, la
mauvaise presse de la vérification statique des types est souvent la
conséquence d'une mauvaise expérience. En effet, dans des langages
comme C, ou encore Java, les types <strong>sont essentiellement une
contrainte</strong> qu'il est possible de dérouter <em>facilement</em>. Dans des
langages qui portent un intérêt fort au typage, comme
<a href="https://ocaml.org">OCaml</a>, <a href="https://haskell.org">Haskell</a>,
<a href="https://fsharp.org/">F#</a>, <a href="https://www.scala-lang.org/">Scala</a> ou
encore <a href="https://www.rust-lang.org">Rust</a>, <strong>les types servent de
garde-fous</strong>, mais, et selon moi, c'est le point le plus important,
<strong>les types servent aussi d'outil de <em>design</em> expressif</strong>. En les
utilisant, on gagne en sécurité, mais on dispose également d'un outil
de description de données incroyablement riche, versatile et concis.</p>
<p>D'après mon expérience, même s'il est courant de passer d'un langage
<em>mal-typé</em> (désolé, la tentation est trop forte) à un langage
<em>dynamiquement typé</em> — j'ai, par exemple, expérimenté le passage de
Java à Ruby avec beaucoup de joie — passer d'un langage avec un
système de type riche, comme OCaml ou Haskell, rend le passage à un
langage <em>dynamiquement typé</em> largement plus compliqué. À l'heure
actuelle, <strong>je ne connais personne ayant expérimenté sérieusement des
langages comme OCaml ou Haskell, qui soit ravi de revenir à des
langages aux systèmes de types moins sophistiqués</strong> (même si la
motivation d'un projet intéressant peut justifier la régression
technologique).</p>
<p>Ce n'est d'ailleurs <strong>pas une observation personnelle</strong> ; la
vérification statique des types fait partie intégrante <em>du grand débat
sur l'évolution des langages</em>. Des langages historiques muent (ou
tentent de muer) pour intégrer plus de vérification des types. Par
exemple, <a href="https://www.erlang.org/">Erlang</a>, dès les années 80 (avant
la libération du code source de son compilateur), avait expérimenté
<a href="https://homepages.inf.ed.ac.uk/wadler/papers/erlang/erlang.pdf">l'intégration d'un système de
type</a>. Et
Java améliore, de version en version, les fonctionnalités destinées à
améliorer la vérification statique des types, en intégrant, par
exemple, des <a href="https://openjdk.org/jeps/409">familles
scellées</a>. Beaucoup de langages
expérimentent l'intégration de systèmes de types : <a href="https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-released/">Ruby avec
RBS</a>
(ou encore <a href="https://crystal-lang.org/">Crystal</a>, un langage
statiquement typé, drastiquement inspiré par Ruby), <a href="https://mypy-lang.org/">Python et
Mypy</a>,
<a href="https://www.irif.fr/_media/users/gduboc/elixir-types.pdf">Elixir</a>,
qui revient sur les tentatives passées d'Erlang en proposant une
approche graduelle viable, et évidemment,
<a href="https://www.typescriptlang.org/">TypeScript</a> qui est devenu
<strong>largement adopté</strong> par la communauté des développeurs et
développeuses JavaScript. Même si toutes ces initiatives sont très
motivantes, et vont clairement, selon moi, dans la bonne direction,
actuellement, ces propositions <em>ajoutent des garde-fous</em>, mais ne
servent pas encore d'outils de <em>design</em> expressifs.</p>
<p>Dans l'utilisation de systèmes de types de plus en plus riches, <strong>la
Maison Blanche</strong> a récemment publié un
<a href="https://bidenwhitehouse.archives.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/">communiqué</a>
qui insiste sur l'importance de la <em>memory safety</em> dans la conception
de programmes et ... <em>plébiscite</em> l'utilisation du langage
<a href="https://www.rust-lang.org">Rust</a> (historiquement <a href="https://users.rust-lang.org/t/understanding-how-the-rust-compiler-is-built/87237/7">écrit en
OCaml</a>,
avant d'être <em>auto-hébergé</em>) au détriment de C++, montrant très
explicitement que même les instances officielles (et souvent
présentées comme poussiéreuses) soulignent l'importance des systèmes
de types riches — d'ailleurs, la <a href="https://tarides.com/blog/2024-03-07-a-time-for-change-our-response-to-the-white-house-cybersecurity-press-release/">réponse formulée par
Tarides</a>,
l'entreprise où je travaille à l'heure où je rédige cet article, est
aussi porteuse d'arguments intéressants en faveur de l'utilisation
d'OCaml pour la construction de systèmes critiques.</p>
<p>Pour conclure, la vérification statique des types, c'est vraiment bien
et recommandé, et ça vaut le coup de regarder des langages disposant
de systèmes de types sophistiqués (comme OCaml) et pourquoi pas,
d'aller encore plus loin, en s'intéressant de plus en plus aux
méthodes formelles.</p>
<h3 id="fonctionnalités-du-langage"><a class="anchor" aria-hidden="true" href="#fonctionnalités-du-langage"></a>Fonctionnalités du <em>langage</em></h3>
<p>Même s'il est très tentant de faire un gigantesque tutoriel sur OCaml,
l'objectif de cet article est de présenter, dans cette section, ce qui
fait que <strong>pour moi</strong>, OCaml est un choix <strong>très pertinent</strong> pour
l'apprentissage et la production. Les avantages seront donc présentés
(et <em>défendus</em>), mais <strong>ce n'est pas un tutoriel</strong>.</p>
<h4 id="un-langage-multi-paradigmes"><a class="anchor" aria-hidden="true" href="#un-langage-multi-paradigmes"></a>Un langage <em>multi-paradigmes</em></h4>
<p>De nos jours, parler de langages <strong>multi-paradigmes</strong> peut sembler peu
sensé car une très large partie des langages de programmation
<em>plébiscités par l'industrie</em> sont déjà multi-paradigmes. Cependant,
OCaml est un langage de <strong>programmation fonctionnelle</strong>, permettant la
<strong>programmation impérative</strong>, la <strong>programmation modulaire</strong>, la
<strong>programmation par objets</strong>, et depuis la version <code>5.0.0</code> du langage,
la <strong>programmation multi-cœur</strong>. Comme
<a href="https://www.haskell.org/">Haskell</a> a <em>pignon sur rue</em> quand on parle
de programmation fonctionnelle, il arrive souvent que l'on considère
que proposer des mécanismes impératifs, dans un langage, est une
mauvaise idée, surtout si l'on est convaincu des bienfaits du style
fonctionnel. De mon point de vue, il existe plusieurs raisons
parfaitement légitimes de faire de la programmation impérative, si le
langage le permet :</p>
<ul>
<li>
<p><strong>La lisibilité d'une implémentation.</strong> En effet, il arrive parfois
que pour éviter la mutabilité, il faille ajouter de la plomberie
additionnelle (par exemple, une <a href="https://wiki.haskell.org/State_Monad">monade
State</a>) rendant la lecture et
la compréhension d'un programme plus laborieuse.</p>
</li>
<li>
<p><strong>La performance.</strong> L'ajout de plomberie peut engendrer des coûts,
rendant l'exécution d'implémentations plus laborieuse.</p>
</li>
<li>
<p><strong>Le confort à l'usage.</strong> Il y a quelques années, <a href="https://twitter.com/rtguillon">Arthur
Guillon</a> m'avait cérémonieusement dit
que &quot;<em>OCaml était un lambda-calcul permettant trivialement
d'exécuter des effets</em>&quot;, ce qui le rendait très efficace pour, par
exemple, faciliter le débogage en permettant facilement d'imprimer
des messages sur la sortie standard. Même si je reconnais que ce
n'est probablement pas la <em>meilleure manière</em> de produire de la
journalisation, cela apporte indéniablement un confort
d'utilisation, permettant le prototypage rapide.</p>
</li>
</ul>
<p>De manière générale, la nature à la fois impérative et fonctionnelle
d'OCaml permet de tirer parti des différents avantages des deux
paradigmes dans des situations différentes et, évidemment, de les
coupler. Par exemple, en cachant la nature impérative d'un module sous
une API fonctionnelle.</p>
<h5 id="syntaxe-à-la-ml"><a class="anchor" aria-hidden="true" href="#syntaxe-à-la-ml"></a>Syntaxe <em>à la ML</em></h5>
<p>Bien que la syntaxe soit souvent considérée comme un détail, les
langages de <a href="https://en.wikipedia.org/wiki/ML_(programming_language)">la famille
ML</a> disposent
d'une syntaxe concise, expressive et lisible. Même si <em>cette famille
de syntaxe</em> peut être déroutante quand on vient de syntaxe plus
conventionnelle, <em>inspirée de C</em>, on s'y fait assez rapidement et l'on
peut très vite se rendre compte qu'elle est très cohérente et
relativement peu ambigüe. Cependant, si la syntaxe de OCaml vous pose
des soucis, n'hésitez pas à vous tourner vers
<a href="https://reasonml.github.io/">ReasonML</a>, une syntaxe alternative —
avec des accolades.</p>
<h5 id="étroitement-lié-à-la-recherche"><a class="anchor" aria-hidden="true" href="#étroitement-lié-à-la-recherche"></a>Étroitement lié à la recherche</h5>
<p>OCaml est un langage issu de la recherche française, comme en témoigne
<a href="https://caml.inria.fr/about/history.en.html">l'histoire de Caml</a>,
essentiellement pour permettre l'implémentation de l'assistant de
preuves <a href="https://coq.inria.fr/">Coq/Rocq</a>. Cette provenance — et les
motivations initiales, implémenter Coq, mais aussi servir de langage
de programmation enseigné en classes préparatoires — induit une
certaine dualité :</p>
<ul>
<li>
<p>Le socle des fonctionnalités n'a pas été pensé pour
l'industrie. Cependant, cette assertion n'est plus du tout vraie,
essentiellement parce que OCaml <strong>est</strong> devenu un langage utilisé
industriellement. Même si, dans la genèse du langage, on trouvait
plus d'outils pour construire un langage (permettant de faciliter
l'enseignement du fonctionnement des compilateurs plus aisé) que de
l'outillage pour <em>construire des applications dites
&quot;<a href="https://www.oracle.com/fr/java/technologies/java-ee-glance.html">entreprises</a>&quot;</em>,
des projets issus de la communauté, motivés par des usages
industriels enrichiront le langage et son écosystème, faisant du
langage un outil générique, et adapté à l'industrie. Par exemple, la
construction d'une <em>liaison</em> avec la bibliothèque
<a href="https://en.wikipedia.org/wiki/Tk_(software)">Tk</a> motivera
l'intégration, dans le langage, <a href="https://ocaml.org/manual/lablexamples.html">d'arguments
nommés</a>, <a href="https://ocaml.org/manual/lablexamples.html#s%3Aoptional-arguments">d'arguments
optionnels</a>,
et de <a href="https://ocaml.org/manual/polyvariant.html">variants
polymorphes</a>.</p>
</li>
<li>
<p>L'ensemble des paradigmes et des fonctionnalités du langage sont
<strong>très mûrement réfléchis et théorisés</strong>. En général, l'intégration
d'une fonctionnalité (ou d'une collection de fonctionnalités) est le
fruit d'un travail de recherche méticuleux, basé sur des fondements
théoriques solides et soumis à la revue d'un grand nombre d'experts
dans le domaine (souvent
<a href="https://www.inria.fr/fr/avec-xavier-leroy-linformatique-confirme-sa-presence-au-college-de-france">reconnus</a>
par la communauté scientifique). Cette rigueur peut parfois ralentir
l'intégration de nouvelles fonctionnalités, mais garantit
généralement leur bon fonctionnement et leur stabilité théorique.</p>
</li>
</ul>
<p>Cette rigueur théorique, engendrée par une proximité indéniable avec
le monde de la recherche, fait que les différents aspects de OCaml
sont bien documentés, illustrés par <a href="https://arxiv.org/search/?query=ocaml&amp;searchtype=all&amp;source=header">un grand nombre de
publications</a>
et possèdent des <strong>comportements prévisibles</strong>. Ce qui fait que, de
mon point de vue, OCaml est un choix très judicieux pour comprendre,
<em>en profondeur</em>, ces différentes fonctionnalités. Par exemple, je
pense que OCaml m'a permis de <strong>largement mieux comprendre</strong> certains
traits ou paradigmes de langages.</p>
<p>D'ailleurs, un très bon exemple démontrant comment un travail
méticuleux et rigoureux de recherche peut servir l'intégration d'un
aspect de langage est l'implémentation d'un <a href="https://ocaml.org/manual/objectexamples.html">modèle
objet</a> dans OCaml. En
effet, la thèse de <a href="https://www.irif.fr/~vouillon/">Jérôme Vouillon</a>,
<em><a href="https://www.irif.fr/~vouillon/publi/these.ps.gz">Conception et réalisation d'une extension du langage ML avec des
objets</a></em> propose un
modèle objet novateur, qui se marie très bien à l'inférence de types
en <a href="https://caml.inria.fr/pub/docs/oreilly-book/html/book-ora144.html">séparant la notion d'héritage et de
sous-typage</a>
— l'héritage étant une <strong>notion syntaxique</strong> et le sous-typage étant
une <strong>notion sémantique</strong> — utilisant du <a href="https://en.wikipedia.org/wiki/Row_polymorphism">polymorphisme de
rangée</a> pour décrire
des relations de <a href="https://en.wikipedia.org/wiki/Structural_type_system">sous-typage
structurelles</a>,
par opposition au <a href="https://en.wikipedia.org/wiki/Nominal_type_system">sous-typage
nominal</a>, utilisé
par Java, C#, et une grande partie des langages de programmation OOP
populaires. Le modèle objet de OCaml se conforme parfaitement au
principe <a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a> sans <a href="https://spring.io/projects/spring-boot">cérémonie
additionnelle</a>.</p>
<h4 id="types-algébriques"><a class="anchor" aria-hidden="true" href="#types-algébriques"></a>Types algébriques</h4>
<p>J'ai été assez expansif sur les raisons qui font que je trouve qu'un
langage soit doté d'une analyse statique des types. Cependant, dans
mon expérience, je trouve que pour qu'un langage statiquement typé
soit réellement utilisable, la présence de <a href="https://cs3110.github.io/textbook/chapters/data/algebraic_data_types.html">types
algébriques</a>
est nécessaire :</p>
<ul>
<li>
<p>Des <strong>types produits</strong> : qui permettent de grouper des valeurs de
types hétérogènes (donc de créer une <strong>conjonction</strong> de types
hétérogènes). Ils sont généralement présents dans tous les langages
<em>mainstream</em> (les <em>objets</em> par exemple, qui introduisent des
concepts en plus, ou les couples et les enregistrements).</p>
</li>
<li>
<p>Des <strong>types sommes</strong> : qui permettent de construire une
<strong>disjonction</strong> de types de valeurs hétérogènes, des différents
<em>cas</em>, indexés par des constructeurs. Même si on peut trouver des
<em>cas particuliers</em> de sommes dans les langages <em>mainstreams</em>,
notamment les <em>booléens</em> (qui sont une disjonction de deux cas :
<code>true</code> et <code>false</code>, soit deux constructeurs sans paramètres), le
support de ces dernières est souvent laborieux dans les langages
populaires.  Par exemple, Kotlin et Java (et <em>de facto</em>, C#)
utilisent une construction, associée aux relations d'héritages, <a href="https://docs.oracle.com/en/java/javase/17/language/sealed-classes-and-interfaces.html">le
scellage</a>.
L'intégration <a href="https://docs.scala-lang.org/scala3/reference/enums/adts.html">d'une syntaxe dédiée aux
sommes</a>
a aussi pris un peu de temps en Scala, qui, avant les dernières
versions du langage, utilisait aussi des familles scellées, rendant
l'expression de sommes assez verbeuses (et, de mon point de vue,
difficile à raisonner).</p>
</li>
<li>
<p>Des <strong>types exponentiels</strong> : qui permettent de décrire des fonctions
qui permettent d'exprimer des types pour des fonctions d'ordre
supérieur (que l'on peut passer en argument ou renvoyer).</p>
</li>
</ul>
<p>Couplé avec de la <a href="https://ocaml.org/manual/5.2/patterns.html">correspondance de
motifs</a> et du
<a href="https://en.wikipedia.org/wiki/Parametric_polymorphism">polymorphisme
paramétrique</a>
(ou <em>génériques</em>), un système de types algébriques est un outil
formidablement expressif pour décrire des structures de données, la
machine à état d'un programme, ou l'expression d'un <a href="https://pragprog.com/titles/swdddf/domain-modeling-made-functional/">domaine
métier</a>
avec une cardinalité adaptée. Même s'il est, au 21ème siècle, courant
d'avoir des produits et des exponentiels, quand je suis amené à
utiliser des langages <em>très populaires</em>, je suis souvent frustré de
l'absence de sommes, m'obligeant à utiliser un encodage verbeux (et
augmentant la cardinalité d'un domaine). C'est très flagrant dans
l'utilisation de <a href="https://go.dev/">Go</a> et de
<a href="https://www.typescriptlang.org/">TypeScript</a>.</p>
<p>L'intérêt de cette triade est d'ailleurs, probablement, une des
raisons (couplée à un écosystème et une chaîne d'outillage très
ergonomique) qui explique le succès de
<a href="https://www.rust-lang.org/">Rust</a>. En bref, si vous avez l'intention
de construire un nouveau langage de programmation, doté d'une
vérification statique des types, <em>par pitié</em>, n'hésitez surtout pas à
intégrer des types algébriques !</p>
<p>Pour terminer, il existe des pans du systèmes de types de OCaml que je
n'ai pas couverts, mais qui méritent probablement des articles
dédiés. Par exemple, <a href="https://ocaml.org/manual/gadts-tutorial.html">les types algébriques
généralisés</a> qui
permettent de décrire encore plus d'invariants.</p>
<h4 id="programmation-modulaires-et-langage-de-modules"><a class="anchor" aria-hidden="true" href="#programmation-modulaires-et-langage-de-modules"></a>Programmation modulaires et langage de modules</h4>
<p>OCaml, par le biais de <a href="https://caml.inria.fr/pub/docs/manual-caml-light/">Caml
Light</a>, son
ancêtre, figure parmi les premiers langages à proposer un système de
modules, à l'instar de <a href="https://smlfamily.github.io/">Standard ML</a>,
offrant ainsi <strong>l'encapsulation et l'abstraction</strong> tout en permettant
<strong>la compilation séparée</strong>, à la manière de
<a href="https://en.wikipedia.org/wiki/Modula-2">Modula-2</a>. Le langage de
modules d'OCaml constitue un <strong>aspect fondamental</strong> de ce langage,
bien que sa complexité puisse intimider. En effet, en OCaml, il est
possible de distinguer clairement l'interface (la <em>signature</em>) de
l'implémentation (la <em>structure</em>), facilitant ainsi l'encapsulation et
la documentation, tout en autorisant <strong>l'application de fonctions dans
le langage des modules</strong>.</p>
<p>Il m'est particulièrement difficile d'aborder brièvement le sujet des
modules (c'est un domaine que j'aspire à explorer depuis <em>des années</em>
sur mon blog).  Cependant, voici une liste des avantages que je
perçois dans cette approche <em>très modulaire</em> d'OCaml :</p>
<ul>
<li>
<p>La compilation séparée, une fonctionnalité clé, permet de compiler
efficacement de gros programmes en identifiant des points de
jonction pour optimiser la compilation parallèle et
incrémentale. Cette approche est exploitée par
<a href="https://dune.build/">dune</a>, le système de construction recommandé
pour compiler du OCaml.</p>
</li>
<li>
<p>La séparation systématique entre l'implémentation et l'interface
offre plusieurs avantages significatifs, notamment l'encapsulation
et la localisation de la documentation dans l'interface. Dans mon
flot de programmation, je trouve ça très confortable car je peux
implémenter ma <em>structure</em> (l'implémentation d'un module) en me
<em>laissant guider par l'inférence</em> et spécifier son API dans sa
<em>signature</em> (l'interface du module) tout en décidant d'un ordre
d'affichage et en fournissant une documentation claire ne polluant
pas l'espace d'implémentation. En complément, l'encapsulation me
permet librement de décrire, dans le corps de ma structure, des
types intermédiaires pour, par exemple, exprimer la machine à état
d'une application, <a href="https://en.wikipedia.org/wiki/Leaky_abstraction">sans la laisser
s'échapper</a>.</p>
</li>
<li>
<p>Un outil formidable pour décrire des structures de données. En
effet, en abstrayant les types (en cachant leur implémentation),
couplé à l'encapsulation, il est possible de décrire des structures
de données qui <strong>maintiennent des invariants</strong>. C'est d'ailleurs
pour ça qu'il est courant d'avoir une paire structure/signature par
structure de données cachant, au moyen de l'abstraction et de
l'encapsulation, des détails d'implémentation.</p>
</li>
<li>
<p>De la réutilisabilité et de la mutualisation. En effet, de la même
manière qu'il est possible de décrire des types dans le langage des
valeurs (comme nous l'avons vu dans la rubrique dédiée aux types
algébriques), il est possible de décrire des types dans le langage
des modules, que l'on appelle des <strong>signatures translucides</strong>,
permettant de décrire le type d'une signature, sans l'associer à une
structure. Ces signatures sont typées structurellement, et couplées
avec les fonctions dans le langage des modules,
<a href="https://ocaml.org/docs/functors">foncteurs</a>, il est possible de
<em>mutualiser du comportement</em> attaché à des modules.</p>
</li>
<li>
<p>Des formes de polymorphisme avancé, notamment du <a href="https://okmij.org/ftp/ML/higher-kind-poly.html">Higher Kinded
Polymorphism</a>,
disponible dans le langage des modules. Dans les grandes lignes, on
peut décrire <em>&quot;des génériques, paramétrés par des
génériques&quot;</em>. Cette limitation dans des langages, comme F# ou Java,
motive souvent l'utilisation <a href="https://github.com/yallop/higher?tab=readme-ov-file#implementations-in-other-languages">d'encodages
lourds</a>
pour pallier ce manque.</p>
</li>
</ul>
<p>La théorie derrière les langages de modules dans les langages ML est
un sujet très vaste, <a href="https://dl.acm.org/doi/10.1145/3649818">toujours en
évolution</a>, qu'il est très
difficile de résumer dans un paragraphe. Cependant, l'introduction de
la thèse de <a href="https://people.mpi-sws.org/~dreyer/">Derek Dreyer</a>,
<a href="https://people.mpi-sws.org/~dreyer/thesis/main.pdf"><em>Understanding and Evolving the ML Module
System</em></a> donne une
très bonne explication sur les intérêts des modules, de leurs usages,
illustrés avec beaucoup d'exemples. J'espère cependant prendre du
temps dans les semaines/mois à venir pour écrire sur le langage de
modules, plus expansivement que ce que j'ai <a href="/pages/modules-import.html">déjà
tenté</a>, parce que ça pourrait être
formateur et que le domaine est, je trouve, très très intéressant !</p>
<h4 id="injection-et-inversion-de-dépendances"><a class="anchor" aria-hidden="true" href="#injection-et-inversion-de-dépendances"></a>Injection et inversion de dépendances</h4>
<p>En parlant brièvement de la programmation orientée objets en OCaml,
j'ai évoqué rapidement le <em>fait</em> que OCaml permet d'exprimer, par le
biais des fonctionnalités offertes par le langage, trivialement, des
prérequis pour écrire du code <strong>SOLID</strong>. Le dernier point que
j'aimerais souligner est la facilité d'inversion des dépendances à
injecter au moyen de <strong>fonctionnalités offertes par le langage</strong>. Dans
les grandes lignes, le principe d'inversion des dépendances consiste à
décrire des treillis de dépendance au moyen <strong>d'abstractions</strong> et non
<strong>d'implémentations</strong>. De cette manière, les dépendances peuvent-être
<em>injectées à postériori</em> — rendant, notamment, le changement de
contextes, pour des tests unitaires par exemple, trivialement
implémentables.</p>
<p>OCaml dispose (<em>au moins</em>) de deux outils facilitant cette inversion,
et pouvant être utiles dans des contextes différents. Et nous allons
nous inspirer de l'exemples très populaires du télétype pour montrer
comment inverser les dépendances :</p>
<pre><code><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>program</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-unit'>()</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>let</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-unit'>()</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>print_endline</span><span class='ocaml-source'> </span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-string-quoted-double'>Hello World</span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>in</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>let</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-unit'>()</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>print_endline</span><span class='ocaml-source'> </span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-string-quoted-double'>What is your name?</span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>in</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>name</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>read_line</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-unit'>()</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>in</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-source'>print_endline</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-string-quoted-double'>Hello </span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>^</span><span class='ocaml-source'> </span><span class='ocaml-source'>name</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span></code></pre>
<p>Même si ça peut ne pas sembler évident, ce programme dépend
d'implémentations concrètes, <strong>les interactions avec l'entrée et la
sortie standards</strong>.</p>
<h5 id="par-le-biais-de-modules"><a class="anchor" aria-hidden="true" href="#par-le-biais-de-modules"></a>Par le biais de modules</h5>
<p>L'approche la plus évidente consiste à utiliser des modules, comme
<a href="https://ocaml.org/manual/firstclassmodules.html">valeurs de premier
ordre</a> ou par
construction, au moyen de
<a href="https://ocaml.org/docs/functors">foncteurs</a>. La dualité entre les
signatures et les structures rend l'inversion de dépendances
évidente. Par exemple, pour reprendre notre exemple, voici comment, en
utilisant des <a href="https://ocaml.org/manual/firstclassmodules.html"><em>first-class
modules</em></a>, il est
<strong>très facile</strong> de dépendre d'un ensemble d'interaction abstrait. On
commence par décrire la représentation abstraite des interactions
possibles :</p>
<pre><code><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>type</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>IO</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>sig</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>print_endline</span><span class='ocaml-source'> : string -&gt; unit
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>read_line</span><span class='ocaml-source'> : unit -&gt; string
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span></code></pre>
<p>On peut maintenant attendre de notre fonction <code>program</code> qu'elle prenne
un module du type <code>IO</code> en argument (on appellera ça <em>un gestionnaire</em>)
et utiliser les fonctions exportées par le module, qui, dans notre
exemple, s'appelle <code>Handler</code> :</p>
<pre><code><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>program</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Handler</span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>IO</span><span class='ocaml-source'>)</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>let</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-unit'>()</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Handler</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>print_endline</span><span class='ocaml-source'> </span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-string-quoted-double'>Hello World</span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>in</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>let</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-unit'>()</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Handler</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>print_endline</span><span class='ocaml-source'> </span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-string-quoted-double'>What is your name?</span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>in</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>name</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Handler</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>read_line</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-unit'>()</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>in</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-constant-language-capital-identifier'>Handler</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>print_endline</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-string-quoted-double'>Hello </span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>^</span><span class='ocaml-source'> </span><span class='ocaml-source'>name</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span></code></pre>
<p>Et il est possible, par exemple, dans le contexte des tests unitaires,
de fournir une implémentation qui journalise l'ensemble des opérations
appelées (et qui <em>mock</em> l'appel de <code>read_line</code>, pour fixer le résultat
renvoyé). Cela rend l'expression de tests unitaires <em>testant la
logique métier</em> très facile à implémenter.</p>
<p>L'action de passer une implémentation concrète en argument à notre
fonction consiste à <strong>interpréter le programme</strong>.</p>
<h5 id="par-le-biais-deffets-définis-par-lutilisateur"><a class="anchor" aria-hidden="true" href="#par-le-biais-deffets-définis-par-lutilisateur"></a>Par le biais d'<em>effets définis par l'utilisateur</em></h5>
<p>La version 5 d'OCaml est arrivée avec son lot de
nouveautés. Cependant, la plus grande avancée est la refonte du
<em>runtime</em> d'OCaml pour prendre en charge le multi-cœur. Il existe
plusieurs manières de décrire des algorithmes concurrents, par exemple
en utilisant des <a href="https://en.wikipedia.org/wiki/Actor_model">acteurs</a>
ou encore des <a href="https://go101.org/article/channel.html">canaux</a>. OCaml
a fait le choix d'utiliser <a href="https://github.com/ocaml-multicore/ocaml-effects-tutorial">des
effets</a>,
permettant de simplifier le traitement du flot de contrôle du
programme. En effet OCaml permet à l'utilisateur de décrire ses
propres effets, que l'on appelle logiquement, <a href="https://ocaml.org/manual/effects.html">des effets définis par
l'utilisateur</a>. Même s'ils
forment un outil formidable pour décrire des programme concurrents,
ils permettent aussi de faciliter l'injection de dépendances quand on
veut garder la main, <em>au niveau du gestionnaire</em>, sur le flot
d'exécution d'un programme.</p>
<blockquote>
<p>Attention, dans mon exemple, j'utilise une syntaxe expérimentale,
<a href="https://github.com/ocaml/ocaml/pull/12309">tout juste fusionnée</a>
dans le tronc de OCaml, et qui sera probablement disponible dans la
version <code>5.3.0</code> du langage.</p>
</blockquote>
<p>Comme pour notre amélioration précédente, il faut d'abord décrire
l'ensemble des opérations que l'on pourra produire. On utilise la
construction <code>effect</code> :</p>
<pre><code><span class='ocaml-source'>effect</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Print_endline</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>string</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>unit</span><span class='ocaml-source'>
</span><span class='ocaml-source'>effect</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Read_line</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>unit</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>string</span><span class='ocaml-source'>
</span></code></pre>
<p>Ensuite, on peut écrire, dans un style directe, notre programme en
<em>produisant des effets</em> :</p>
<pre><code><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>program</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-unit'>()</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>let</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-unit'>()</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Effect</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>perform</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-constant-language-capital-identifier'>Print_endline</span><span class='ocaml-source'> </span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-string-quoted-double'>Hello World</span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-source'>)</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>in</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>let</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-unit'>()</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Effect</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>perform</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-constant-language-capital-identifier'>Print_endline</span><span class='ocaml-source'> </span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-string-quoted-double'>What is your name?</span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-source'>)</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>in</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>name</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Effect</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>perform</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-constant-language-capital-identifier'>Read_line</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-unit'>()</span><span class='ocaml-source'>)</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>in</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-constant-language-capital-identifier'>Effect</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>perform</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-constant-language-capital-identifier'>Print_endline</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-string-quoted-double'>Hello </span><span class='ocaml-string-quoted-double'>&quot;</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>^</span><span class='ocaml-source'> </span><span class='ocaml-source'>name</span><span class='ocaml-source'>)</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span></code></pre>
<p>Il est ensuite possible d'interpréter, à postériori, notre programme
en utilisant une construction similaire au filtrage par motif pour
donner un sens spécifique à chaque effet.</p>
<p>Actuellement, on regrettera que la propagation d'effets ne soit pas
capturée par le système de types. Cependant, il s'agit d'une
fonctionnalité expérimentale, que l'on utilise massivement dans la
<a href="https://github.com/xhtmlboi/yocaml">nouvelle version de YOCaml</a>. Je
sais que des ressources sont allouées à l'élaboration d'un système de
type efficace pour <em>tracker</em> la propagation d'effets !</p>
<p>En général, quand je ne me soucie pas du contrôle du flot du
programme, ou que je ne veux pas pouvoir ajouter des effets <em>à
postériori</em>, j'utilise des modules.  Mais dans le cas de YOCaml, on a
profité de l'utilisation du nouveau système d'effets pour <a href="https://github.com/xhtmlboi/yocaml/commit/d78bb21077272ae86f7b6b3017509596de0a5a27">introduire
des effets dédiés aux tests
unitaires</a>,
permettant, par exemple, de <em>mocker</em> le <em>temps qui passe</em>.</p>
<p>Une fois de plus, il est vraiment très compliqué de ne pas trop
s'épancher sur les <em>effets définis par l'utilisateur</em>, qui est une
toute nouvelle fonctionnalité très excitante du langage. Je terminerai
en me contentant de vous partager deux articles écrits par <a href="https://github.com/art-w">Arthur
Wendling</a> expliquant, très pédagogiquement,
l'utilisation des effets, ainsi qu'une bibliographie très complète de
la littérature relative à l'abstraction d'effets en programmation
fonctionnelle :</p>
<ul>
<li><a href="https://hackmd.io/@yF_ntUhmRvKUt15g7m1uGw/Bk-5NXh15">Scopes and effect
handlers</a></li>
<li><a href="https://hackmd.io/@yF_ntUhmRvKUt15g7m1uGw/BJBZ7TMeq">Roguelike with effect
handlers</a></li>
<li><a href="https://github.com/yallop/effects-bibliography">Effect bibliography</a></li>
</ul>
<p>À noter qu'il serait aussi possible de procéder à cette
inversion/injection au moyen de <em>records</em> ou d'objets, cependant, mon
expérience en OCaml m'indique que les approches avec des modules ou
des effets (quand on veut pouvoir manipuler le flot de contrôle), sont
souvent plus directes et facile à raisonner.</p>
<h3 id="concernant-le-futur"><a class="anchor" aria-hidden="true" href="#concernant-le-futur"></a>Concernant le futur</h3>
<p>OCaml est un langage <em>toujours en activité</em> qui, de version en
version, évolue.  Dans la section dédiée à l'inversion de dépendances,
j'ai rapidement parlé de l'inclusion toute récente d'effets dans le
langage pour décrire un <em>runtime</em> multi-cœur, témoignant des mutations
dont bénéficie le langage au fil des années. On notera aussi
l'intégration des <a href="https://ocaml.org/manual/bindingops.html">opérateurs de
liaisons</a>, rendant
l'utilisation de la triade
<a href="https://en.wikipedia.org/wiki/Functor_(functional_programming)">Foncteurs</a>,
<a href="https://en.wikipedia.org/wiki/Applicative_functor">Foncteurs
Applicatifs</a> et
<a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">Monades</a>
plus confortable — à la manière des <a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions">expressions de
calcul</a>,
en F#.</p>
<p>Actuellement, beaucoup de chantiers très excitants sont en œuvre pour
améliorer, encore plus, le langage :</p>
<ul>
<li>
<p>un travail de fond sur l'expression des effets, avec une nouvelle
syntaxe fraichement ajoutée, et une collection de travaux sur la
séparation entre les <a href="https://github.com/ocaml/ocaml/pull/12736">opérations et les
effets</a> et, évidemment,
sur la <a href="https://arxiv.org/abs/2407.11816">propagation des effets dans le système de
types</a>.</p>
</li>
<li>
<p><a href="https://opensource.janestreet.com/">Jane Street</a> a proposé <a href="https://antonlorenzen.de/mode-inference.pdf">un
modèle non-intrusif de gestion de
ressources</a>, inspiré
par celui de Rust, introduisant <em>des modalités</em> et <em>un peu de
linéarité</em>.</p>
</li>
<li>
<p>Un véritable <a href="https://clement.blaudeau.net/assets/pdf/blaudeau_ocaml_modules.pdf">travail de
fond</a>
à été entamé sur le langage de modules permettant de rendre
l'implémentation de <a href="https://www.cl.cam.ac.uk/~jdy22/papers/modular-implicits.pdf">Modular
Implicits</a>
plus sereinement implémentable.</p>
</li>
</ul>
<p>On notera aussi le développement d'un système de <a href="https://xnning.github.io/papers/icfp23.pdf">macro
hygiénique</a>, de
l'intégration progressive d'un système de <a href="https://okmij.org/ftp/ML/MetaOCaml.html">métaprogrammation à
étages</a>, de l'implémentation
d'un <a href="https://ocamlpro.com/blog/tag/flambda2/"><em>back-end
d'optimisation</em></a>, témoignant
de l'activité forte de OCaml dans le secteur de l'innovation et
rendant son développement, pour les années à venir, très motivant et
excitant !</p>
<h3 id="points-faibles"><a class="anchor" aria-hidden="true" href="#points-faibles"></a>Points faibles</h3>
<p>Même si je suis convaincu que OCaml est un <strong>excellent langage</strong>, dire
qu'il est parfait serait probablement de la <em>très mauvaise foi</em> — en
effet, <em>rien n'est malheureusement parfait</em>. Voici, selon moi,
quelques points ombrageant OCaml en tant que langage :</p>
<ul>
<li>
<p>l'absence de <a href="https://en.wikipedia.org/wiki/Ad_hoc_polymorphism">polymorphisme
ad-hoc</a>. Même
s'il est possible de s'en tirer sans, notamment au moyen
d'ouvertures locales de modules, l'absence de <em>polymorphisme ad-hoc</em>
(au moyen de <a href="https://en.wikibooks.org/wiki/Haskell/Classes_and_types">classes de
types</a>, <em>à
la Haskell</em> ou
<a href="https://doc.rust-lang.org/book/ch10-02-traits.html">traits</a>/<a href="https://docs.scala-lang.org/tour/implicit-parameters.html">objets
implicites</a>,
<em>à la Rust et Scala</em> ou encore des <a href="https://coq.inria.fr/doc/v8.18/refman/language/extensions/canonical.html">structures
canoniques</a>
<em>à la Coq</em>) peut parfois rendre certaines situations délicates. Même
si j'ai tendance à toujours trouver les relations explicites
préférables, j'ai, au fil des années, trouvé plusieurs cas où cette
absence pouvait être problématique :</p>
<ul>
<li>
<p>l'impossibilité de décrire des contraintes de paramètres de
types sur des fonctions polymorphes, introduisant dans la
bibliothèque des fonctions d'égalités et de comparaisons
polymorphes, faisant couler <a href="https://blog.janestreet.com/the-perils-of-polymorphic-compare/">beaucoup
d'encre</a>
et imposant, par exemple, des versions spécialisées de
opérateurs arithmétiques pour les differentes représentations
des nombres (<code>int</code>, <code>int64</code>, <code>float</code>).</p>
</li>
<li>
<p>Le risque d'explosion combinatoire quand on décrit beaucoup de
relations entre des modules. C'est pour cette raison que la
bibliothèque <a href="https://github.com/xvw/preface">Preface</a> propose
une <a href="https://github.com/xvw/preface/blob/master/guides/option_instantiation.md">découpe modulaire un peu
complexe</a></p>
</li>
</ul>
<p>Cependant, même si l'arrivée des <a href="https://www.cl.cam.ac.uk/~jdy22/papers/modular-implicits.pdf">modules
implicites</a>
n'est probablement pas dans la feuille de route <em>court-termiste</em>,
les récents travaux sur le langage de modules, présentés dans la
rubrique dédiée au futur du langages, sont prometteurs.</p>
</li>
<li>
<p>Une interaction laborieuse entre le langage de modules et le
langages des valeurs. En effet, le langage de modules est <strong>un
langage différent</strong>, doté d'un système de types différent. Je ne
sais pas si l'on peut réellement parler d'un point faible, mais
cette différence peut être intimidante et s'explique par le fait que
le langage de modules de OCaml est un pionier dans la théorie des
modules et prédate des innovation <em>plus récentes</em>
(<a href="https://people.mpi-sws.org/~rossberg/1ml/1ml-extended.pdf">1ML</a>
par exemple). Dans la pratique, en plus d'être <em>complexe à
appréhender</em>, certains pans du langages sont difficiles à spécifier
correctement, par exemple <a href="https://www.ocaml.org/manual/5.2/recursivemodules.html#s%3Arecursive-modules">les modules
récursifs</a>.</p>
</li>
<li>
<p>Un langage <em>confortable pour la programmation fonctionnelle</em>,
impur. Même si je trouve que l'impureté est <strong>une feature</strong>, quand
on essaye d'importer des idiomes issus de langages purs (au hasard,
Haskell), on peut se heurter à des difficultés liées à l'inférence
de types : la <a href="https://en.wikipedia.org/wiki/Value_restriction"><em>value
restriction</em></a>. Même
si, en OCaml, elle <a href="https://caml.inria.fr/pub/papers/garrigue-value_restriction-fiwflp04.pdf">a été
<em>détendue</em></a>,
ses implications sur l'inférence de fonctions polymorphes peuvent
être intimidantes — pour de très bonnes raisons.</p>
</li>
<li>
<p>La syntaxe. Même si, à titre personnel, j'apprécie beaucoup la
syntaxe de OCaml et que je suis convaincu que la syntaxe devrait
rarement être une issue, je suis conscient que certains choix
syntaxiques peuvent être déroutants. Par exemple, le fait que les
paramètres de types préfixent le nom du type, <em>une liste de a</em> sera
écrite <code>'a list</code>. Beaucoup de ces choix sont motivés par une
<em>volonté de réduire l'ambiguïté de la syntaxe du langage</em> et on s'y
fait très vite. Cependant, je suis conscient qu'en venant d'un autre
langage, certains de ces choix peuvent sembler surprenants.</p>
</li>
</ul>
<p>Je pense que ces points faibles sont globalement discutables (parce
qu'ils sont souvent justifiés), mais je comprend parfaitement qu'ils
peuvent être perturbants. Cependant, je pense qu'ils ne suffisent pas
à rendre OCaml inutilisable et <strong>qu'ils ne devraient pas être une
barrière trop grande pour se mettre à OCaml</strong> ! Et le bénéfice d'avoir
un langage <em>améliorable</em>, c'est qu'il reste, en permanence, une volée
d'améliorations potentielles, motivant des travaux qui peuvent, en
plus, bénéficier à d'autres langages. Et, en toute sincérité, en étant
conscient de ces <em>parties rugueuses</em>, j'ai plus souvent eu l'occasion
de râler de l'absence de traits de langages, présents dans OCaml, dans
d'autres langages, que de râler de ces parties en écrivant du OCaml,
pour lesquelles il existe, souvent, des solutions (parfois, à la
limite de la satisfaction, je vous l'accorde) permettant de travailler
sereinement.</p>
<h3 id="pour-conclure-sur-le-langage"><a class="anchor" aria-hidden="true" href="#pour-conclure-sur-le-langage"></a>Pour conclure sur le langage</h3>
<p>J'ai, dans les <em>très très</em> grandes lignes, survolé <strong>des raisons</strong> qui
font que, selon moi, apprendre OCaml est un choix <strong>très
pertinent</strong>. Ce langage permet de <em>comprendre fondamentalement</em>
certains idiomes de programmation <em>très</em> populaires (mais souvent mal
définis). De plus, certains aspects du langage servent parfaitement
des desseins industriels rendant, parfois, des bonnes pratiques,
triviales à exprimer ! Une grande partie de ces attraits est
expérimentable avec d'autres langages, cependant, la nature <em>fortement
multi-paradigmes</em> de OCaml permet de centraliser son apprentissage
dans un seul langage. À ma connaissance, dans la jungle de langages
<em>partiellement populaires</em>, seul Scala semble couvrir autant de
sujets, même si, de mon point de vue, son modèle objet est,
essentiellement par soucis d'interopérabilité avec les autres langages
de la JVM, largement moins intéressant.</p>
<p>Comme l'objectif de cet article n'est pas d'être un tutoriel, je suis
volontairement passé rapidement sur certains concepts, <a href="https://ocaml.org/docs/modules">les
modules</a> et les
<a href="https://ocaml.org/manual/ffects.html">effets</a>. Je n'ai presque pas
parlé des <a href="https://ocaml.org/docs/objects">objets</a>, des <a href="https://ocaml.org/manual/polyvariant.html">variants
polymorphes</a> et des <a href="https://ocaml.org/manual/gadts-tutorial.html">types
algébriques
généralisés</a>. Si jamais
ces sujets vous intéressent, je vous invite à lire en détail
l'excellent <a href="https://caml.inria.fr/pub/docs/u3-ocaml/index.html">Using, Understanding, and Unraveling The OCaml
Language</a>, de
<a href="http://cristal.inria.fr/~remy/">Didier Remy</a>, couplé aux livres que
j'ai présentés en introduction, qui est une mine d'or pour toute
personne désireuse d'approfondir ses connaissances en OCaml.</p>
<p>Pour conclure, OCaml offre un outillage, au niveau du langage, varié
et riche pour l'apprentissage de la programmation, la construction de
programmes industriels respectant des standards mais aussi
l'implémentation <a href="https://github.com/art-w/deque">structure de données
complexes</a> et <a href="https://github.com/xvw/preface">d'abstractions issu de
la théorie des catégories</a> comme un
noyau fonctionnel, des traits impératifs, un système de types inférés
riche et expressif (permettant l'expression de types algébriques,
facilitant l'expression de domaines clairs), un langage de modules
comme outil d'abstraction, de réutilisabilité et de définition
d'unités de compilation, un modèle objet, la possibilité d'exprimer
des effets que l'on peut propager et interpréter <em>à postériori</em> et
d'autres fonctionnalités avancées. Ne serait-ce que pour <em>appréhender
des concepts avancés de programmation</em>, OCaml est un <strong>excellent
candidat</strong> — c'est d'ailleurs pour ça que OCaml est une inspiration
évidente pour beaucoup de langages plus récents, <a href="https://doc.rust-lang.org/reference/influences.html">Rust étant un des
exemples
notables</a>.</p>
<h2 id="ocaml-en-tant-quécosystème"><a class="anchor" aria-hidden="true" href="#ocaml-en-tant-quécosystème"></a>OCaml en tant qu'écosystème</h2>
<p>Avoir un langage expressif est très bénéfique pour <em>construire des
choses</em> (la formulation est volontairement naïve). Cependant, dans
différents contextes, le professionnel et le personnel, ce n'est pas
suffisant :</p>
<ul>
<li>
<p>dans le contexte professionnel, il est évident que si je veux que
mon équipe et moi soyons productifs, il n'est probablement pas très
pertinent de devoir construire une pile d'outils avant de pouvoir
commencer à répondre au problème pour lequel on est mandaté.</p>
</li>
<li>
<p>Dans le contexte personnel, même si l'on pourrait <em>arguer</em> que
construire sa pile technologique est <strong>très formateur</strong>, ça modifie
l'ensemble des compétences que l'on veut <em>travailler</em>. Si pour
construire une petite application web pour m'initier à OCaml comme
un langage web, je dois construire toute ma pile HTTP, il est fort
probable que OCaml ne soit pas le bon choix. Rassurez-vous,
cependant, OCaml dispose <a href="https://ocaml.org/docs/is-ocaml-web-yet">d'un outillage
riche</a> pour construire des
applications web !</p>
</li>
</ul>
<p>C'est pour ça que les fonctionnalités offertes par le langage ne sont
pas une métrique suffisante pour décrire sa viabilité pour construire
et maintenir des projets. L'écosystème est aussi un point très
important. C'est d'ailleurs pour ces raisons que
<a href="https://dotnet.microsoft.com/en-us/">.NET</a> et la
<a href="https://en.wikipedia.org/wiki/Java_virtual_machine">JVM</a>, par le
biais de langages relativement peu expressifs (mais en progrès) comme
Java et C# sont aussi populaires. Pour juger la pertinence d'un
écosystème, je pense qu'il est important de prendre en compte
plusieurs critères :</p>
<ul>
<li>
<p>la pertinence du <em>runtime</em> (ou des cibles de compilations) pour le
projet. Il est probable que je ne recommande pas OCaml pour
l'embarquer dans un tout petit <em>hardware</em> exotique — même si, n'y
connaissant rien en programmation <em>bas-niveau</em> (parce que ce n'est
pas du tout mon métier), il est probable que je me trompe.</p>
</li>
<li>
<p>Sa <strong>plateforme</strong>. Est-ce que l'ensemble de sa <em>chaine d'outillage</em>
est complète et ergonomique. Ce qui inclut, de mon point de vue, un
gestionnaire de paquet, un <em>build-system</em>, un bon <em>support éditeur</em>
(agnostique au possible), un bon générateur de documentation et une
collection d'outils additionnels, comme, par exemple, un <em>formateur</em>
(et bien d'autres).</p>
</li>
<li>
<p>La pertinence des <strong>bibliothèques disponibles</strong> (et leur niveau de
maintenance et leur découvrabilité, ce qui implique généralement la
nécéssité de disposer d'un gestionnaire de paquets) avec une
considération particulière sur l'ergonomie de ces dernières. Par
exemple, si je ne dispose d'aucune primitive de chiffrement, il est
probable que je ne choisisse pas cette technologie pour construire
une <em>blockchain</em>. Il existe toute une classe de problèmes qu'il est
<strong>très difficile</strong> de <em>résoudre dans son coin</em> ou dans un contexte
professionnel.</p>
</li>
</ul>
<p>Dans cette section, nous allons essayer de survoler ces différents
points pour voir si l'écosystème OCaml est à la hauteur du langage. Je
tiens à préciser que <strong>je suis un peu biaisé</strong> parce que je suis
convaincu de la pertinence de OCaml depuis 2012, à l'époque où
l'écosystème était <strong>drastiquement plus pauvre</strong>. A cette époque, j'ai
essayé de construire des projets en composant avec les manques ce qui
a engendré, probablement, un <a href="https://en.wikipedia.org/wiki/Survivorship_bias">biais du
survivant</a>. Comme de
nos jours, notamment grâce à des utilisateurs industriels,
l'écosystème de OCaml est largement plus riche et étendu, il est
cependant devenu beaucoup plus simple de le défendre, et quand
certains manques subsistent, la mauvaise fois <em>de l'ancien
utilisateur</em> peut ressurgir.</p>
<h3 id="compilation-runtimes-et-cibles-additionnelles"><a class="anchor" aria-hidden="true" href="#compilation-runtimes-et-cibles-additionnelles"></a>Compilation, <em>runtimes</em>, et cibles additionnelles</h3>
<p>OCaml dispose depuis sa genèse de deux cibles de compilation :</p>
<ul>
<li>
<p>une compilation native, qui produit des exécutables très efficaces,
compilés pour une architecture. (Et qui supporte un <a href="https://github.com/ocaml/ocaml?tab=readme-ov-file#overview">grand nombre
d'architectures</a>).
De plus, alors qu'historiquement, Windows était fortement délaissé,
<a href="https://tarides.com/blog/2024-05-22-launching-the-first-class-windows-project/">un effort tout
particulier</a>
a été mis en oeuvre pour le supporter (on notera aussi le projet
<a href="https://github.com/diskuv/dkml-installer-ocaml">DkMl</a>, une
initiative indépendante).</p>
</li>
<li>
<p>une compilation vers un <em>bytecode</em> (donc à destination d'une machine
virtuelle), produisant des exécutables portables.</p>
</li>
</ul>
<p>La présence d'une machine virtuelle a permis le développement du
vénérable
<a href="http://ocsigen.org/js_of_ocaml/latest/manual/overview">Js_of_OCaml</a>
qui permet <a href="https://www.irif.fr/~vouillon/publi/js_of_ocaml.pdf">la transformation dy bytecode OCaml vers
JavaScript</a>,
rendant OCaml parfaitement viable pour le développement d'application
dans le navigateur, mais aussi dans le <em>runtime</em>
<a href="https://nodejs.org/en">node</a>, et qui est drastiquement utilisé pour
ce site web. En utilisant une technique similaire, le support de
<a href="https://webassembly.org/">WebAssembly</a> a été rendu possible, très
récemment, par le biais du projet
<a href="https://github.com/ocaml-wasm/wasm_of_ocaml">Wasm_of_OCaml</a>. Supporter
la compilation vers <em>WASM</em> pour un langage étant doté d'un <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">glâneur de
cellules</a>
était un <em>sacré challenge</em>, mais l'équipe derrière <em>WASM</em> ayant
récemment spécificé l'interaction entre <em>WASM</em> et des <a href="https://github.com/WebAssembly/gc"><em>garbage
collector</em></a>, <strong>OCaml dispose
maintenant d'une compilation vers WebAssembly parfaitement décente</strong>
(et beaucoup de projets web, ambitieux, comme
<a href="https://ocsigen.org">Ocsigen</a>, commencent à supporter <em>WASM</em>
nativement).</p>
<p>De plus, le projet <a href="https://melange.re">Melange</a> (historiquement
<a href="https://discuss.ocaml.org/t/a-short-history-of-rescript-bucklescript/7222">BuckleScript</a>)
propose de <em>transpiler</em> — mapper l'<em>AST</em> de OCaml vers l'<em>AST</em> de
JavaScript — est une alternative pour produire du JavaScript. Si je
devais comparer
<a href="http://ocsigen.org/js_of_ocaml/latest/manual/overview">Js_of_OCaml</a>
et <a href="https://melange.re">Melange</a>, au delà des différentes méthodes
sous-jacentes utilisées pour produire du JavaScript (compiler vers du
<em>bytecode</em> et transformer ce <em>bytecode</em> en JavaScript, contre la
transformation syntaxique de OCaml en JavaScript), je dirais que
<strong>Js_of_OCaml</strong> se marie mieux avec l'écosystème OCaml, et est donc,
probablement, à <strong>destination de développeurs OCaml</strong> désireux de
rendre leurs projets accessibles depuis un navigateur — en effet,
l'interaction avec l'écosystème JavaScript existant peut-être plus
laborieuse. <strong>Melange</strong> se marie mieux avec l'écosystème JavaScript
(<code>npm</code> <em>and co</em>) et est donc, probablement, <strong>à destination des
développeurs JavaScript</strong> désireux d'apporter plus de sûreté dans
leurs projets JS (ou dans une base de code existante).</p>
<p>De nos jours, il est courant de trouver des langages <em>multi-backend</em>
comme <a href="https://www.idris-lang.org/">Idris</a> ou
<a href="https://nim-lang.org/">Nim</a>. Cependant, <em>à l'époque</em>, j'étais très
impressionné par le fait que OCaml puisse, <em>depuis le moment où j'ai
commencé à l'utiliser</em>, compiler vers JavaScript (en plus). A cette
épqoue, je ne connaissais que <a href="https://haxe.org/">Haxe</a> qui proposait
plusieurs cibles de compilation, si différentes (d'ailleurs, Haxe est
<a href="https://github.com/HaxeFoundation/haxe">écrit en OCaml</a>).</p>
<p>En effet, en 2024, produire du JavaScript est devenu standard, on
trouve les <a href="https://www.irif.fr/~balat/publications/2006mlworkshop-balat-ocsigen.pdf">premières traces de Js_of_OCaml en
2006</a>,
faisant de OCaml, un pionier dans le domaine !</p>
<h4 id="un-petit-détour-par-mirageos"><a class="anchor" aria-hidden="true" href="#un-petit-détour-par-mirageos"></a>Un petit détour par MirageOS</h4>
<p>Dans le <em>treillis formé par les différents contextes d'exécution et de
compilation de OCaml</em>, avoir des bibliothèques qui fonctionnent bien
dans <em>une majorité de contexte</em> est un exercice
compliqué. Heureusement, le projet <a href="https://mirage.io/">MirageOS</a> — un
ensemble de bibliothèques conçues pour construire un <strong>systéme
d'exploitation dedié à ne faire tourner qu'une seule application</strong>, au
moyen de virtualisation (un
<a href="https://en.wikipedia.org/wiki/Unikernel"><em>unikernel</em></a>) — a introduit
une véritable hygiène de la production de bibliothèques
multi-contextes.</p>
<p>Dans un futur <em>proche</em>, j'aimerais passer plus de temps à écrire sur
Mirage, un projet fascinant que l'on essaie d'intégrer dans nos
projets, par exemple dans
<a href="https://github.com/xhtmlboi/yocaml">YOCaml</a>, notre générateur de
sites statiques. D'ailleurs, en plus de fournir une approche saine de
la distribution de bibliothèques <em>intelligemment compartimentées</em>,
Mirage offre un socle solide de bibliothèques pour la construction de
projets OCaml, dont je parlerai, en étant plus <em>expansif</em>, dans la
rubrique dédiée aux bibliothèques.</p>
<h3 id="la-plateforme-ocaml"><a class="anchor" aria-hidden="true" href="#la-plateforme-ocaml"></a>La plateforme OCaml</h3>
<p>La <a href="https://ocaml.org/platform">plateforme OCaml</a> est un ensemble
d'outils, maintenus dans un cycle de vie explicite (<code>actif</code>, <code>en incubation</code>, <code>maintenu</code> et <code>déprécié</code>), destinés adosser le
compilateur à une chaine d'outillage cohérente pour la production de
code OCaml. On y trouve beaucoup d'outils qui servent différents
propos, cependant, dans cette section, je ne vais me focaliser que sur
certains points de la plateforme, vous laissant le loisir de consulter
sa <a href="https://ocaml.org/platform">page</a> et sa <a href="https://ocaml.org/tools/platform-roadmap">feuille de
route</a> pour de plus amples
informations. Dans cette section, nous allons nous intéresser, <em>dans
les grandes lignes</em>, à 4 grands points spécifiques :</p>
<ul>
<li>Le gestionnaire de paquets</li>
<li>Le système de construction (<em>build-system</em>)</li>
<li>Le support éditeurs (incluant le formatage de code)</li>
<li>Le générateur de documentation</li>
</ul>
<p>Quand on utilise OCaml depuis un certains temps, c'est probablement la
partie la plus excitante de l'article, car, selon moi, c'est celle qui
a bénéficié du plus de progrès. Et la <a href="https://ocaml.org/tools/platform-roadmap">feuille de
route</a> est, selon moi,
prometteuse !</p>
<h4 id="opam-le-gestionnaire-de-paquets"><a class="anchor" aria-hidden="true" href="#opam-le-gestionnaire-de-paquets"></a>OPAM, le gestionnaire de paquets</h4>
<p>Même si <em>les gestionnaires de paquets dédiés à un langage spécifique</em>
sont devenu très populaires (pour ne pas dire obligatoire) dans la
réduction des frictions de l'adoption d'un langage, à l'époque ou
OCaml a été conçu, ces derniers étaient confidentiels. En effet, mis à
part <a href="https://en.wikipedia.org/wiki/CTAN">CTAN</a>, pour distribuer des
paquets <a href="https://en.wikipedia.org/wiki/TeX">TeX</a> et
<a href="https://en.wikipedia.org/wiki/CPAN">CPAN</a>, inspiré par CTAN, pour
distribuer des paquets <a href="https://www.perl.org/">Perl</a> et
<a href="https://en.wikipedia.org/wiki/PEAR">PEAR</a>, pour
<a href="https://www.php.net/">PHP</a>, il faudra attendre les
<a href="https://en.wikipedia.org/wiki/RubyGems">Gems</a> pour que les
technologies de développement considèrent l'adoption d'un gestionnaire
de paquets comme axiomatique pour le développement d'un langage.</p>
<p><a href="https://opam.ocaml.org">OPAM</a>, pour <strong>O</strong>Caml <strong>Pa</strong>ckage <strong>M</strong>anager
est une
<a href="https://raw.githubusercontent.com/ocaml/opam/30598a59c98554057ce2beda80f0d31474b94150/specs/roadmap.pdf">proposition</a>
de 2012 (la <a href="https://opam.ocaml.org/about.html">page <em>À propos</em> du site
officiel</a> présente une petite frise
chronologique). OPAM permet, en plus d'installer des paquets,
installer des versions différentes de OCaml, et construire des
environnements <em>potentiellement isolés dans des bacs à sables</em>, que
l'on appelle des
<a href="https://ocaml.org/docs/opam-switch-introduction">switches</a>. Il est
possible d'utiliser le dépôt publique de ressources, <a href="https://github.com/ocaml/opam-repository">hébergé sur
Github</a> mais il est
parfaitement possible de construire son propre index de paquets.</p>
<blockquote>
<p>Ayant déjà publié plusieurs paquets sur OPAM, je dois avouer que la
<a href="https://check.ci.ocaml.org/">CI</a> de validation d'ajout de paquets
est incroyablement efficace et ergonomique (chaque erreur fournit un
Dockerfile pour reproduire l'issue localement) et que l'équipe de
personnes qui modèrent et administrent les ajouts/modifications de
paquets sont extraordinaires de réactivité et de bienveillance.</p>
</blockquote>
<p>Même si, à la lumière de la modernité, on pourrait reprocher plusieurs
points à OPAM, par exemple :</p>
<ul>
<li>une terminologie pouvant être laborieuse à appréhender (<em>switch</em>,
<em>invariant</em>, etc.)</li>
<li>la duplication de tous les paquets et de tous les compilateurs entre
plusieurs <em>switches</em> (c'est un problème connu pour lequel <a href="https://www.youtube.com/watch?v=5JDSUCx-tPw">du
travail a déjà été mis en
oeuvre</a>)</li>
<li>et probablement quelques soucis d'ergonomie (notamment l'interaction
avec <code>dune</code> pouvant être plus <em>smooth</em>, pour lequel un <a href="https://discuss.ocaml.org/t/ann-dune-developer-preview-updates/15160">travail est
aussi actuellement en
cours</a>)</li>
<li>quelques complications quand il s'agit de gérer des paquets en
développement, en les référençant depuis un dépôt de source plutôt
que depuis OPAM</li>
</ul>
<p>Je dois avouer qu'en venant d'une ère où OPAM n'existait pas, j'ai
appris à m'accomoder de certains de ces petits écueils et que,
quotidiennement, je dois avouer avoir peu de raison de me plaindre de
l'outil qui, pour mon usage quotidien, ne m'a jamais réellement fait
défaut. Cependant, si vous avez fait face à des soucis d'usages, je
vous invite à venir en discuter sur <a href="https://ocaml.org/community">l'un des espaces destinés à la
communication</a> pour que l'équipe de
développement puisse tenir compte de vos retours, et vous aiguiller.</p>
<p>Il existe aussi <a href="https://esy.sh/">esy</a> comme gestionnaire de paquets
alternatif, qui s'inspire de <a href="https://nixos.org/">Nix</a> pour construire
un <em>store</em> réutilisable, de la même manière qu'il est possible
d'utiliser Nix avec OCaml, cependant, étant un peu conventionnel, je
ne suis pas vraiment aux faits de ces pratiques et, étant satisfait de
mon <em>workflow</em> avec OPAM, je n'ai, malheureusement, jamais pris le
temps d'expérimenter sérieusement <strong>esy</strong>.</p>
<h4 id="dune-le-build-system"><a class="anchor" aria-hidden="true" href="#dune-le-build-system"></a>Dune, le <em>build-system</em></h4>
<p>Comme pour la gestion de paquets, historiquement, OCaml disposait de
<strong>plusieurs</strong> <em>build-systems</em> : le vénérable
<a href="https://github.com/ocaml/ocamlbuild">ocamlbuild</a>,
<a href="https://github.com/ocaml/oasis">oasis</a>,
<a href="https://github.com/OCamlPro/ocp-build">ocp-build</a>,
<a href="https://ocaml.org/p/jenga/latest">Jenga</a> et d'autres variation
autours de <a href="https://www.gnu.org/software/make/">Make</a>. Cependant,
depuis 2018, la communauté à fortement adopté
<a href="https://dune.build/">Dune</a>, un <em>build-system</em> initialement développé
à <a href="https://www.janestreet.com/">Janestreet</a>.</p>
<p>Sur beaucoup d'aspects, Dune peut être intimidant. En effet, sa
<a href="https://dune.readthedocs.io/en/stable/">documentation</a> est <strong>très
touffue</strong> — mais elle s'est très largement améliorée, en terme de
structure au cours de ces derniers mois. Et, alors que beaucoup
d'outils choisissent des langages de descriptions de règles comme
<a href="https://en.wikipedia.org/wiki/YAML">Yaml</a>,
<a href="https://en.wikipedia.org/wiki/TOML">Toml</a> ou encore
<a href="https://en.wikipedia.org/wiki/JSON">JSon</a>, Dune a fait le choix des
<a href="https://en.wikipedia.org/wiki/S-expression">S-expression</a>. On
regrettera aussi que Dune paramètre, <em>par défaut</em>, <a href="https://ocaml.org/manual/5.2/comp.html#s%3Acomp-warnings">l'ensemble des
avertissements</a>
fatal.</p>
<p>Avant de motiver certains choix (comme les <strong>S-expression</strong>), il est
très important de souligner les points qui ont fait de Dune un
standard :</p>
<ul>
<li>Dune est <strong>très rapide</strong> et propose un modèle d'exécution <strong>très
efficace</strong></li>
<li>il construit des artéfacts nécéssaire à la configuration
<em>gratuitement</em></li>
<li>il génère certains fichiers redondants (comme les fichiers de
description OPAM)</li>
<li>il trivialise le
<a href="https://en.wikipedia.org/wiki/S-expression"><em>vendoring</em></a> de
bibliothèques</li>
<li>il permet d'invoquer des <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">boucles
d'interaction</a>
correctement provisionnées par le contexte</li>
<li>on se familiarise très rapidement avec les <strong>S-expression</strong>, qui
permette de décrire schématiquement et rapidement des règles de
compilation</li>
<li>il est relativement agnostique et peut exécuter des tâches
arbitraires (à la manière de <code>make</code>)</li>
<li>il est en constante évolution et amélioré de version en version</li>
<li>adossé à <a href="https://github.com/tarides/dune-release">dune-release</a>, il
rend la publication de paquets sur OPAM incroyablement simple</li>
</ul>
<p>Peut-être que je suis biaisé mais, selon moi, Dune est un des
<em>build-system</em> les plus génériques et agréables que j'ai pu utiliser —
même si, aux premiers abords, il peut sembler effrayant et certains
choix peuvent sembler difficile à motiver.</p>
<h5 id="sur-le-choix-des-s-expression"><a class="anchor" aria-hidden="true" href="#sur-le-choix-des-s-expression"></a>Sur le choix des S-expression</h5>
<p>Aux premiers abords, l'utilisation d'un <em>lisp-like</em> pour décrire des
binaires, des bibliothèques et des projets peut sembler
surprenant. Cependant, cette décision à plusieurs avantages :</p>
<ul>
<li>l'AST des <strong>S-expression</strong> étant <strong>drastiquement simple</strong>, le
<em>parsing</em> est très simple et il est facile de le rendre très
efficace, ce qui ne pénalise pas l'efficacité de la compilation</li>
<li>le langage dispose de <em>terminaison</em>, ce qui le rend plus facile à
inspecter en cas d'erreurs (pour toute personne ayant tenté de
traiter des erreurs dans de gros fichiers YAML doit avoir été
confronté à ce genre de problèmes)</li>
<li>le langage est très facile à apprendre, et à décrire</li>
<li>il permet de décrire de <strong>véritables programmes</strong>, rendant Dune
relativement générique et permettant de faire des tâches
additionnelles</li>
</ul>
<p>Donc, de mon point de vue, le choix des <strong>S-expression</strong> est
pertinent, il permet de décrire des programmes complexes, lisibles,
sans être trop verbeux, il ne pénalise pas trop la compilation et il
permet de décrire, de manière très concise, des règles de compilations
très complexes. Et pour être très honnête, on s'y fait très vite !</p>
<h5 id="contribution-à-létat-de-lart-selective-applicative-functor"><a class="anchor" aria-hidden="true" href="#contribution-à-létat-de-lart-selective-applicative-functor"></a>Contribution à l'état de l'art: Selective Applicative Functor</h5>
<p>En plus d'être un très agréable <em>build-system</em>, Dune a contribué à
l'état de l'art de la recherche en mettant en lumière une nouvelle
construction <em>inspirée de la théorie des catégories</em>. En effet, en
2018, <a href="https://blogs.ncl.ac.uk/andreymokhov/about/">Andrey Mokhov</a>,
<a href="https://ndmitchell.com/">Neil Mitchell</a> et <a href="https://simon.peytonjones.org/">Simon Peyton
Jones</a> ont proposé, dans l'excellent
papier <a href="https://dl.acm.org/doi/10.1145/3236774">&quot;<em>Build Systems à la
Carte</em>&quot;</a>, une collection
d'abstraction pour réimplémenter — modulairement — des <em>build-systems</em>
divers et variés. Cependant, pour certaines raisons liées à
<strong>l'analyse statique des dépendances</strong>, ces modèles n'étaient pas
compatibles avec Dune. Après plusieurs investigations et
expérimentations, une nouvelle construction, similaire à un
<a href="https://hackage.haskell.org/package/base-4.20.0.1/docs/Control-Applicative.html">Applicative</a>,
un <a href="https://dl.acm.org/doi/10.1145/3341694">Selective Applicative
Functor</a>, capturant les
pré-requis de Dune a été proposée. Cette information peut sembler
anecdotique, mais, de mon point de vue, elle renforce l'intérêt (et
l'importance) d'être à <strong>l'intersection entre la recherche et
l'industrie</strong>.</p>
<h5 id="alternatives"><a class="anchor" aria-hidden="true" href="#alternatives"></a>Alternatives</h5>
<p>Bien qu'étant fortement adopté par la communauté, OCaml propose des
systèmes alternatifs (utilisant parfois Dune <em>sous le capot</em>), par
exemple, <a href="https://obazl.github.io/docs_obazl/">Obazl</a> qui offre des
règles OCaml pour <a href="https://bazel.build/">Bazel</a>,
<a href="https://github.com/rizo/onix">Onix</a> qui permet de construire des
projets avec <a href="https://nixos.org">Nix</a>, <a href="https://buck2.build/">Buck2</a>
qui est un projet ambitieux et générique qui est en compétition avec
Bazel et <a href="https://github.com/OCamlPro/drom">Drom</a> qui offre une
expérience similaire à
<a href="https://doc.rust-lang.org/stable/cargo/">Cargo</a>, unifiant la gestion
de paquets et la construction de projets.</p>
<p>En toute transparence, je n'ai jamais expérimenté ces alternatives,
étant très satisfait de Dune et de la direction qu'il est en train de
prendre, unifiant enfin, la gestion des <em>constructions</em> et des paquets
!</p>
<h4 id="lsp-et-merlin-pour-les-éditeurs"><a class="anchor" aria-hidden="true" href="#lsp-et-merlin-pour-les-éditeurs"></a>LSP et Merlin pour les éditeurs</h4>
<p>Dans les précédentes sections, nous avons pu voir à quel point OCaml à
progressé dans des domaines nécéssaires à l'industrialisation. Par
contre, en terme de support éditeur, OCaml dispose depuis plus de 10
ans d'un excellent support pour <a href="https://www.vim.org/">Vim</a> et
<a href="https://www.gnu.org/software/emacs/">Emacs</a> au moyen du projet
<a href="https://github.com/ocaml/merlin">Merlin</a> qui fournit des services
d'éditeurs permettant de la <strong>complétion</strong>, du <strong>diagnostique</strong>, des
fonctionnalités de <strong>navigation dans le code</strong>, des outils liées à la
<strong>déstructuration de valeurs</strong>, à la <strong>construction de valeur</strong>, de la
gestion (et navigation) de <strong>trous typés</strong>, de la <strong>recherche par
polarité</strong>, des informations précises (avec contrôle de verbosité) sur
<strong>les types de valeurs</strong>, du <strong><em>jump-to-definition</em></strong> etc.</p>
<p>Selon moi, le support IDE, via Merlin, est excellent, en OCaml, depuis
très longtemps. Couplé avec
<a href="https://github.com/OCamlPro/ocp-indent">ocp-indent</a>, qui permet de
calculer la position du curseur après une action dans l'éditeur et
<a href="https://github.com/ocaml-ppx/ocamlformat">OCamlformat</a>, qui permet le
formatage (configurable) à la volée de document OCaml, écrire du code
dans Emacs ou Vim est un immense plaisir !</p>
<h5 id="avènement-de-vscode-lsp-comme-standard"><a class="anchor" aria-hidden="true" href="#avènement-de-vscode-lsp-comme-standard"></a>Avènement de VSCode, LSP comme standard</h5>
<p>En 2015, <a href="https://en.wikipedia.org/wiki/Visual_Studio_Code">Visual Studio
Code</a> est arrivé en
amenant <a href="https://en.wikipedia.org/wiki/Language_Server_Protocol">Language Server
Protocol</a>
permettant d'abstraire la manière dont les éditeurs interagissent avec
un langage par le biais d'un serveur, respectant protocole
uniforme. OCaml dispose d'un <a href="https://github.com/ocaml/ocaml-lsp">très bon serveur
LSP</a> qui, lui même, repose sur des
bibliothèques éprouvées de l'écosystème OCaml, notamment Merlin. Comme
LSP est devenu <em>relativement standard</em> dans le monde des éditeurs
(Vim, Emacs et, en fait, presque tous les éditeurs libres que je
connaisse) permettent d'interagir avec un serveur LSP, il est question
de déprécier le serveur de Merlin, pour ne passer plus que par LSP,
faisant de Merlin une bibliothèque <em>bas-niveau</em>, fournissant
l'outillage, sous forme de bibliothèque utilisée par LSP. C'est un des
projets sur lequel travaille l'équipe <code>Editeur</code>, chez
<a href="https://tarides.com">Tarides</a> (dont je fais partie) : rendre
<code>ocaml-lsp</code> compatible en fonctionnalités, avec le serveur historique
de Merlin pour réduire la maintenance des clients alternatifs (Emacs
et Vim), ne nous souciant plus que des requêtes et actions spécifiques
à OCaml (et ne faisant donc, logiquement, pas partie du protocole).</p>
<p>Actuellement, la <a href="https://marketplace.visualstudio.com/items?itemName=ocamllabs.ocaml-platform">plateforme OCaml pour Visual Studio
Code</a>
et <a href="https://github.com/tarides/ocaml-eglot">OCaml-eglot</a> sont les deux
implémentations canoniques (qui étendent le protocole LSP pour OCaml),
respectivement pour VSCode et Emacs. Nous somme en train de penser
l'implémentation du plugin NeoVim.</p>
<p>Un peu comme pour Dune, l'état de l'outillage est, à mon sens,
excellent, et la feuille de route est motivante ! Cependant, comme
c'est <strong>mon travail</strong>, il est probable que je sois biaisé.</p>
<h4 id="odoc-le-générateur-de-documentation"><a class="anchor" aria-hidden="true" href="#odoc-le-générateur-de-documentation"></a>Odoc, le générateur de documentation</h4>
<p>OCaml est distribué avec un générateur de documentation, le vénérable
<a href="https://ocaml.org/manual/5.2/ocamldoc.html">OCamldoc</a>, cependant, ce
dernier n'est plus recommandé par/pour la communauté. En effet,
l'outil mis en avant est <a href="https://ocaml.github.io/odoc/">Odoc</a>, un
nouvel outil, qui vit en dehors du compilateur et qui offre plusieurs
fonctionnalités très intéressantes :</p>
<ul>
<li>un langage de <em>markup riche</em>, supportant les références croisées</li>
<li>la possibilité d'écrire des pages &quot;de manuel&quot;, volatiles, tout en
bénéficiant des références croisées</li>
<li>une très bonne intégration dans Dune</li>
<li>une barre de recherche par types (implémentée via
<a href="https://doc.sherlocode.com/">Sherlodoc</a>)</li>
<li>l'inclusion du code source (rédigé dans la documentation ou des
modules documentés)</li>
<li>l'implémentation de <em>drivers</em> permettant de générer des grands
ensembles de documentation (utilisé pour implémenter <a href="https://ocaml.org/packages">la
documentation de tous les paquets présents sur
OPAM</a>)</li>
<li>le support de <a href="https://en.wikipedia.org/wiki/Doctest"><em>doctest</em></a> via
<a href="https://github.com/realworldocaml/mdx">mdx</a></li>
</ul>
<p>Même si le <em>look'n feel</em> d'une documentation générée par Odoc, par
défaut, est, de mon point de vue, <strong>largement superieur</strong> de celle
générée par OCamldoc, il reste tout de même (<em>une fois de plus, de mon
point de vue</em>) un peu de travail à fournir sur l'UI pour que l'outil
soit réellement <strong>parfait</strong> !</p>
<p>J'ai clairement une certaine sympathie pour la documentation du
langage <a href="https://elixir-lang.org/">Elixir</a>,
<a href="https://hexdocs.pm/">HexDoc</a> (en terme de <em>design</em> et de
fonctionnalités), et à titre personnel, j'aimerais que OCaml converge
vers cet exemple. En revanche, il faut reconnaitre que la
documentation générée par Odoc est supérieure à beaucoup de
documentation d'autres langages. De plus, de part la nature fortemment
modulaire du langage, un bon générateur de documentation supportant
efficacement les <em>cross-references</em> est un sacré exploit !</p>
<h3 id="bibliothèques-disponibles"><a class="anchor" aria-hidden="true" href="#bibliothèques-disponibles"></a>Bibliothèques disponibles</h3>
<p>On a vu que le langage était <em>cool</em>, et qu'il dispose d'un outillage,
bien que toujours en progrès, efficace et agréable à utiliser. Se
pourrait-il que son manque de popularité soit la conséquence d'un
ensemble de bibliothèque trop restreind ? Pour être très honnête, <strong>je
ne sais pas</strong>. Ce que je sais, c'est que quand j'ai eu à écrire des
projets OCaml, professionnels comme personnels, j'ai souvent trouvé
tout mon bonheur dans la <a href="https://ocaml.org/packages">liste des
paquets</a>. Je pense que les raisons qui
font que OCaml est mature pour beaucoup de projets usuels peut se
synthétiser en plusieurs points :</p>
<ul>
<li>des entreprises comme <a href="https://www.lexifi.com/">Lexifi</a> et
<a href="https://www.janestreet.com/">Janestreet</a> ont fortement contribué à
l'écosystème en libérant beaucoup des bibliothèques nécéssaires à
leurs usages quotidien</li>
<li>Des projets de recherches ambitieux, comme, dans le cas du Web par
exemple, <a href="https://ocsigen.org/home/intro.html">Ocsigen</a>, utilisé
industriellement dans le projet <a href="https://www.besport.com">BeSport</a>
ont généré une collection de bibliothèques utiles</li>
<li>Nous en parlions précédemment mais <a href="https://mirage.io">MirageOS</a>,
dans son approche <a href="https://blog.container-solutions.com/all-about-unikernels-part-1-what-they-are"><em>Clean
Slate</em></a>
a, naturellement, engendré beaucoup de bibliothèques robustes</li>
<li>Comme pour des langages populaires, comme JavaScript ou Rust, des
contributeurs motivés ont fourni d'excellentes bibliothèques</li>
<li>Le langage est ancien, et utilisé industriellement depuis bien
longtemps</li>
</ul>
<p>Pour ma part, il m'est arrivé de <em>re-créer</em> des bibliothèques pour le
<strong>plaisir de réinventer la roue</strong>, mais aussi, parfois, pour proposer
une interface alternative. De plus, OCaml permet de s'interfacer avec,
entre autres, du C, permettant de construire des <em>bindings</em> pour un
grand nombre de bibliothéques et outils. Cependant, s'il existe une
bibliothèque que vous trouvez <em>objectivement</em> manquante, je vous
invite à prendre part à <a href="https://ocaml.org/community">la communauté</a>.</p>
<p>Il est important de noter que mon usage de OCaml s'est porté
essentiellement sur 3 sujets :</p>
<ul>
<li><strong>le développement web</strong> (fortement porté par Mirage, Ocsigen et des
projets indépendants, comme
<a href="https://aantron.github.io/dream/">Dream</a>,
<a href="https://github.com/xhtmlboi/yocaml">YOCaml</a> et bien
<a href="https://ocaml.org/packages/search?q=web">d'autres</a>)</li>
<li><strong>le développement de <a href="https://tezos.com/">Blockchain</a></strong> et par
extension l'utilisation de bibliothèque de cryptographie, offertes,
une fois de plus, par Mirage, mais aussi par le projet
<a href="https://github.com/hacl-star/hacl-star">HACL*</a>, une bibliothèque
formellement vérifiée, écrite en <a href="https://fstar-lang.org/">F*</a> et
extraite en OCaml</li>
<li><strong>le développement de <a href="https://github.com/ocaml/merlin">Merlin</a></strong></li>
</ul>
<p>Tous ces sujets impliquent tout de même la nécéssité d'un bon
outillage de tests et OCaml dispose de plusieurs bibliothèques
complémentaires pour implémenter des suites de tests robustes. En
effet, dans l'écosystème OCaml on trouve de quoi rédiger des
<a href="https://github.com/realworldocaml/mdx">doctests</a>, des <a href="https://github.com/mirage/alcotest">tests
unitaires classiques</a>, de quoi
décrire des <a href="https://github.com/c-cube/qcheck">tests dirigés par les
propriétés</a>, de quoi faire <a href="https://github.com/stedolan/crowbar">du
<em>fuzzing</em></a> mais aussi des <a href="https://dune.readthedocs.io/en/stable/tests.html#inline-expectation-tests">tests
par observation de la
sortie</a>,
des <a href="https://dune.readthedocs.io/en/stable/tests.html#inline-tests">tests
<em>inlines</em></a>
(qui permettent de tester, notamment, des composants privés) et des
<a href="https://dune.readthedocs.io/en/latest/reference/cram.html">tests
cram</a>.</p>
<p>Je continue de trouver mon bonheur dans les paquets disponibles et je
suis toujours très impressionné de voir le nombre de paquets et
d'alternative croître, <em>d'année. en année</em>. Il existe évidemment des
manques, mais qui n'ont pas invalidés mon choix de OCaml.</p>
<h4 id="aparté-sur-la-bibliothèque-standard"><a class="anchor" aria-hidden="true" href="#aparté-sur-la-bibliothèque-standard"></a>Aparté sur la bibliothèque standard</h4>
<p>Un reproche récurrent qu'il est fait à OCaml est la <em>modestie</em> de sa
bibliothèque standard. En effet, <em>historiquement</em>, cette dernière ne
servait qu'a implémenter le langage. Elle ne s'ecombrait donc pas de
certaines fonctionnalités utiles pour l'utilisateur final. Cette
situation a engendré l'émergence de bibliothèques standards
alternatives dont les plus populaires sont :</p>
<ul>
<li><a href="https://github.com/ocaml-batteries-team/batteries-included">Batteries</a>,
une alternative à la bibliothèque standard <em>un peu
datée</em>. Historiquement une <em>fork</em> de
<a href="https://github.com/ygrek/ocaml-extlib">Extlib</a>.</li>
<li><a href="https://opensource.janestreet.com/base/">Base</a>, une alternative
construite par <a href="https://janestreet.com">Janestreet</a> utilisée <em>un peu
invasivement</em> dans le livre <a href="https://dev.realworldocaml.org/">Real World
OCaml</a>. La bibliothèque utilise des
conventions forte, comme <em>labeliser</em> les fonctions d'ordre superieur
(généralement avec le nom <code>f</code>).</li>
<li><a href="https://opensource.janestreet.com/core/">Core</a> est une extension de
Base.</li>
<li><a href="https://github.com/c-cube/ocaml-containers">Containers</a> est une
extension de la bibliothèque standard (dans le sens où <code>open Containers</code> en début de module ne casse pas du code rédigé avec la
bibliothèque standard).</li>
</ul>
<p>Je n'ai pas d'opinion forte concernant le choix d'une bibliothèque
alternative, j'ai tendance à utiliser celle que mon projet utilise ou
de <em>réinventer la roue</em> (parce que c'est très rigolo), cependant, si
je devais donner un avis, il est probable que je recommande
<strong>Containers</strong>.</p>
<p>En plus de ces bibliothèques standards alternatives, on trouve des
bibliothèques spécifiques qui résolvent des problématiques générales
comme <a href="https://github.com/dbuenzli/bos">Bos</a> qui propose des outils
pour interagir avec un système d'exploitation ou encore
<a href="https://github.com/xvw/preface">Preface</a> — <em>shameless plug</em> — qui
permet de <em>concrétiser des abstractions issues de la théorie des
catégories</em>.</p>
<p>La position des mainteneurs sur la bibliothèque standard à évolué au
fil des années et il est dorénavant envisageable de
l'étendre. Cependant, les additions dans cette dernière sont souvent
sujettes à débat et l'addition de nouveaux modules peut parfois
prendre beaucoup de temps. Pour ma part, j'aurais préféré que la
bibliothèque standard <strong>continue à ne servir que le développement du
langage</strong> et qu'une bibliothèque sous l'ombrelle de la communauté
OCaml soit publiée. Cette séparation permet de désynchroniser les
<em>releases</em> du langage et de sa bibliothèque standard et aussi,
probablement, de simplifier la compatibilité entre cette bibliothèque
et le langage.</p>
<h3 id="conclusion-de-lécosystème"><a class="anchor" aria-hidden="true" href="#conclusion-de-lécosystème"></a>Conclusion de l'écosystème</h3>
<p>Je n'ai malheureusement pas l'occasion de parler de tous les outils de
la plateforme, ni des briques fondamentales qui font que OCaml est un
langage agréable à utiliser pour des projets personnels, mais aussi
pour des projets industriels (par exemple, des différents
<a href="https://github.com/hackwaly/ocamlearlybird">débogueurs</a>
existants). En revanche, j'espère avoir survolé quelques outils, qui
forment un socle solide pour l'utilisation de OCaml.</p>
<p>Dans mon utilisation du langage, il m'est parfois arrivé de devoir
construire ma propre bibliothèque, cependant, ce n'est pas un exercice
que je regrette et je pense que, maheureusement, si l'on décide de ne
jamais utiliser un langage parce que 100% des bibliothèques
nécéssaires ne sont pas disponibles, je trouve, peut-être
maladroitement que c'est <strong>nivellement par le bas</strong>, et que ça nous
enferme derrière des langages portés par des <em>entreprises riches</em>,
comme Java ou C# et <strong>c'est un peu triste</strong>.</p>
<h2 id="sur-la-communauté"><a class="anchor" aria-hidden="true" href="#sur-la-communauté"></a>Sur la communauté</h2>
<p>Même si j'ai utilisé beaucoup de langages de programmation différents,
je pense que OCaml est le seul avec lequel j'ai entretenu une
interaction communautaire forte. Je ne suis donc pas au courant de la
manière dont les choses se passent dans d'autres communautés, ce qui
rend mon retour <em>un peu inutile</em>. Mais de mon expérience, je trouve
que la communauté OCaml, en plus d'être très productive, est :</p>
<ul>
<li>
<p><strong>Très accessible</strong> : comme beaucoup d'autres, OCaml dispose d'une
<a href="https://ocaml.org/community">présence numérique forte</a>. Sur ces
différents espaces, il est possible d'y retrouver des contributeurs
au langage et à son écosystème très aguéris et de bénéficier de
conseils pointus (ou moins). Je me permet d'adresser une mention
particulière à <a href="http://gasche.info">Gabriel Scherer</a> et <a href="https://perso.quaesituri.org/florian.angeletti">Florian
Angeletti</a> dont les
réponses sont toujours élaborées et intéressantes.</p>
</li>
<li>
<p><strong>Très bienveillante</strong> : il m'arrive souvent d'avoir à demander de
l'aide et j'ai toujours eu l'occasion d'avoir des réponses claires
et précises, que ça soit en privé ou en public.</p>
</li>
<li>
<p><strong>Très brillante</strong> : OCaml est le fruit du travail de <em>chercheurs
brillants</em> et avoir l'opprtunité d'interagir avec eux est incroyable
(et potentiellement un peu intimidant). Avoir l'opportunité de
poser, directement, des questions à des gens étant derrière
certaines découvertes importantes de la construction de langage est
une aubaine formidable.</p>
</li>
</ul>
<p>Pour conclure sur le pan communautaire, même si je ne suis pas
réellement aux faits des interactions dans d'autres communautés, je
trouve que c'est un plaisir de faire partie de celle des développeurs
et développeuses OCaml. C'est un espace bienveillant, propice au
partage et à l'apprentissage.</p>
<h2 id="quelques-mythes-liés-à-ocaml"><a class="anchor" aria-hidden="true" href="#quelques-mythes-liés-à-ocaml"></a>Quelques mythes liés à OCaml</h2>
<p>J'arrive — <em>enfin</em> — à la partie la plus amusante de ce trop long
article, je vais pouvoir <em>debunker</em> certains mythes persistants liés à
OCaml. Je ne promet toujours de bonne foi, mais sachez que mon
intention est bonne. On lit souvent sur les internets plusieurs
critiques ou remarques à l'égard d'OCaml, et souvent, je trouve qu'il
est fatiguant d'y répondre. Cependant, quoi de mieux qu'un article
destiné à faire part de mon intérêt pour le langage pour prendre le
temps de survoler certaines de ses critiques et tâcher d'apporter une
réponse ?</p>
<p>J'en ai sélectionné quelques-uns mais il est probable que dans le
futur, j'écrirais des articles un peu plus long, à la manière des
membres de
<a href="https://www.heyplzlookat.me/articles/critique-de-la-raison-pure.gmi">HeyPlzLookAtMe</a>,
sur des articles que je trouve injustes.</p>
<h3 id="ocaml-et-f"><a class="anchor" aria-hidden="true" href="#ocaml-et-f"></a>OCaml et F#</h3>
<p><a href="https://fsharp.org/">F#</a> est un langage de programmation
<a href="https://fsharp.org/history/hopl-final/hopl-fsharp.pdf">historiquement très
inspiré</a> par
OCaml qui tourne sur la plateforme
<a href="https://dotnet.microsoft.com">.NET</a> (et s'interface, <em>de facto</em>, très
bien avec C#). Je trouve le langage — que j'ai professionnellement
utilisé chez <a href="https://derniercri.io/">DernierCri</a> et chez
<a href="https://www.d-edge.com">D-Edge</a> — très agréable. Comme
historiquement, .NET était exclusivement réservé à des environnements
Windows, OCaml souffrait peu de la comparaison, cependant depuis
l'arrivée de <a href="https://github.com/dotnet/core">.NET Core</a>, une
implémentation multi-plateforme de .NET, il m'arrive de plus en plus
de lire sur les internets, de phrases de ce genre :</p>
<blockquote>
<p>Pourquoi continuer à faire du OCaml, quand on peut disposer du même
langage, F#, avec tout l'écosystème .NET, plus de fonctionnalités
et une syntaxe plus agréable à utiliser.</p>
</blockquote>
<p>Premièrement, je trouve que oui, bénéficier de l'écosystème .NET
(Core) est un énorme avantage. Concernant le syntaxe, je suis plus
réservé. En effet, je trouve que la syntaxe basé sur l'indentation
rend parfois le déplacement de code plus laborieux et même s'il existe
des critiques à l'encontre de la syntaxe de OCaml, je dois avouer
qu'elle ne me fait pas défaut. Le dernier point me semble, lui, un peu
plus pernicieux. En effet, F# s'est vu doté de fonctionnalités non
présentes dans OCaml, par exemple :</p>
<ul>
<li>les <a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions">expressions de
calcul</a>
(qui sont une forme syntaxiquement plus générale que les <a href="https://ocaml.org/manual/5.2/bindingops.html">opérateurs
de liaisons</a>)</li>
<li>le <a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions">fournisseur de
types</a>
(qui malheureusement peut soulever quelques déconvenues avec .NET
Core, dans certains cas de résolutions de noms/chemins)</li>
<li>les <a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns">motifs
actifs</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/statically-resolved-type-parameters">Paramètres de type résolus
statiquement</a></li>
<li>la possibilité d'attribuer des méthodes à des sommes et des
produits, ce qui, pour des raisons d'interopérabilité a beaucoup de
sens, mais casse notablement l'inférence</li>
<li>et probablement d'autres fonctionnalités que je ne connais pas bien
(ou liées à l'interopérabilité avec la plateforme .NET, notamment de
la
<a href="https://learn.microsoft.com/fr-fr/dotnet/fsharp/language-reference/attributes">réflexion</a>)</li>
</ul>
<p>Ces évolutions sont arrivées progressivement dans le langage. Il
serait naïf de croire que OCaml n'a pas évolué lui aussi. En effet,
bien que historiquement, les deux langages semblaient très similaires,
dès le début de la proposition de F#, certaines fonctionnalités
étaient manquantes :</p>
<ul>
<li>
<p>l'absence d'un <strong>langage de modules</strong>. En effet, le mot-clé <code>module</code> est
présent en F#, cependant, ce dernier ne sert qu'a décrire des classes
statiques (et se marie étrangement avec les espaces noms)</p>
</li>
<li>
<p>Un modèle objet <strong>drastiquement différent</strong> (pour l'interopérabilité
avec C#, évidemment)</p>
</li>
</ul>
<p>Ces deux raisons, à elles seules, suffiraient de considérer OCaml et
F# comme deux langages <em>cousins</em> mais <strong>très différents</strong> et
motiveraient, selon moi, très largement le fait de préférer l'un à
l'autre. Dans mon cas, OCaml plutôt que F# rendant la phrase
d'introduction de la section caduc. Cependant, comme F#, OCaml a aussi
évolué et en plus de ces deux différences fondamentales, on trouve
beaucoup de choses en OCaml, absente dans F# :</p>
<ul>
<li>les ouvertures locales et
<a href="https://ocaml.org/manual/5.2/generalizedopens.html">généralisées</a>. En
effet, en F#, on ne peut ouvrir un module qu'en <em>top-level</em>, ce qui
parfois peut être très iritant</li>
<li>Du <a href="https://en.wikipedia.org/wiki/Row_polymorphism">row
polymorphism</a> sur
les produits (via des objets) et sur les sommes (via des <a href="https://ocaml.org/manual/5.2/polyvariant.html">variants
polymorphes</a>)</li>
<li>Des <a href="https://ocaml.org/manual/5.2/gadts-tutorial.html">Types algébriques
généralisés</a>
(probablement une des fonctionnalités, après le langage de modules,
qui m'a le plus manqué)</li>
<li>Des <a href="https://ocaml.org/manual/5.2/effects.html">Effets définis par
l'utilisateur</a></li>
<li>Des <a href="https://ocaml.org/manual/5.2/extensiblevariants.html">sommes
ouvertes</a>, ce
qui peut largement se simuler avec des objets et de l'héritage
ceci-dit</li>
</ul>
<p>Pour conclure, même si F# est un vraiment chouette langage, et que son
usage fait profiter de beaucoup d'avantages (notamment la plateforme
.NET), ce n'est pas <em>juste une meilleure version de OCaml</em>. Les deux
langages sont très différents et, de mon point de vue, OCaml dispose
d'un système de types plus sophistiqué, me faisant le préférer
largement à F#. Et, à mon sens, dire que F# est juste un OCaml plus
beau est aussi recevable que de dire que
<a href="https://kotlinlang.org/">Kotlin</a> n'est rien de plus qu'un
<a href="https://www.scala-lang.org/">Scala</a> avec une syntaxe plus légère.</p>
<h3 id="les-opérateurs-doublés-pour-les-flottants"><a class="anchor" aria-hidden="true" href="#les-opérateurs-doublés-pour-les-flottants"></a>Les opérateurs doublés pour les flottants</h3>
<p>Dans la bibliothèque standard, on trouve les opérateurs arithmétiques
sur les entiers suivant :</p>
<pre><code><span class='ocaml-keyword-other'>val</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>+</span><span class='ocaml-source'> </span><span class='ocaml-source'>)</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>int</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>int</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>int</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>val</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-</span><span class='ocaml-source'> </span><span class='ocaml-source'>)</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>int</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>int</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>int</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>val</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>*</span><span class='ocaml-source'> </span><span class='ocaml-source'>)</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>int</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>int</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>int</span><span class='ocaml-source'>
</span></code></pre>
<p>Mais aussi des opérateurs arithmétiques pour les nombres flottants :</p>
<pre><code><span class='ocaml-keyword-other'>val</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>+.</span><span class='ocaml-source'> </span><span class='ocaml-source'>)</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>float</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>float</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>float</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>val</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-.</span><span class='ocaml-source'> </span><span class='ocaml-source'>)</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>float</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>float</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>float</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>val</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>*.</span><span class='ocaml-source'> </span><span class='ocaml-source'>)</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>float</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>float</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>float</span><span class='ocaml-source'>
</span></code></pre>
<p>Aux premiers abords, cela peut sembler déroutant. Cependant, c'est
parfaitement sensé. Si on voulait avoir des opérateurs génériques, il
nous faudrait du <a href="https://en.wikipedia.org/wiki/Ad_hoc_polymorphism">polymorphisme
ad-hoc</a>, comme
c'est le cas en Haskell, par exemple, où les opérateurs arithmétiques
résides dans la classe <code>Num</code> :</p>
<pre><code><span class='haskell-keyword-other'>class</span><span class='haskell-meta-declaration-class'>  </span><span class='haskell-support-class-prelude'>Num</span><span class='haskell-meta-declaration-class'> </span><span class='haskell-variable-other-generic-type'>a</span><span class='haskell-meta-declaration-class'>  </span><span class='haskell-keyword-other'>where</span><span class='haskell-source'>
</span><span class='haskell-punctuation-whitespace-comment-leading'>  </span><span class='haskell-punctuation-definition-comment'>--</span><span class='haskell-comment-line-double-dash'> more code</span><span class='haskell-comment-line-double-dash'>
</span><span class='haskell-source'>  (+), (-), (*) :: a -&gt; a -&gt; a
</span><span class='haskell-source'>  </span><span class='haskell-punctuation-definition-comment'>--</span><span class='haskell-comment-line-double-dash'> more code</span><span class='haskell-comment-line-double-dash'>
</span></code></pre>
<p>Sans forme de polymorphisme ad-hoc (via des classes, des traits ou des
implicites), permettant de décrire une contrainte sur nos opérateurs :
<code>op :: Num a =&gt; a -&gt; a -&gt; a</code> ? Une proposition que j'ai souvent lu sur
internet serait d'utiliser <em>la même triche</em> que pour l'opérateur <code>=</code>,
dont le type est <code>val (=) : 'a -&gt; 'a -&gt; bool</code>. Ça ne fonctionne pas,
parce que alors que l'on peut espérer que <em>tout soit comparable</em> (dans
le pire des cas, on peut renvoyer <code>false</code>), comment généraliser, par
exemple, une addition ?</p>
<p>Le support des opérateurs arithmétiques est un problème laborieux, qui
est d'ailleurs la motivation originale derrière les <a href="https://en.wikipedia.org/wiki/Type_class">classes de
types</a> (et la raison d'être
des <a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/statically-resolved-type-parameters">Paramètres de type résolus
statiquement</a>
en F#). De mon point de vue, <em>en attendant les <a href="https://www.cl.cam.ac.uk/~jdy22/papers/modular-implicits.pdf">modules
implicites</a></em>,
doubler les opérateurs pour fonctionner avec les entiers et les
flottants me semble être une proposition <em>raisonnable</em> et, si pour
d'étranges raisons, suffixer les opérateurs par des points en présence
de flottant vous donne de l'urticaire, il est possible, au moyen
d'ouvertures locales, de s'en passer en fournissant, par exemple, ce
module :</p>
<pre><code><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Arithmetic</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-constant-language-capital-identifier'>P</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>sig</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>type</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>t</span><span class='ocaml-source'>
</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>add</span><span class='ocaml-source'> : t -&gt; t -&gt; t
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>sub</span><span class='ocaml-source'> : t -&gt; t -&gt; t
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>mul</span><span class='ocaml-source'> : t -&gt; t -&gt; t
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>div</span><span class='ocaml-source'> : t -&gt; t -&gt; t
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>)</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>let</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>+</span><span class='ocaml-source'> </span><span class='ocaml-source'>)</span><span class='ocaml-keyword-other-ocaml punctuation-comma punctuation-separator'>,</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-</span><span class='ocaml-source'> </span><span class='ocaml-source'>)</span><span class='ocaml-keyword-other-ocaml punctuation-comma punctuation-separator'>,</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>*</span><span class='ocaml-source'> </span><span class='ocaml-source'>)</span><span class='ocaml-keyword-other-ocaml punctuation-comma punctuation-separator'>,</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>/</span><span class='ocaml-source'> </span><span class='ocaml-source'>)</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>P</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>(</span><span class='ocaml-source'>add</span><span class='ocaml-keyword-other-ocaml punctuation-comma punctuation-separator'>,</span><span class='ocaml-source'> </span><span class='ocaml-source'>sub</span><span class='ocaml-keyword-other-ocaml punctuation-comma punctuation-separator'>,</span><span class='ocaml-source'> </span><span class='ocaml-source'>mul</span><span class='ocaml-keyword-other-ocaml punctuation-comma punctuation-separator'>,</span><span class='ocaml-source'> </span><span class='ocaml-source'>div</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span></code></pre>
<p>Qui permet d'étendre les modules <code>Int</code> et <code>Float</code> (qui disposent déjà
des fonctions <code>add</code>, <code>sub</code>, <code>mul</code> et <code>div</code>) pour les provisionner
d'opérateurs arithmétiques :</p>
<pre><code><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Int</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>include</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Int</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>include</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Arithmetic</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-constant-language-capital-identifier'>Int</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span></code></pre>
<p>Dans les grandes lignes, on construit un module <code>Int</code>, on inclut le
module <code>Int</code> précédent, pour que notre nouveau module <code>Int</code> dispose de
toute l'API du module <code>Int</code> original, ensuite on construit (et on
inclut) nos opértateurs arithmétiques. On peut maintenant répéter
l'opération avec <code>Float</code> :</p>
<pre><code><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Float</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>include</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Float</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>include</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Arithmetic</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-constant-language-capital-identifier'>Float</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span></code></pre>
<p>Et on peut maintenant se servir de l'ouverture locale pour ne pas
devoir suffixer nos opérateurs avec des points :</p>
<pre><code><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>x</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Int</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>(</span><span class='ocaml-constant-numeric-decimal-integer'>1</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>+</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-integer'>2</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>+</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-integer'>3</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>+</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-constant-numeric-decimal-integer'>4</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>*</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-integer'>6</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>/</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-integer'>7</span><span class='ocaml-source'>)</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>y</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Float</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>(</span><span class='ocaml-constant-numeric-decimal-float'>1.3</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>+</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-float'>2.5</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>+</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-float'>3.1</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>+</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-constant-numeric-decimal-float'>4.6</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>*</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-float'>6.8</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>/</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-float'>7.9</span><span class='ocaml-source'>)</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span></code></pre>
<p>De mon point de vue, même si ça peut être déroutant quand on vient de
languages pour lesquels ce n'est pas une question, c'est un problème
mineur, et il me semble que l'absence de surcharge d'opérateurs est un
argument un peu léger pour ne pas donner sa chance à un langage, <em>mais
ce n'est que mon humble avis</em>.</p>
<h3 id="sur-la-séparation-entre-ml-et-mli"><a class="anchor" aria-hidden="true" href="#sur-la-séparation-entre-ml-et-mli"></a>Sur la séparation entre <code>ml</code> et <code>mli</code></h3>
<p>Un autre point qui fait couler beaucoup d'encre (encore
<a href="https://discuss.ocaml.org/t/has-there-been-a-syntax-proposed-for-combining-mli-into-ml/15163">récemment</a>)
porte sur la <strong>séparation entre <code>ml</code> et <code>mli</code></strong>. Pour ma part, je
trouve ça génial, même si ça peut engendrer une légère forme de
répétition, je peux me concentrer sur l'API, via l'encapsulation, de
mon module côté <code>mli</code> tout en décrivant de la documentation, ça me
permet d'ordonner les fonctions que j'expose dans l'ordre qu'il me
plait et, naturellement, ça me fait abstraire au maximum les types que
je partage. De plus, si je consulte une implémentation, le code du
<code>ml</code> est rarement pollué par de la documentation et je peux rapidement
naviguer dans les différentes éléments qui consistuent le module que
j'observe.  En plus ça rend la compilation séparée possible et permet
de ne pas recompiler des modules qui dépendent de modules dont seul
l'implémentation a été modifiée en développement (c'est le
comportement par défaut de Dune dans le profile <code>dev</code>).</p>
<p>Cependant, les goûts et les couleurs ne sont pas vraiment discutable
et quand on expose des types complexes ou des types de modules, cette
répétition peut être ennuyante. Heureusement, il existe une <em>astuce</em>,
présentée en 2020 par <a href="https://www.craigfe.io">Craig Ferguson</a>, qui
permet de palier à ces répétitions : <a href="https://www.craigfe.io/posts/the-intf-trick">The <code>_intf_</code>
trick</a>.</p>
<p>En plus, il existe des petites astuces, basées sur la possibilité de
passer des expressions de modules arbitraires aux primitives <code>open</code> et
<code>include</code> qui permettent, parfois, de se passer <code>mli</code>. J'en avais déjà
parlé dans l'article <a href="/pages/modules-import.html">OCaml, modules et schémas
d'importation</a>.</p>
<h4 id="gérer-lencapsulation-sans-mli"><a class="anchor" aria-hidden="true" href="#gérer-lencapsulation-sans-mli"></a>Gérer l'encapsulation sans <code>mli</code></h4>
<p>On peut simplement utiliser <code>open struct (* code privé *) end</code> pour ne
pas exporter des parties codes sans nécéssiter d'interfaces. Par
exemple :</p>
<pre><code><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-comment-block'>(*</span><span class='ocaml-comment-block'> Private API </span><span class='ocaml-comment-block'>*)</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>f</span><span class='ocaml-source'> </span><span class='ocaml-source'>x</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>x</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>g</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>_some_private_stuff</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span><span class='ocaml-source'>
</span><span class='ocaml-comment-block'>(*</span><span class='ocaml-comment-block'> Public API </span><span class='ocaml-comment-block'>*)</span><span class='ocaml-source'>
</span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>a</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>f</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-integer'>10</span><span class='ocaml-source'>
</span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>b</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>g</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>+</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-integer'>11</span><span class='ocaml-source'>
</span></code></pre>
<h4 id="exprimer-linterface-depuis-le-ml"><a class="anchor" aria-hidden="true" href="#exprimer-linterface-depuis-le-ml"></a>Exprimer l'interface depuis le <code>ml</code></h4>
<p>Une autre technique similaire consiste à utiliser <code>include (struct ... end : sig (* API publique *) end)</code> pour permettre de décrire la
structure et l'interface dans le même fichier. Par exemple :</p>
<pre><code><span class='ocaml-keyword-other'>include</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>type</span><span class='ocaml-source'> </span><span class='ocaml-source'>t</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>int</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>f</span><span class='ocaml-source'> </span><span class='ocaml-source'>x</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>x</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>g</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>_some_private_stuff</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>sig</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>type</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>t</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>f</span><span class='ocaml-source'> : int -&gt; t
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span></code></pre>
<p>De cette manière, la signature et la structure vivent dans le même
fichier, tout en permettant de contrôler précisemment
l'encapsulation. Une autre approche consisterait à sortir la signature
dans un <code>module type</code> dédié, de cette manière :</p>
<pre><code><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>type</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>S</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>sig</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>type</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>t</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>f</span><span class='ocaml-source'> : int -&gt; t
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>include</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>type</span><span class='ocaml-source'> </span><span class='ocaml-source'>t</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>int</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>f</span><span class='ocaml-source'> </span><span class='ocaml-source'>x</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>x</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>g</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>_some_private_stuff</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>S</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span></code></pre>
<p>C'est très similaire à la première proposition, si ce n'est que le
module expose aussi le type de module <code>S</code>. L'effet de bord bénéfique
de ce <em>leak</em> est que l'on peut facilement référencer la signature du
module en utilisant <code>My_mod.S</code> plutôt que de devoir utiliser <code>module type of My_mod</code>.</p>
<h4 id="pour-conclure-sur-la-séparation"><a class="anchor" aria-hidden="true" href="#pour-conclure-sur-la-séparation"></a>Pour conclure sur la séparation</h4>
<p>Je trouve que cette séparation est <strong>très désirable</strong>, cependant, le
langage de module de OCaml étant très expressif, il est possible, au
moyen d'un peu d'encodage, de pallier à cette séparation. De mon point
de vue, ces approches servent essentiellement à démontrer cette
<em>expressivité</em> parce que le contre-coup de ce regroupement est la
perte de la compilation séparée, ce que je trouve sacrément balot.</p>
<h2 id="pour-conclure"><a class="anchor" aria-hidden="true" href="#pour-conclure"></a>Pour conclure</h2>
<p>Je pense avoir <em>sommairement</em> survolé les points que je voulais
développer. De mon point de vue, <strong>OCaml est un langage génial</strong> ! En
effet, il offre un très bon compromis entre la sûreté et
l'expressivité notamment grâce à un système de type très avancé, un
langage de modules riche, des objets, le support de <em>row polymorphism</em>
au moyen d'objets et de variants polymorphes et le support d'effets
définis par l'utilisateurs ! Son intersection entre la recherche et
l'industrie en font un langage qui, de mon point de vue, évolue dans
la bonne direction, en intégrant précautionneusement de nouvelles
fonctionnalités permettant au langage de rester moderne, sans subir
les éceuils d'une intégration trop rapide et non éprouvée.</p>
<p>Même si pendant plusieurs années, l'outillage de OCaml pouvait sembler
un peu ... <em>poussiéreux</em>, ces derniers temps, notamment grâce au
support commercial de certaines entreprises, l'outillage s'est
drastiquement modernisé, et continue son progrès comme le témoigne <a href="https://ocaml.org/tools/platform-roadmap">la
feuille de route de la
plateforme</a>. En complément,
l'ensemble des bibliothèques disponibles progresse permettant
d'utiliser OCaml dans une multitude de contexte, notamment grâce à ses
différentes cibles de compilation (par exemple le navigateur via
<a href="https://github.com/ocsigen/js_of_ocaml">js_of_ocaml</a> et
<a href="https://github.com/ocaml-wasm/wasm_of_ocaml">wasm_of_ocaml</a>).</p>
<p>En ajoutant à un langage expressif, doté d'un écosystème versatile,
une communauté bienveillante et réactive, OCaml devient un choix très
sérieux pour des projets personnels et professionnels. Il est évident
que proposer une migration complète d'une base de code pour aller vers
OCaml n'est probablement pas un choix pragmatique, mais si vous avez
des petits projets personnels en tête et que vous êtes curieux et
amusés par les langages de programmation, <strong>je vous invite
sérieusement à considérer OCaml</strong> !</p>
<p>J'espère avoir réussi à transmettre mon intérêt pour ce langage (et
son écosystème). Si vous désirez en parler, trouver des projets ou des
points de contributions, je serais ravi d'en parler avec vous, ou
alors vous pouvez vous adresser à la communauté par le biais <a href="https://discuss.ocaml.org/">du
forum</a> qui est actif, réactif et
bienveillant !</p>
</article>

</div>
    </main>
    <footer>
      <div id="footer-content">
        <div>
          <section>
            <h3>Ring.muhokama.fun</h3>
            <p>
              Ce site fait partie du
              <a href="https://ring.muhokama.fun">webring Muhokama</a>.
              Je vous invite à le parcourir&nbsp;!
            </p>
            <nav class="set">
              <a class="btn" href="https://ring.muhokama.fun/u/xvw/pred">
                prédécesseur
              </a>
              <a class="btn" href="https://ring.muhokama.fun/u/xvw/succ">
                successeur
              </a>
            </nav>
          </section>
          <section>
            <h3>Diffusion</h3>
            <p>
              Le <a href="https://github.com/xvw/capsule">code source</a>
              du générateur est diffusé sous
              <a href="https://opensource.org/license/mit">
                licence MIT</a>
              et le contenu est diffusé (<i>sauf mention</i>) sous
              <a href="https://creativecommons.org/licenses/by-sa/4.0/">
                licence CC BY-SA</a>.
            </p>
            <nav class="set">
              <a class="btn" href="https://github.com/xvw/capsule/blob/main/content/pages/why-ocaml.md">
                sources de la page
              </a>
            </nav>
          </section>
          <section>
            <h3>Flux</h3>
            <nav class="set svg-light">
              <a href="/atom.xml"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Rss</title><path d="M19.199 24C19.199 13.467 10.533 4.8 0 4.8V0c13.165 0 24 10.835 24 24h-4.801zM3.291 17.415c1.814 0 3.293 1.479 3.293 3.295 0 1.813-1.485 3.29-3.301 3.29C1.47 24 0 22.526 0 20.71s1.475-3.294 3.291-3.295zM15.909 24h-4.665c0-6.169-5.075-11.245-11.244-11.245V8.09c8.727 0 15.909 7.184 15.909 15.91z"/></svg></a><a rel="me" href="https://bsky.app/profile/xvw.lol"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Bluesky</title><path d="M12 10.8c-1.087-2.114-4.046-6.053-6.798-7.995C2.566.944 1.561 1.266.902 1.565.139 1.908 0 3.08 0 3.768c0 .69.378 5.65.624 6.479.815 2.736 3.713 3.66 6.383 3.364.136-.02.275-.039.415-.056-.138.022-.276.04-.415.056-3.912.58-7.387 2.005-2.83 7.078 5.013 5.19 6.87-1.113 7.823-4.308.953 3.195 2.05 9.271 7.733 4.308 4.267-4.308 1.172-6.498-2.74-7.078a8.741 8.741 0 0 1-.415-.056c.14.017.279.036.415.056 2.67.297 5.568-.628 6.383-3.364.246-.828.624-5.79.624-6.478 0-.69-.139-1.861-.902-2.206-.659-.298-1.664-.62-4.3 1.24C16.046 4.748 13.087 8.687 12 10.8Z"/></svg></svg></a><a rel="me" href="https://x.com/vdwxv"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>X</title><path d="M18.901 1.153h3.68l-8.04 9.19L24 22.846h-7.406l-5.8-7.584-6.638 7.584H.474l8.6-9.83L0 1.154h7.594l5.243 6.932ZM17.61 20.644h2.039L6.486 3.24H4.298Z"/></svg></a><a rel="me" href="https://merveilles.town/@xvw"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Mastodon</title><path d="M23.268 5.313c-.35-2.578-2.617-4.61-5.304-5.004C17.51.242 15.792 0 11.813 0h-.03c-3.98 0-4.835.242-5.288.309C3.882.692 1.496 2.518.917 5.127.64 6.412.61 7.837.661 9.143c.074 1.874.088 3.745.26 5.611.118 1.24.325 2.47.62 3.68.55 2.237 2.777 4.098 4.96 4.857 2.336.792 4.849.923 7.256.38.265-.061.527-.132.786-.213.585-.184 1.27-.39 1.774-.753a.057.057 0 0 0 .023-.043v-1.809a.052.052 0 0 0-.02-.041.053.053 0 0 0-.046-.01 20.282 20.282 0 0 1-4.709.545c-2.73 0-3.463-1.284-3.674-1.818a5.593 5.593 0 0 1-.319-1.433.053.053 0 0 1 .066-.054c1.517.363 3.072.546 4.632.546.376 0 .75 0 1.125-.01 1.57-.044 3.224-.124 4.768-.422.038-.008.077-.015.11-.024 2.435-.464 4.753-1.92 4.989-5.604.008-.145.03-1.52.03-1.67.002-.512.167-3.63-.024-5.545zm-3.748 9.195h-2.561V8.29c0-1.309-.55-1.976-1.67-1.976-1.23 0-1.846.79-1.846 2.35v3.403h-2.546V8.663c0-1.56-.617-2.35-1.848-2.35-1.112 0-1.668.668-1.67 1.977v6.218H4.822V8.102c0-1.31.337-2.35 1.011-3.12.696-.77 1.608-1.164 2.74-1.164 1.311 0 2.302.5 2.962 1.498l.638 1.06.638-1.06c.66-.999 1.65-1.498 2.96-1.498 1.13 0 2.043.395 2.74 1.164.675.77 1.012 1.81 1.012 3.12z"/></svg></a><a rel="me" href="https://github.com/xvw"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Github</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><a href="/feeds.html">Autres flux</a>
            </nav>
          </section><section>
            <h3>Etats</h3>
            <p>
              <strong>
                168
                journaux
              </strong>
              pour une durée de
              <strong>18 jours</strong>,
              <strong>18 heures</strong>,
              <strong>58 minutes</strong> et
              <strong>58 secondes</strong>.
              <br />
              <a href="/activity.html">Activité</a>
            </p>
          </section></div>
        <div>
          <div class="set svg-light">
            <a href="https://ocaml.org"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>OCaml</title><path d="M12.178 21.637c-.085-.17-.187-.524-.255-.676-.067-.135-.27-.506-.37-.625-.22-.253-.27-.27-.338-.608-.12-.574-.405-1.588-.76-2.296-.187-.372-.49-.677-.761-.947-.236-.236-.777-.624-.878-.607-.895.169-1.166 1.046-1.587 1.739-.237.388-.473.71-.66 1.115-.167.371-.151.793-.439 1.115a2.952 2.952 0 00-.624 1.097c-.034.084-.101.929-.186 1.131l1.318-.084c1.233.085.877.557 2.787.456l3.022-.1a5.376 5.376 0 00-.27-.71zM20.96 1.539H3.023A3.02 3.02 0 000 4.56v6.587c.44-.152 1.047-1.08 1.25-1.3.337-.389.405-.895.574-1.2.389-.709.456-1.215 1.334-1.215.406 0 .575.1.845.473.186.253.523.743.675 1.064.186.371.474.86.609.962.1.068.185.136.27.17.135.05.253-.051.354-.12.118-.1.17-.286.287-.556.17-.39.339-.827.44-.997.169-.27.236-.608.422-.76.27-.236.641-.253.743-.27.557-.118.81.27 1.08.507.186.168.423.49.609.91.135.339.304.661.388.846.068.185.237.49.338.86.101.322.337.575.44.744 0 0 .152.406 1.03.778a7.505 7.505 0 00.81.286c.39.135.76.12 1.233.068.338 0 .524-.49.676-.878.084-.237.185-.895.236-1.081.05-.185-.085-.32.034-.49.135-.186.22-.203.287-.439.17-.523 1.114-.54 1.655-.54.456 0 .389.44 1.149.287.439-.085.86.05 1.318.185.388.102.76.22.98.473.134.17.489.997.134 1.031.033.033.067.118.118.151-.085.322-.422.085-.625.051-.253-.05-.44 0-.693.118-.439.187-1.063.17-1.452.49-.32.271-.32.861-.473 1.2 0 0-.422 1.063-1.317 1.722-.237.17-.692.574-1.672.726-.44.068-.86.068-1.318.05-.22-.016-.438-.016-.658-.016-.136 0-.575-.017-.558.034l-.05.119a.6.6 0 00.033.169c.017.1.017.185.034.27 0 .185-.017.388 0 .574.017.388.17.743.186 1.148.017.44.236.913.456 1.267.085.135.203.152.254.32.067.186 0 .406.033.609.118.794.355 1.638.71 2.364v.017c.439-.067.895-.236 1.47-.32 1.063-.153 2.532-.085 3.478-.17 2.399-.22 3.7.98 5.844.49V4.562a3.045 3.045 0 00-3.04-3.023zm-8.951 14.187c0-.034 0-.034 0 0zm-6.47 2.769c.17-.372.271-.778.406-1.15.135-.354.337-.86.693-1.046-.05-.05-.744-.068-.929-.085a7.406 7.406 0 01-.608-.084 22.976 22.976 0 01-1.15-.236c-.22-.051-.979-.322-1.13-.39-.39-.168-.642-.658-.93-.607-.185.034-.37.101-.49.287-.1.152-.134.423-.202.608-.084.203-.22.405-.32.608-.238.354-.626.676-.795 1.03-.033.085-.05.169-.084.254v4.07c.202.034.405.068.624.135 1.69.456 2.095.49 3.75.304l.152-.017c.118-.27.22-1.165.304-1.435.067-.22.153-.39.187-.591.033-.203 0-.406-.017-.59-.034-.491.354-.661.54-1.065z"/></svg></a>
            <span>Fièrement généré par
              <a href="https://github.com/xhtmlboi/yocaml">YOCaml
            </a></span>
          </div>
          <div class="svg-cc-light">
            <a href="https://creativecommons.org/licenses/by-sa/4.0/"><svg role="img" viewBox="5.5 -3.5 64 64" xmlns="http://www.w3.org/2000/svg"><g><circle cx="37.785" cy="28.501" r="28.836"/><path d="M37.441-3.5c8.951,0,16.572,3.125,22.857,9.372c3.008,3.009,5.295,6.448,6.857,10.314
	  c1.561,3.867,2.344,7.971,2.344,12.314c0,4.381-0.773,8.486-2.314,12.313c-1.543,3.828-3.82,7.21-6.828,10.143
	  c-3.123,3.085-6.666,5.448-10.629,7.086c-3.961,1.638-8.057,2.457-12.285,2.457s-8.276-0.808-12.143-2.429
	  c-3.866-1.618-7.333-3.961-10.4-7.027c-3.067-3.066-5.4-6.524-7-10.372S5.5,32.767,5.5,28.5c0-4.229,0.809-8.295,2.428-12.2
	  c1.619-3.905,3.972-7.4,7.057-10.486C21.08-0.394,28.565-3.5,37.441-3.5z M37.557,2.272c-7.314,0-13.467,2.553-18.458,7.657
	  c-2.515,2.553-4.448,5.419-5.8,8.6c-1.354,3.181-2.029,6.505-2.029,9.972c0,3.429,0.675,6.734,2.029,9.913
	  c1.353,3.183,3.285,6.021,5.8,8.516c2.514,2.496,5.351,4.399,8.515,5.715c3.161,1.314,6.476,1.971,9.943,1.971
	  c3.428,0,6.75-0.665,9.973-1.999c3.219-1.335,6.121-3.257,8.713-5.771c4.99-4.876,7.484-10.99,7.484-18.344
	  c0-3.543-0.648-6.895-1.943-10.057c-1.293-3.162-3.18-5.98-5.654-8.458C50.984,4.844,44.795,2.272,37.557,2.272z M37.156,23.187
	  l-4.287,2.229c-0.458-0.951-1.019-1.619-1.685-2c-0.667-0.38-1.286-0.571-1.858-0.571c-2.856,0-4.286,1.885-4.286,5.657
	  c0,1.714,0.362,3.084,1.085,4.113c0.724,1.029,1.791,1.544,3.201,1.544c1.867,0,3.181-0.915,3.944-2.743l3.942,2
	  c-0.838,1.563-2,2.791-3.486,3.686c-1.484,0.896-3.123,1.343-4.914,1.343c-2.857,0-5.163-0.875-6.915-2.629
	  c-1.752-1.752-2.628-4.19-2.628-7.313c0-3.048,0.886-5.466,2.657-7.257c1.771-1.79,4.009-2.686,6.715-2.686
	  C32.604,18.558,35.441,20.101,37.156,23.187z M55.613,23.187l-4.229,2.229c-0.457-0.951-1.02-1.619-1.686-2
	  c-0.668-0.38-1.307-0.571-1.914-0.571c-2.857,0-4.287,1.885-4.287,5.657c0,1.714,0.363,3.084,1.086,4.113
	  c0.723,1.029,1.789,1.544,3.201,1.544c1.865,0,3.18-0.915,3.941-2.743l4,2c-0.875,1.563-2.057,2.791-3.541,3.686
	  c-1.486,0.896-3.105,1.343-4.857,1.343c-2.896,0-5.209-0.875-6.941-2.629c-1.736-1.752-2.602-4.19-2.602-7.313
	  c0-3.048,0.885-5.466,2.658-7.257c1.77-1.79,4.008-2.686,6.713-2.686C51.117,18.558,53.938,20.101,55.613,23.187z"/></g></svg><svg role="img" viewBox="5.5 -3.5 64 64" xmlns="http://www.w3.org/2000/svg"><g><circle cx="37.637" cy="28.806" r="28.276"/>
 <g><path d="M37.443-3.5c8.988,0,16.57,3.085,22.742,9.257C66.393,11.967,69.5,19.548,69.5,28.5c0,8.991-3.049,16.476-9.145,22.456
 C53.879,57.319,46.242,60.5,37.443,60.5c-8.649,0-16.153-3.144-22.514-9.43C8.644,44.784,5.5,37.262,5.5,28.5
 c0-8.761,3.144-16.342,9.429-22.742C21.101-0.415,28.604-3.5,37.443-3.5z M37.557,2.272c-7.276,0-13.428,2.553-18.457,7.657
 c-5.22,5.334-7.829,11.525-7.829,18.572c0,7.086,2.59,13.22,7.77,18.398c5.181,5.182,11.352,7.771,18.514,7.771
 c7.123,0,13.334-2.607,18.629-7.828c5.029-4.838,7.543-10.952,7.543-18.343c0-7.276-2.553-13.465-7.656-18.571
 C50.967,4.824,44.795,2.272,37.557,2.272z M46.129,20.557v13.085h-3.656v15.542h-9.944V33.643h-3.656V20.557
 c0-0.572,0.2-1.057,0.599-1.457c0.401-0.399,0.887-0.6,1.457-0.6h13.144c0.533,0,1.01,0.2,1.428,0.6
 C45.918,19.5,46.129,19.986,46.129,20.557z M33.042,12.329c0-3.008,1.485-4.514,4.458-4.514s4.457,1.504,4.457,4.514
 c0,2.971-1.486,4.457-4.457,4.457S33.042,15.3,33.042,12.329z"/>
 </g></g></svg><svg role="img" viewBox="5.5 -3.5 64 64" xmlns="http://www.w3.org/2000/svg"><g><circle cx="36.944" cy="28.631" r="29.105"/><g>
<path d="M37.443-3.5c8.951,0,16.531,3.105,22.742,9.315C66.393,11.987,69.5,19.548,69.5,28.5c0,8.954-3.049,16.457-9.145,22.514
			     C53.918,57.338,46.279,60.5,37.443,60.5c-8.649,0-16.153-3.143-22.514-9.429C8.644,44.786,5.5,37.264,5.5,28.501
			     c0-8.723,3.144-16.285,9.429-22.685C21.138-0.395,28.643-3.5,37.443-3.5z M37.557,2.272c-7.276,0-13.428,2.572-18.457,7.715
			     c-5.22,5.296-7.829,11.467-7.829,18.513c0,7.125,2.59,13.257,7.77,18.4c5.181,5.182,11.352,7.771,18.514,7.771
			     c7.123,0,13.334-2.609,18.629-7.828c5.029-4.876,7.543-10.99,7.543-18.343c0-7.313-2.553-13.485-7.656-18.513
			     C51.004,4.842,44.832,2.272,37.557,2.272z M23.271,23.985c0.609-3.924,2.189-6.962,4.742-9.114
			     c2.552-2.152,5.656-3.228,9.314-3.228c5.027,0,9.029,1.62,12,4.856c2.971,3.238,4.457,7.391,4.457,12.457
			     c0,4.915-1.543,9-4.627,12.256c-3.088,3.256-7.086,4.886-12.002,4.886c-3.619,0-6.743-1.085-9.371-3.257
			     c-2.629-2.172-4.209-5.257-4.743-9.257H31.1c0.19,3.886,2.533,5.829,7.029,5.829c2.246,0,4.057-0.972,5.428-2.914
			     c1.373-1.942,2.059-4.534,2.059-7.771c0-3.391-0.629-5.971-1.885-7.743c-1.258-1.771-3.066-2.657-5.43-2.657
			     c-4.268,0-6.667,1.885-7.2,5.656h2.343l-6.342,6.343l-6.343-6.343L23.271,23.985L23.271,23.985z"/></g></g></svg></a>
          </div>
        </div>
      </div>
    </footer>
  </body>
</html>
