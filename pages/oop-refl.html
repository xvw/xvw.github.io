<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>xvw - M√©thodes gard√©es</title>
    <meta name="description" content="Impl√©mentation de &quot;m√©thodes gard√©es&quot; en utilisant des t√©moins d&apos;√©galit√©s de types." />
    <meta name="keywords" content="capsule, programmation, type, oop, ocaml, gadt" />
    <meta name="author" content="Xavier Van de Woestyne" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="/css/hl.css" />
    <link rel="stylesheet" href="/css/default.css" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="alternate" type="application/atom+xml" href="/atom.xml" />
    <link rel="alternate" type="application/atom+xml" href="/journal.xml" />
    <link rel="alternate" type="application/atom+xml" href="/pages.xml" />
    <link rel="alternate" type="application/atom+xml" href="/addresses.xml" />
    <script src="/js/hell.js"></script>
    <script src="/js/capsule.js"></script>
  </head>
  <body>
    <main class="container"><section class="header">
  <nav class="breadcrumb">
    <ol>
      <li>
        <a href="/">Accueil</a>
      </li><li>
        <a href="/programming.html">Programmation</a>
      </li><li>
        <a href="/programming.html#index-bribes--encodages">Bribes &amp; Encodages</a>
      </li></ol>
  </nav>

  <h1>M√©thodes gard√©es</h1><time class="published-at" datetime="2022-05-29">
    2022-05-29
  </time></section><section class="synopsis"><p>Les <strong>m√©thodes gard√©es</strong> permettent d'attacher des <strong>contraintes</strong> au receveur (<code>self</code>) <strong>uniquement pour certaines m√©thodes</strong>, permettant donc de n'appeler ces m√©thodes que si le receveur satisfait ces contraintes (ces <em>guards</em>). <a href="https://ocaml.org">OCaml</a> ne permet pas, syntaxiquement, de d√©finir <em>directement</em> ce genre de m√©thodes. Dans cette note, nous allons voir comment les encoder en utilisant un <strong>t√©moin d'√©galit√© de type</strong>.</p>
</section><section class="table-of-contents"><ul>
<li><ul>
<li><a href="#prsentation-du-problme">Pr√©sentation du probl√®me</a>
<ul>
<li><a href="#dplacer-la-mthodes-en-dehors-de-la-classe">D√©placer la m√©thodes en dehors de la classe</a>
</li>
<li><a href="#les-mthodes-dextension">Les m√©thodes d'extension</a>
</li>
<li><a href="#les-mthodes-gardes">Les m√©thodes gard√©es</a>
</li>
<li><a href="#la-symtrie-oopfp--thorie-et-pratique">La sym√©trie OOP/FP : th√©orie et pratique</a>
</li>
</ul>
</li>
<li><a href="#mthodes-gardes-en-ocaml">M√©thodes gard√©es en OCaml</a>
<ul>
<li><a href="#fournir-un-tmoin-dgalit-de-types">Fournir un t√©moin d'√©galit√© de types</a>
</li>
<li><a href="#contraindre-avec-eq">Contraindre avec <code>eq</code></a>
<ul>
<li><a href="#implmentation-de-linterface-objlist">Impl√©mentation de l'interface <code>obj_list</code></a>
</li>
<li><a href="#ajout-dune-mthode-garde-sum">Ajout d'une m√©thode gard√©e <code>sum</code></a>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a>
</li>
</ul>
</li>
</ul>
</section><article><p>Les <em>d√©fenseurs</em> de la <strong>programmation orient√©e objets</strong> d√©fendent souvent cette
derni√®re en affirmant que c'est &quot;<em>la mani√®re normale de raisonner (sur)
l'ensemble des objets du m√©tier</em>&quot; et qu'elle permet de mod√©liser efficacement
l'ensemble des structures de donn√©es de mani√®re uniforme. Pourtant, beaucoup de
critiques sont parfois formul√©es √† l'encontre de cette approche (&quot;<em>beaucoup</em>&quot;
est √† prendre avec des pincettes car l'OOP est encore et toujours l'approche la
plus populaire aujourd'hui, du moins selon leur repr√©sentation sur
<a href="https://github.com">Github</a> ou <a href="https://stackoverflow.com/">StackOverflow</a>).
Dans les critiques formul√©es, nous allons nous int√©resser tout particuli√®rement
√† <strong>l'absence de m√©thodes gard√©es</strong>, qui n'est pas, objectivement, reli√©e √†
l'orient√© objets, car il serait envisageable de les int√©grer, mais qui manque
dans beaucoup de langages OOP populaires.</p>
<h2 id="prsentation-du-problme">Pr√©sentation du probl√®me</h2>
<p>Quand un langage (dont les v√©rification des types est effectu√©e avant
l'ex√©cution du programme, comme en Java ou en OCaml) introduit du
<strong>polymorphisme param√©trique</strong> (les <em>g√©n√©riques de Java</em>), on peut parfois
contraindre les variables de types. Par exemple :</p>
<pre><code class="language-java">class MyClass&lt;T extends S&gt; { ... }
</code></pre>
<p>On rend <code>MyClass</code> g√©n√©rique en admettant que la variable de type <code>T</code> est un
sous-type de <code>S</code>. Le probl√®me est que la contrainte agit <strong>sur toute la
classe</strong>. Pourtant, parfois, nous voudrions pouvoir n'avoir des contraintes
que <strong>sur certaines m√©thodes</strong>. Par exemple, admettons que nous ayons une
classe <code>MyList</code> d√©crivant une liste :</p>
<pre><code class="language-java">class MyList&lt;A&gt; extends ArrayList&lt;A&gt; {
   public int length() {
     return this.size();
   }
}
</code></pre>
<p>Comment d√©crire une m√©thode <code>flatten</code> qui pour une liste <code>[[1, 2, 3], [4, 5]]</code>
produirait la liste <code>[1, 2, 3, 4, 5]</code> ? Si on place la contrainte au niveau
de la classe on force notre liste √† √™tre &quot;<em>tout le temps une liste de liste</em>&quot;
ce qui est tr√®s contraignant. Pour impl√©menter une telle m√©thode, on dispose
de trois approches th√©oriques :</p>
<h3 id="dplacer-la-mthodes-en-dehors-de-la-classe">D√©placer la m√©thodes en dehors de la classe</h3>
<p>La premi√®re solution est la plus √©vidente, il suffit de &quot;<em>tricher</em>&quot; en d√©pla√ßant
la m√©thode en dehors du corps de classe (par exemple dans le contexte statique
ou l'objet <em>compagnon</em>) :</p>
<pre><code class="language-java">class MyList&lt;A&gt; extends ArrayList&lt;A&gt; {
   public static &lt;A&gt; MyList&lt;A&gt; flatten(MyList&lt;MyList&lt;A&gt;&gt; list) {
      // Impl√©mentation de flatten
   }
   public int length() {
     return this.size();
   }
}
</code></pre>
<p>Cette approche fonctionne et ne n√©cessite pas de c√©r√©monie particuli√®re par
contre, elle force le d√©veloppeur √† garder en t√™te les m√©thodes pr√©sentes dans
le corps de la classe et dans son contexte statique. En plus, cela casse
l'approche syst√©matique de l'envoi de messages √† une instance (souvent pr√©sent√©e
comme un des arguments en faveur de la programmation orient√©e objets).</p>
<h3 id="les-mthodes-dextension">Les m√©thodes d'extension</h3>
<p><a href="https://kotlinlang.org/">Kotlin</a> (et d'autres, comme
<a href="https://docs.microsoft.com/en-us/dotnet/csharp/">C#</a>) proposent des <a href="https://kotlinlang.org/docs/extensions.html">m√©thodes
d'extension</a> qui, en plus de
permettre <strong>l'extension d'une classe d√©j√† existante</strong> (ce qui peut √™tre tr√®s
pratique pour ajouter du comportement √† la classe <code>String</code> qui, en Java, est
finale), permet plus de finesse dans la d√©finition du <em>receveur</em>. Nous
pourrions, par exemple, √©crire <code>flatten</code> de cette mani√®re (en Kotlin) :</p>
<pre><code class="language-kotlin">class MyList&lt;A&gt; : ArrayList&lt;A&gt; { ... }
fun &lt;A&gt; MyList&lt;MyList&lt;A&gt;&gt;.flatten() = ...
</code></pre>
<p>M√™me si la solution semble proche de la perfection, elle impose tout de m√™me la
d√©finition de la m√©thode <strong>en dehors de la classe</strong> ce qui pourrait
potentiellement impliquer de devoir rendre certains membres de la classe
<em>publiques</em> en vue d'√™tre exploitable par une extension. Cependant elles
permettent tout de m√™me <strong>de garder l'approche syst√®matique de l'envoi de
messages tout en offrant la possibilit√© de qualifier plus finement le
receveur</strong>.</p>
<h3 id="les-mthodes-gardes">Les m√©thodes gard√©es</h3>
<p>La derni√®re approche est probablement la plus id√©ologique car elle ne sort pas
la d√©finition de la m√©thode en dehors de la classe. Elle ne force donc pas
d'abstractions √©chapp√©es. Il s'agit des <strong>m√©thodes gard√©es</strong>, soit la possibilit√©
d'ajouter, au niveau de la d√©finition de la m√©thode, des contraintes sur le
param√®tre g√©n√©rique. Dans une syntaxe <strong>imaginaire</strong> (ce code compile parce
qu'il n'est pas syntaxiquement faux par contre, il ne produit pas l'effet
d√©sir√©) :</p>
<pre><code class="language-kotlin">class MyList&lt;A&gt; : ArrayList&lt;A&gt;() {
    fun length() = size
    fun &lt;B&gt; MyList&lt;MyList&lt;B&gt;&gt;.flatten() =
        // Impl√©mentation de flatten
}
</code></pre>
<p>M√™me si √ßa ne semble pas sensiblement diff√©rent des m√©thodes d'extensions
classiques (pour preuve, la syntaxe de ces derni√®res, mais <strong>dans le corps de la
classe</strong> semble suffire), on corrige tous les soucis r√©v√©l√©s pr√©c√©demment :</p>
<ul>
<li>on peut caract√©riser plus finement que dans une m√©thode <em>normale</em> le receveur
</li>
<li>on ne casse pas l'envoi de messages r√©guliers
</li>
<li>on b√©n√©ficie toujours des membres disponibles (donc on n'√©chappe pas de
repr√©sentations)
</li>
</ul>
<p>M√™me si les m√©thodes gard√©es semblent √™tre n√©cessaires, je ne connais
malheureusement pas de langages <em>mainstream</em> qui permettent leur d√©finition.
Voil√† qui est tr√®s triste. Heureusement, en OCaml, il est possible de les
<em>encoder</em>.</p>
<h3 id="la-symtrie-oopfp--thorie-et-pratique">La sym√©trie OOP/FP : th√©orie et pratique</h3>
<p>Comme les m√©thodes gard√©es sont assez rares dans les langages de programmation
populaires j'ai d√©couvert leur existence assez r√©cemment, en lisant les
<a href="http://gallium.inria.fr/~scherer/doc/oo-fp-symmetry-bob-2020.org">transparents</a>
de la pr√©sentation &quot;<em><a href="https://www.youtube.com/watch?v=TrameN7BTCQ">The Object-Oriented/Functional-Programming symmetry: theory
and practice </a></em>&quot; de <a href="http://gallium.inria.fr/~scherer/">Gabriel
Scherer</a>.</p>
<p>Je recommande cette pr√©sentation qui pr√©sente une <strong>sym√©trie</strong> entre les outils
de la programmation fonctionnelle statiquement typ√©e et la programmation
orient√©e objets. M√™me si cette sym√©trie √† √©t√© de tr√®s nombreuses fois observ√©e et
√©tudi√©e, la pr√©sentation est exhaustive et accessible (et relativement peu
biais√©e, posant les avantages et inconv√©nients des deux approches).
Malheureusement non couvertes pendant la pr√©sentation (<em>le temps est souvent
l'ennemi d'un pr√©sentateur</em>), toute une section est d√©di√©e aux m√©thodes gard√©es
dans les transparents. L'exemple original propose une observation sym√©trique
entre l'impl√©mentation de la fonction <code>flatten</code> dans un style fonctionnel
classique :</p>
<pre><code class="language-ocaml">type 'a list = ...
let rec length : 'a list -&gt; int = ...
let rec concat : 'a list -&gt; 'a list -&gt; 'a list = ...

let rec flatten : 'a list list -&gt; 'a list = function
  | [] -&gt; []
  | x::xs -&gt; x @ flatten xs
</code></pre>
<p>Et l'impl√©mentation d'une m√©thode <code>flatten</code> si nous √©tions dans le monde
objet, posant exactement le probl√®me introduit dans cette note. Soit quel
type donner √† <code>flatten</code> :</p>
<pre><code class="language-ocaml">class type ['a] olist = object
  method length : int
  method concat : 'a olist -&gt; 'a olist

  method flatten : ???
end
</code></pre>
<p>Il propose donc cette syntaxe, qui implique une garde sur la m√©thode <code>flatten</code>:</p>
<pre><code class="language-ocaml">method flatten : 'b olist with 'a = 'b olist
</code></pre>
<p>Cette syntaxe permet de d√©crire une m√©thode gard√©e et pourrait se g√©n√©raliser de
cette mani√®re : <code>method method_name : return_type with generic_type = other_type</code>.
Un peu √† la mani√®re des <strong>substitution</strong> dans les modules, on pourrait d√©crire
des contraintes sur plusieurs g√©n√©riques au moyen de <code>and</code>. Par exemple :
<code>method foo : string with 'a = string and b = int</code> pour une classe param√©tr√©e
par deux types : <code>class ['a, 'b] t</code>.</p>
<p>En compl√©ment, cette syntaxe permettrait aussi de d√©finir des comportements sp√©cifiques
de mani√®re √©l√©gante, par exemple, pour notre type <code>olist</code>, nous pourrions proposer
une m√©thode <code>sum</code> si les habitants de la liste sont des entiers :</p>
<pre><code class="language-ocaml">class type ['a] olist = object
  method length : int
  method concat : 'a olist -&gt; 'a olist
  method flatten : 'b olist with 'a = 'b olist
  method sum : int with 'a = int
end
</code></pre>
<p>Tout ceci semble extraordinaire, <strong>malheureusement, cette syntaxe n'est pas disponible</strong>
en OCaml. Voil√† qui est ennuyant ! Pas de panique, il est possible de <strong>l'encoder</strong>
au moyen de quelques petits outils.</p>
<h2 id="mthodes-gardes-en-ocaml">M√©thodes gard√©es en OCaml</h2>
<blockquote>
<p>M√™me si j'avais une id√©e assez pr√©cise des outils √† mettre en oeuvre dans
l'encodage des m√©thodes gard√©es, en me heurtant √† quelques <em>corner-cases</em>,
j'ai d√©cid√© de faire appel √† celui qui, dans la communaut√© OCaml, ne pose
jamais de questions mais y r√©pond toujours de mani√®re expansive : <a href="https://github.com/Octachron">Florian
Angeletti</a>, aussi connu sous le nom de
<strong>Octachron</strong>. (Petite note amusante, <code>octachron</code> est le nom d'un s√©quenceur
de batterie midi, donc en cherchant son pseudonyme sur <em>Google</em>, j'ai tout de
suite eu, dans les suggestions : <code>octachron ocaml</code>.)</p>
</blockquote>
<p>Notre objectif est de permettre d'ajouter une contrainte √† certaines m√©thodes pour
ne les rendre accessibles que si le type du receveur la satisfait. Sans passer par
de la modification syntaxique du langage, mod√©liser une contrainte peut <strong>consister
√† donner un param√®tre additionnel qui l'enforce</strong>. En d'autres mots, on voudrait
fournir une <strong>√©vidence</strong>.</p>
<h3 id="fournir-un-tmoin-dgalit-de-types">Fournir un t√©moin d'√©galit√© de types</h3>
<p>Depuis l'introduction des <a href="https://v2.ocaml.org/releases/4.14/htmlman/gadts-tutorial.html#sec63">types alg√©briques
g√©n√©ralis√©s</a>
dans le langage, il existe une mani√®re assez directe de d√©finir un t√©moin
d'√©galit√© de types :</p>
<pre><code class="language-ocaml">type (_, _) eq =
  | Refl : ('a, 'a) eq
</code></pre>
<p>Le type <code>eq</code>, qui n'a qu'un seul constructeur : <code>Refl</code>, et permet de repr√©senter
des √©galit√© de types <strong>non connues par le <em>type-checker</em></strong>. Comme on ne peut que
construire des valeurs <code>Refl</code> qui associent deux types √©gaux, l'instanciation
de <code>Refl</code> dans un <em>scope</em> garantit qu'ils sont √©quivalents. Par exemple :</p>
<pre><code class="language-ocaml">type other_int = int
let _ : (int, other_int) eq = Refl
(* D√®s lors, on poss√®de une preuve que [int = other_int]. *)_
</code></pre>
<p>Cet exemple est assez artificiel car ici, le compilateur sait parfaitement que
<code>int = other_int</code>, cependant, il existe des cas o√π le compilateur ne peut pas
le savoir. Par exemple, si une donn√©e est fournie √† l'ex√©cution du programme, o√π
il est parfaitement logique que le <em>type-checker</em> n'ait aucune information sur
un type ou encore quand la repr√©sentation du type est cach√©e par l'abstraction.</p>
<p>L'objectif de cette note n'est pas de nous √©tendre sur <code>eq</code> donc ne retenons que
le fait que si on peut construire une valeur <code>Refl</code>, on peut avoir une garantie
que deux types <em>syntaxiquement diff√©rents</em> sont en fait √©gaux.</p>
<h3 id="contraindre-avec-eq">Contraindre avec <code>eq</code></h3>
<p>Reprenons notre exemple qui fournit une API objet √† une liste. Voici son interface :</p>
<pre><code class="language-ocaml">class type ['a] obj_list =
  object ('self)
    method length : int
    method append : 'a list -&gt; 'a obj_list
    method uncons : ('a * 'self) option
    method flatten : ???
  end
</code></pre>
<p>Pour donner un type √† <code>flatten</code>, ou voudrait imposer que <code>'a</code> (le param√®tre de
type de la classe <code>obj_list</code>) soit une liste. En d'autre mot, nous voudrions
<strong>une preuve que <code>'a</code> est de type <code>'b list</code></strong>. Soit garantir que <code>'a</code> et <code>'b list</code>, bien que syntaxiquement diff√©rents, soient √©gaux. Rien de plus simple, il
suffit de demander d'en fournir une valeur de type <code>('a, 'b list) eq</code> :</p>
<pre><code class="language-ocaml">method flatten : ('a, 'b list) eq -&gt; 'b list
</code></pre>
<p>Maintenant que nous avons une interface qui d√©crit une liste avec une m√©thode
<code>flatten</code> qui contraint le receveur √† √™tre <code>une liste de quelque chose</code>,
impl√©mentons concr√®tement une classe qui impl√©mente <code>obj_list</code>.</p>
<h4 id="implmentation-de-linterface-objlist">Impl√©mentation de l'interface <code>obj_list</code></h4>
<p>Les premi√®res m√©thodes (<code>length</code>, <code>append</code> et <code>uncons</code>) sont triviales √†
impl√©menter :</p>
<pre><code class="language-ocaml">let my_list (list : 'a list) =
  object (self : 'a obj_list)
    val l = list
    method length = List.length l
    method append x = {&lt;l = List.append l x&gt;}
    method uncons = match l with [] -&gt; None | x :: xs -&gt; Some (x, {&lt;l = xs&gt;})

    method flatten = ???
  end
</code></pre>
<p>Maintenant, int√©ressons-nous √† <code>flatten</code>. On va r√©cursivement parcourir
la liste en concat√©nant chaque √©l√©ment au pr√©c√©dent. Par exemple :
<code>[[1]; [2]; [3]]</code> donnera <code>[1] @ [2]; [3]</code>. Au-del√† des annotations un
peu bruyantes, toute l'astuce r√©side dans l'instanciation de <code>Refl</code> pour
nous fournir une √©vidence sur le fait que <code>'a = 'b list</code>.</p>
<pre><code class="language-ocaml">method flatten : 'b. ('a, 'b list) eq -&gt; 'b list =
  let rec aux : type a b. a #obj_list -&gt; (a, b list) eq -&gt; b list =
  fun list witness -&gt; match list#uncons with
    | None -&gt; []
    | Some (head_list, xs) -&gt;
        let flatten_list : b list =
          let Refl = witness  in head_list
        in flatten_list @ aux xs witness
  in aux self
</code></pre>
<h4 id="ajout-dune-mthode-garde-sum">Ajout d'une m√©thode gard√©e <code>sum</code></h4>
<p>Maintenant que nous sommes capable de contraindre certaines m√©thodes, essayons
d'ajouter une m√©thode <code>sum</code> qui produit la somme d'une liste d'entiers !
Premi√®rement ajoutons <code>sum</code> √† notre interface. Cette fois, on veut contraindre
notre param√®tre de type √† √™tre <code>int</code>. Pour cela, il suffit de prendre
<code>('a, int) eq</code> comme t√©moin d'√©galit√© :</p>
<pre><code class="language-ocaml">class type ['a] obj_list =
  object ('self)
    method length : int
    method append : 'a list -&gt; 'a obj_list
    method uncons : ('a * 'self) option
    method flatten : ('a, 'b list) eq -&gt; 'b list
    method sum : ('a, int) eq -&gt; int
  end
</code></pre>
<p>Ensuite, on peut impl√©menter la m√©thode <code>sum</code>, qui n'est qu'une utilisation
de la fonction <code>fold_left</code>.</p>
<pre><code class="language-ocaml">method sum : ('a, int) eq -&gt; int =
  let aux : type a. a list -&gt; (a, int) eq -&gt; int = fun list Refl -&gt;
    List.fold_left (fun acc x -&gt; acc + x) 0 list
  in aux l
</code></pre>
<p>L'impl√©mentation de <code>sum</code> est logiquement plus simple que celle de <code>flatten</code>
parce qu'elle n'introduit pas de variables de type compl√©mentaires. Et on peut
tester nos diff√©rentes m√©thodes, on peut invoquer <code>flatten</code> sur un objet de type
<code>'a list obj_list</code>et <code>sum</code> sur un objet de type <code>int obj_list</code>.</p>
<pre><code class="language-ocaml">let a = my_list [ [ 1 ]; [ 2 ]; [ 3 ] ]
let _ = assert ([ 1; 2; 3 ] = a#flatten Refl)
let b = my_list [ 1; 2; 3; 4 ]
let _ = assert (10 = b#sum Refl)
</code></pre>
<p>Si l'on tente d'appliquer une m√©thode gard√©e avec un mauvais type, par exemple, essayer
de faire la somme de notre liste <code>a</code> (qui est de type <code>'a list obj_list</code>), le programme
ne compilera pas, logique, nous essayons d'appeler une m√©thode gard√©e <strong>sans respecter
la contrainte qu'elle impose</strong>.</p>
<pre><code class="language-ocaml">1 | let _ = a#sum Refl
                  ^^^^
Error: This expression has type (int list, int list) eq
       but an expression was expected of type (int list, int) eq
       Type int list is not compatible with type int
</code></pre>
<p>Soit exactement le comportement attendu ! Nous pouvons maintenant d√©finir des
m√©thodes qui <strong>contraignent le type du receveur</strong> au moyen d'un t√©moin
d'√©galit√©. <strong>mission complete</strong> !</p>
<h2 id="conclusion">Conclusion</h2>
<p>Il est surprenant que les m√©thodes gard√©es ne soient pas pr√©sentes dans tous les
langages OOP, poss√©dant une v√©rification statique des types, parce qu'elles
permettent d'exprimer plus de m√©thodes, tout en <strong>pr√©servant la s√©mantique
d'envoi de message</strong>, si ch√®re √† la programmation orient√©e objets. N'√©tant pas
un grand utilisateur de langages de programmation orient√©e objets (OCaml est le
seul que je pratique r√©guli√®rement), je ne suis pas au fait de langages
fournissant un support syntaxique des m√©thodes gard√©es. Je sais par contre,
depuis peu, point√© par <a href="https://twitter.com/NicolasRinaudo">Nicolas Rinaudo</a>,
que le langage <a href="https://www.scala-lang.org/">Scala</a> utilise un encodage
similaire √† celui propos√© dans cette note mais o√π le t√©moin d'√©galit√© est
fourni <em>implicitement</em>, all√©geant ainsi l'appel, n'obligeant pas l'utilisateur √†
fournir manuellement <code>Refl</code>.</p>
<p>M√™me si l'encodage est un peu lourd, et que l'on pourrait imaginer un support
natif dans le langage pour simplifier la d√©finition de m√©thode gard√©e,
<strong>manipuler explicitement un t√©moin d'√©galit√© de type permet de les encoder</strong>.
Est-ce utile ? Comme la programmation OOP est rarement encourag√©e en OCaml,
<em>probablement pas</em>, mais c'√©tait tout de m√™me amusant de pr√©senter un cas
d'usage concret et pratique √† l'utilisation de t√©moins d'√©galit√©s !</p>
</article>
</main>
    <footer>
      <div class="container">
        <p>
          Diffus√© sous licence
          <a href="https://creativecommons.org/licenses/by-sa/4.0/">
            <strong>CC BY-SA</strong>
          </a>
        </p>
        <p>
          Honteuseument g√©n√©r√© par
          <a href="https://github.com/xhtmlboi/yocaml">
            <strong>YOCaml</strong>
          </a>
        </p>
        <p class="feed-icons"><a href="/feeds.html">üÆæ</a></p>
      </div>
    </footer>
    <script>
      capsule.mount();
    </script>
  </body>
</html>
