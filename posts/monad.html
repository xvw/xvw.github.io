<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
  <link rel="alternate" type="application/atom+xml" title="xvw blog" href="../atom.xml" />
  <link href="https://fonts.googleapis.com/css?family=Lora:400,400i,700,700i|Playfair+Display:400,700,900|Fira+Mono" rel="stylesheet">
  <link rel="stylesheet" href="../css/default.css" />
  <script src="../js/player.js" type="application/javascript"></script>
  <title>xvw - Un article sur les monades en 2018</title>
</head>

<body>
  <div id="resume-reader" class="history-tooltip">
  <a href="../index.html">Revenir à l'accueil</a>
  <div id="resume-box"></div>
  <div class="progress">
    <div id="progress-bar"></div>
  </div>
</div>

<main class="article">

  <h1 class="main-title">Un article sur les monades en 2018</h1>
  <div class="date">Publié le 22 du 08 2018</div>
  <blockquote>
<p>Ce n’est pas très original d’écrire, en 2018, un article sur les monades. Cependant, ça présente plusieurs intérêts. Premièrement, ça permet d’ajouter relativement facilement un peu de contenu à mon blog. Ensuite, il y a déjà énormément de documentation. Pour terminer, ça permet, éventuellement, de servir de base à des articles potentiellement originaux.</p>
<p>L’article suppose que vous ayez … une vague idée de ce qu’est une monade, ou d’avoir au moins trifouillé IO en Haskell. Mais bon, vous pouvez quand même lire l’article sinon (évidemment).</p>
<p>L’objectif réel de cet article est de concrétiser (du mieux que je peux) une intuition liée aux monades. Parce que ça permet, parfois, d’écrire du code lisible, et puis c’est toujours cool de pouvoir se servir de mots compliqués pour expliquer des choses concrètes (pour peu que l’on donne les outils pour être compris !)</p>
</blockquote>
<p>Il m’arrive souvent de lire, sur <em>les internets</em>, que la communauté des programmeurs fonctionnels est élitiste. Même si je ne me considère pas comme appartenant à cette communauté, je dois avouer que quand j’ai eu des questions (plein de questions !) à lui poser, j’ai très souvent eu des réponses claires, tenant bien souvent compte du fait que j’étais (et suis toujours) un total néophyte et qu’il fallait parfois me prendre par la main. Je n’ai donc jamais réellement trouvé les membres de <em>ces</em> communautés particulièrement élitistes. Je les voyais plus comme détenteurs d’un savoir intéressant.</p>
<p>Par contre, ce qu’il faut avouer, c’est que le <a href="https://github.com/hemanth/functional-programming-jargon"><em>jargon</em> de la programmation fonctionnelle</a> peut parfois être très impressionnant. Je pense que la notion de <strong>monades</strong>, particulièrement commentée/illustrée sur internet, fait partie de la collection de terminologie que l’on pourrait considérer comme “bloquante” (aha) quand on apprend à utiliser un langage, comme <a href="https://www.haskell.org/">Haskell</a> par exemple, qui propose rapidement de s’en servir pour des cas d’usages spécifiques.</p>
<p>L’objectif de l’article est de résumer ce que <strong>je pense</strong> avoir compris des monades, quelques années après en avoir utilisé dans plusieurs projets (parfois ne sachant pas du tout qu’il s’agissait de monades). Pour ça, on s’intéressera aux origines des monades, et on en présentera sommairement quelques-unes.</p>
<p>Par contre, je pense que le terme est parfois trop utilisé, par exemple : “<em>Ah ! Ta fonction doit potentiellement ne rien renvoyer ? Tu n’as qu’à utiliser</em> <em>la monade Option</em> !”. Je pense que ce genre de phrase véhicule une idée d’élitisme <em>latent</em>, bien que peu pernicieuse. J’ai rarement entendu quelqu’un dire “<em>Ah ! tu veux transformer les données d’une liste en autre chose ? Tu n’as qu’à</em> <em>utiliser le Foncteur List</em>”.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<h2 id="de-la-théorie-des-catégories-à-la-programmation">De la théorie des catégories à la programmation</h2>
<p>Historiquement appelées “<em>constructions standards</em>” ou “<em>triples</em>” en topologie algébrique dans les années 50, c’est en 1971 que <a href="https://en.wikipedia.org/wiki/Saunders_Mac_Lane">Saunders MacLane</a> leur donne le nom de <strong>monades</strong>, en référence au <em>concept philosophique</em> du même nom, et en l’utilisant dans <strong>la théorie des catégories</strong>. Il introduit aussi une des <em>punchlines</em> les plus <em>badass</em> du monde de la programmation fonctionnelle (à mon sens), “<em>a monad is a monoid in the category of endofunctors</em>”. Ce qui est cool avec cette phrase, c’est qu’elle ne dit absolument rien pour, à mon avis, 89% (ce nombre est évidemment choisi arbitrairement) des programmeurs.</p>
<p>Plus tard, <a href="https://en.wikipedia.org/wiki/Eugenio_Moggi">Eugenio Moggi</a> donnera cette définition : une <strong>monade</strong> sur une <strong>catégorie</strong> <span class="math inline"><em>Ω</em></span> est un <strong>triplet</strong> (<span class="math inline"><em>T</em>, <em>η</em>, <em>μ</em></span>) où :</p>
<ul>
<li><span class="math inline"><em>T</em> : <em>Ω</em> → <em>Ω</em></span> est un <strong>foncteur</strong> ;</li>
<li><span class="math inline"><em>η</em> : <em>I</em><em>d</em><sub><em>Ω</em></sub> → <em>T</em></span> et <span class="math inline"><em>μ</em> : <em>T</em><sup>2</sup> → <em>T</em></span> sont des <strong>transformations naturelles</strong> telles que :
<ul>
<li><span class="math inline"><em>μ</em><sub><em>A</em></sub> • <em>T</em><em>μ</em><sub><em>A</em></sub> = <em>μ</em><sub><em>A</em></sub> • <em>μ</em><sub><em>T</em><em>A</em></sub></span></li>
<li><span class="math inline"><em>μ</em><sub><em>A</em></sub> • <em>η</em><sub><em>T</em><em>A</em></sub> = <em>I</em><em>d</em><sub><em>T</em><em>A</em></sub> = <em>μ</em><sub><em>A</em></sub> • <em>T</em><sub><em>η</em><em>A</em></sub></span></li>
</ul></li>
</ul>
<p>Tout ça ne nous avance pas beaucoup, surtout si on a aucun bagage en théorie des catégories. Cependant, ça aura eu le mérite de faire croitre la crédibilité de l’article en ajoutant des petits symboles grecs un peu partout !</p>
<p>Concrètement, essayons de voir rapidement ce que tout cela veut dire :</p>
<ul>
<li>le <span class="math inline"><em>T</em></span> de notre foncteur signifie qu’il s’agit d’un <strong>type paramétré</strong>, par exemple <em>une liste de choses</em> (<code class="sourceCode ocaml" rundoc-language="ocaml">'a <span class="dt">list</span></code>), ou d’une option de quelque chose (<code class="sourceCode ocaml" rundoc-language="ocaml">'a <span class="dt">option</span></code>) ;</li>
<li>les transformations naturelles <span class="math inline"><em>η</em></span> et <span class="math inline"><em>μ</em></span> sont en quelque sorte des fonctions ;</li>
<li><span class="math inline"><em>T</em><sup>2</sup></span> exprime, en référence à nos exemples précédents, <em>une liste de liste de</em> <em>choses</em> (<code class="sourceCode ocaml" rundoc-language="ocaml">'a <span class="dt">list</span> <span class="dt">list</span></code>) ou encore <code class="sourceCode ocaml" rundoc-language="ocaml">'a <span class="dt">option</span> <span class="dt">option</span></code> ;</li>
<li><span class="math inline"><em>I</em><em>d</em></span> exprime l’identité, donc une fonction qui pour <code class="sourceCode ocaml" rundoc-language="ocaml">x</code> renvoie <code class="sourceCode ocaml" rundoc-language="ocaml">x</code>, par exemple <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="kw">fun</span> x -&gt; x</code> ;</li>
<li>l’opérateur <span class="math inline">•</span> est un opérateur <a href="https://en.wikipedia.org/wiki/Function_composition">de composition</a>.</li>
</ul>
<p>Essayons de projeter ces ingrédients dans un langage de programmation statiquement typé, comme <strong>OCaml</strong> par exemple.</p>
<h3 id="traduction-dune-définition-catégorique-dans-un-langage-fonctionnel">Traduction d’une définition catégorique dans un langage fonctionnel</h3>
<p>La traduction proposée par <a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">Philip Wadler</a> considère que le foncteur devient <strong>un constructeur de type</strong> (un type paramétré) avec une fonction de <em>mapping</em>, ce qui correspond formellement à la définition d’un foncteur. Et les deux transformations naturelles deviennent des <strong>fonctions</strong>, <code class="sourceCode ocaml" rundoc-language="ocaml">join</code> pour <span class="math inline"><em>μ</em></span> et <code class="sourceCode ocaml" rundoc-language="ocaml">pure</code> pour <span class="math inline"><em>η</em></span>.</p>
<p>Dans l’exemple ci-dessous, j’utilise un module pour représenter les opérations liées à une monade.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">module</span> <span class="kw">type</span> MONAD =
<span class="kw">sig</span>
  <span class="co">(* Le foncteur *)</span>
  <span class="kw">type</span> 'a t
  <span class="kw">val</span> map  : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t

  <span class="co">(* La transformation naturelle η *)</span>
  <span class="kw">val</span> pure : 'a -&gt; 'a t

  <span class="co">(* La transformation naturelle μ *)</span>
  <span class="kw">val</span> join : ('a t) t -&gt; 'a t
<span class="kw">end</span></code></pre></div>
<blockquote>
<p><strong>NB:</strong> Parfois, il arrive que la transformation <code class="sourceCode ocaml" rundoc-language="ocaml">pure</code> s’appelle <code class="sourceCode ocaml" rundoc-language="ocaml">return</code>, j’ai pris la décision d’utiliser <code class="sourceCode ocaml" rundoc-language="ocaml">pure</code> pour éviter une confusion potentielle avec le mot clé <strong>return</strong> de la programmation impérative.</p>
</blockquote>
<p>Nous avons encodé, en OCaml, une partie des ingrédients évoqués en théorie des catégories, cependant, dans la définition, il était question de certaines contraintes liées aux transformations naturelles.</p>
<p>On pose donc les deux contraintes (qu’on appelle des “<strong>lois</strong>”) :</p>
<ul>
<li><span class="math inline"><em>j</em><em>o</em><em>i</em><em>n</em> • <em>j</em><em>o</em><em>i</em><em>n</em> = <em>j</em><em>o</em><em>i</em><em>n</em> • <em>m</em><em>a</em><em>p</em> <em>j</em><em>o</em><em>i</em><em>n</em></span></li>
<li><span class="math inline"><em>j</em><em>o</em><em>i</em><em>n</em> • <em>p</em><em>u</em><em>r</em><em>e</em> = <em>i</em><em>d</em> = <em>j</em><em>o</em><em>i</em><em>n</em> • <em>m</em><em>a</em><em>p</em> <em>p</em><em>u</em><em>r</em><em>e</em></span></li>
</ul>
<p>Ce n’est malheureusement pas suffisant. En décrivant les fonctions comme des transformations naturelles, nous avions évoqué que c’était “presque pareil”. Les transformations naturelles impliquent des lois complémentaires, qui sont implicites dans la définition catégorique car on est <strong>explicite</strong> sur le fait qu’il s’agit de transformations naturelles. Ici comme on utilise des fonctions, il est nécessaire d’adjoindre 4 lois pour formaliser le fait que les deux fonctions <code class="sourceCode ocaml" rundoc-language="ocaml">join</code> et <code class="sourceCode ocaml" rundoc-language="ocaml">pure</code> sont bien des transformations naturelles :</p>
<ul>
<li><span class="math inline"><em>m</em><em>a</em><em>p</em> <em>i</em><em>d</em> = <em>i</em><em>d</em></span></li>
<li><span class="math inline"><em>m</em><em>a</em><em>p</em> (<em>g</em> • <em>f</em>)  = <em>m</em><em>a</em><em>p</em> <em>g</em> • <em>m</em><em>a</em><em>p</em> <em>f</em></span></li>
<li><span class="math inline"><em>m</em><em>a</em><em>p</em><em>f</em> • <em>j</em><em>o</em><em>i</em><em>n</em> = <em>j</em><em>o</em><em>i</em><em>n</em> • <em>m</em><em>a</em><em>p</em> (<em>m</em><em>a</em><em>p</em> <em>f</em>)</span></li>
<li><span class="math inline"><em>m</em><em>a</em><em>p</em><em>f</em> • <em>p</em><em>u</em><em>r</em><em>e</em> = <em>p</em><em>u</em><em>r</em><em>e</em> • <em>f</em></span></li>
</ul>
<p>Cependant, la traduction dans un langage fonctionnel ne garantit absolument pas que la fonction de <em>mapping</em> termine. De ce fait, <strong>la définition dans un langage</strong> <strong>fonctionnel n’est pas formellement une monade de la théorie des catégories</strong>.</p>
<p>Mais dans l’absolu, est-ce que ça nous concerne réellement quand on est utilisateur de bibliothèques monadiques ?</p>
<h3 id="une-différence-entre-la-définition-catégorique-et-programmatique">Une différence entre la définition <em>catégorique</em> et <em>programmatique</em></h3>
<p>En fait, le point essentiel de cette introduction un peu barbante, c’est que même si elles sont analogues, elles sont aussi différentes. En théorie des catégories, les monades ont été développées par Moggi pour <strong>raisonner</strong> à propos des programmes à effets, alors que les monades présentées par Wadler sont utilisées pour <strong>implémenter</strong> des programmes à effets dans un langage de programmation fonctionnel pur. En plus de ça, la sémantique du contexte fait légèrement varier les deux définitions de monades, certains aspects des propositions de Moggi ne sont pas nécessaires dans une monade définie dans le contexte d’un langage de programmation.</p>
<p>Donc même si connaître l’origine mathématique d’un objet de programmation est sans doute toujours intéressant, il ne faut pas développer d’analogies trop fortes, pour ne pas tendre vers une stricte équivalence entre le concept initial, issu des mathématiques, et son implémentation concrète dans un langage de programmation parce qu’il est fort probable que certaines règles, certains outils soient légèrement altérés par le changement de contexte.</p>
<p>Ne retenons donc que la phrase “<em>A monad is just a monoid in the category of</em> <em>endofunctors, what’s the problem?</em>” pour pouvoir briller en société.</p>
<h2 id="les-monades-en-programmation-fonctionnelle">Les monades en programmation fonctionnelle</h2>
<p>En général, quand on lit des ressources sur les monades, on utilise parfois (… oké, souvent) une autre interface :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">module</span> <span class="kw">type</span> MONAD =
<span class="kw">sig</span>
  <span class="kw">type</span> 'a t
  <span class="kw">val</span> pure  : 'a -&gt; 'a t
  <span class="kw">val</span> (&gt;&gt;=) : 'a t -&gt; ('a -&gt; 'b t)  -&gt; 'b t
<span class="kw">end</span></code></pre></div>
<blockquote>
<p><strong>NB:</strong> Dans certains langages, <code class="sourceCode ocaml" rundoc-language="ocaml">&gt;&gt;=</code> s’appelle parfois <code class="sourceCode ocaml" rundoc-language="ocaml">flatMap</code>.</p>
</blockquote>
<p>Qui doit satisfaire ces lois :</p>
<ul>
<li><span class="math inline"><em>p</em><em>u</em><em>r</em><em>e</em> <em>a</em> ≫= <em>f</em> = <em>f</em> <em>a</em></span></li>
<li><span class="math inline"><em>m</em> ≫= <em>p</em><em>u</em><em>r</em><em>e</em> = <em>m</em></span></li>
<li><span class="math inline">(<em>m</em> ≫= <em>f</em>) ≫= <em>g</em> = <em>m</em> ≫= (<em>f</em><em>u</em><em>n</em> <em>x</em> → <em>f</em> <em>x</em> ≫= <em>g</em>)</span></li>
</ul>
<p>Cette interface permet d’arriver exactement aux mêmes résultats que la précédente car il est possible d’implémenter <code class="sourceCode ocaml" rundoc-language="ocaml">map</code> et <code class="sourceCode ocaml" rundoc-language="ocaml">join</code> avec <code class="sourceCode ocaml" rundoc-language="ocaml">pure</code> et <code class="sourceCode ocaml" rundoc-language="ocaml">&gt;&gt;=</code> :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> join x  = x &gt;&gt;= (<span class="kw">fun</span> x -&gt; x)
<span class="kw">let</span> map f x = x &gt;&gt;= (<span class="kw">fun</span> x -&gt; pure (f x))</code></pre></div>
<p>De même qu’avec <code class="sourceCode ocaml" rundoc-language="ocaml">pure</code>, <code class="sourceCode ocaml" rundoc-language="ocaml">map</code> et <code class="sourceCode ocaml" rundoc-language="ocaml">join</code> il est possible d’implémenter <code class="sourceCode ocaml" rundoc-language="ocaml">&gt;&gt;=</code> :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> (&gt;&gt;=) x f = join (map f x)</code></pre></div>
<blockquote>
<p><strong>NB:</strong> Ici, le nom <code class="sourceCode ocaml" rundoc-language="ocaml">flatMap</code> prend tout son sens.</p>
</blockquote>
<p>Cette équivalence est possible si l’on respecte les lois que nous avons évoquées précédemment. C’est d’ailleurs tout l’intérêt de ces dernières. Elles permettent, en plus de créer une équivalence entre les deux interfaces, de dériver une <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Monad.html">collection de combinateurs</a> utiles lorsque l’on travaille avec des monades. Donc ces deux interfaces, couplées à leurs “lois”, sont les prérequis minimums pour découler une série d’outils très utiles. Cependant, nous ne les développerons pas dans cet article.</p>
<p>Concrètement, ces lois sont des axiomes attachés aux monades. Ils peuvent donc servir de base de raisonnement !</p>
<p>Certains me demanderont pourquoi j’ai introduit la monade en informatique avec la première interface, qui semble plus complexe et qui possède plus de lois. C’est parce que je trouve qu’il est <strong>plus facile de comprendre la relation</strong> entre une monade en programmation et une monade en théorie des catégories. En effet, on peut projeter presque chacun des ingrédients de la monade en théorie des catégories dans des objets d’un langage de programmation fonctionnelle statiquement typé.</p>
<h2 id="tout-ça-ce-ne-sont-que-des-interfaces">Tout ça, ce ne sont que des interfaces !</h2>
<p>Jusqu’à présent, nous avons observé (de loin) l’origine des monades et nous les avons représentées sous forme d’interfaces. Mais ça ne nous dit toujours pas ce que c’est et à quoi ça sert. Une manière de résumer le concept derrière des monades pourrait être de proposer deux petites définitions :</p>
<ul>
<li>une monade <strong>encapsule</strong> un <em>objet</em> dans une structure plus riche ;</li>
<li>et elle permet d’exprimer plusieurs <strong>types de construction</strong> pour une <strong>même structure</strong>.</li>
</ul>
<p>Concrètement, il suffit d’implémenter une des deux interfaces en veillant bien à respecter “les lois” pour avoir une monade. Donc <strong>il n’existe pas, à priori, de nombre fini de monades</strong>. Même s’il en existe des courantes, la condition pour être une monade est de respecter les prérequis des interfaces précédemment évoquées (tout en respectant leur lois).</p>
<p>Voici un module paramétré qui permet de construire des modules “monadiques” au besoin. Nous nous en servirons pour présenter quelques exemples.</p>
<blockquote>
<p><strong>NB:</strong> Un module paramétré, en OCaml, c’est un module qui est paramétré par un autre module, dont l’interface est fixée et qui permettra de produire un nouveau module construit sur la base du module paramétré et du module passé en argument.</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">module</span> <span class="kw">type</span> BINDABLE =
<span class="kw">sig</span>
  <span class="kw">type</span> 'a t
  <span class="kw">val</span> pure  : 'a -&gt; 'a t
  <span class="kw">val</span> (&gt;&gt;=) : 'a t -&gt; ('a -&gt; 'b t)  -&gt; 'b t
<span class="kw">end</span>

<span class="kw">module</span> <span class="kw">type</span> JOINABLE =
<span class="kw">sig</span>
  <span class="kw">type</span> 'a t
  <span class="kw">val</span> pure : 'a -&gt; 'a t
  <span class="kw">val</span> map  : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t
  <span class="kw">val</span> join : ('a t) t -&gt; 'a t
<span class="kw">end</span>

<span class="kw">module</span> <span class="kw">type</span> MONAD =
<span class="kw">sig</span>
  <span class="kw">type</span> 'a t
  <span class="kw">val</span> pure  : 'a -&gt; 'a t
  <span class="kw">val</span> map   : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t
  <span class="kw">val</span> join  : ('a t) t -&gt; 'a t
  <span class="kw">val</span> (&gt;&gt;=) : 'a t -&gt; ('a -&gt; 'b t)  -&gt; 'b t
<span class="kw">end</span>

<span class="kw">module</span> With_bind (M : BINDABLE) :
  MONAD <span class="kw">with</span> <span class="kw">type</span> 'a t = 'a M.t =
<span class="kw">struct</span>
  <span class="kw">include</span> M
  <span class="kw">let</span> join x  = x &gt;&gt;= (<span class="kw">fun</span> x -&gt; x)
  <span class="kw">let</span> map f x = x &gt;&gt;= (<span class="kw">fun</span> a -&gt; pure (f a))
<span class="kw">end</span>

<span class="kw">module</span> With_join (M : JOINABLE) :
  MONAD <span class="kw">with</span> <span class="kw">type</span> 'a t = 'a M.t =
<span class="kw">struct</span>
  <span class="kw">include</span> M
  <span class="kw">let</span> (&gt;&gt;=) x f = join (map f x)
<span class="kw">end</span></code></pre></div>
<p>Sans se soucier des détails syntaxiques liés à OCaml, on possède maintenant deux modules pour construire des modules qui définissent des monades. Le premier permet de construire un module monadique avec la première interface (qui requiert la présence de <code class="sourceCode ocaml" rundoc-language="ocaml">map</code> et <code class="sourceCode ocaml" rundoc-language="ocaml">join</code>), la seconde requiert <code class="sourceCode ocaml" rundoc-language="ocaml">&gt;&gt;=</code>.</p>
<h2 id="deux-premières-monades-option-et-list">Deux premières monades : <code class="sourceCode ocaml" rundoc-language="ocaml">Option</code> et <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">List</span></code></h2>
<p>Sans plus attendre, je vous propose deux implémentations concrètes de modules pour deux monades différentes.</p>
<p>Premièrement, la monade <code class="sourceCode ocaml" rundoc-language="ocaml">Option</code>, qui repose sur le type <code class="sourceCode ocaml" rundoc-language="ocaml">'a <span class="dt">option</span></code>. Ce type est assez simple, il permet de caractériser la présence d’une valeur ou non (ce qui permet, au demeurant, d’éviter les <code class="sourceCode java" rundoc-language="java"><span class="bu">NullPointerException</span></code>) :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">module</span> OptionM = With_bind(
  <span class="kw">struct</span>
    <span class="kw">type</span> 'a t = 'a <span class="dt">option</span>
    <span class="kw">let</span> pure x = <span class="dt">Some</span> x
    <span class="kw">let</span> (&gt;&gt;=) x f = <span class="kw">match</span> x <span class="kw">with</span>
      | <span class="dt">Some</span> a -&gt; f a
      | <span class="dt">None</span> -&gt; <span class="dt">None</span>
  <span class="kw">end</span>)</code></pre></div>
<p>La monade <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">List</span></code>, que l’on appelle aussi parfois, pour des raisons discutablement pédagogiques, <code class="sourceCode ocaml" rundoc-language="ocaml">Non_Determinist</code>, repose sur le type <code class="sourceCode ocaml" rundoc-language="ocaml">'a <span class="dt">list</span></code>. Cette fois j’ai utilisé le module <code class="sourceCode ocaml" rundoc-language="ocaml">With_join</code> pour la construire, car le module <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">List</span></code> expose déjà les fonctions dont j’ai besoin pour implémenter les prérequis.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">module</span> ListM = With_join(
  <span class="kw">struct</span>
    <span class="kw">type</span> 'a t = 'a <span class="dt">list</span>
    <span class="kw">let</span> pure x = [x]
    <span class="kw">let</span> map = <span class="dt">List</span>.map
    <span class="kw">let</span> join = <span class="dt">List</span>.flatten
  <span class="kw">end</span>)</code></pre></div>
<p>Comme nos fonctions <code class="sourceCode ocaml" rundoc-language="ocaml">&gt;&gt;=</code> renvoient une monade (pour rappel, voici son type <code class="sourceCode ocaml" rundoc-language="ocaml">'a t -&gt; ('a -&gt; 'b t)  -&gt; 'b t</code>), on peut chainer les appels de <code class="sourceCode ocaml" rundoc-language="ocaml">&gt;&gt;=</code>, ce qui est assez pratique.</p>
<p>Par exemple, imaginons cette fonction qui effectue la division de <code class="sourceCode ocaml" rundoc-language="ocaml">a</code> par <code class="sourceCode ocaml" rundoc-language="ocaml">b</code>. Si le diviseur est égal à zéro, la division échoue (et renvoie <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">None</span></code>), si elle réussit, elle emballe le résultat dans <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">Some</span></code>. Son type est <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> <span class="dt">option</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> safe_div b a =
  <span class="kw">if</span> b = <span class="dv">0</span> <span class="kw">then</span> <span class="dt">None</span>
  <span class="kw">else</span> <span class="dt">Some</span> (a / b)</code></pre></div>
<p>Voici deux valeurs calculées en utilisant notre module fraîchement défini :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> valueA = <span class="kw">let</span> <span class="kw">open</span> OptionM <span class="kw">in</span>
  pure <span class="dv">1000</span>
  &gt;&gt;= safe_div <span class="dv">10</span>
  &gt;&gt;= safe_div <span class="dv">100</span>

<span class="kw">let</span> valueB = <span class="kw">let</span> <span class="kw">open</span> OptionM <span class="kw">in</span>
  pure <span class="dv">1000</span>
  &gt;&gt;= safe_div <span class="dv">0</span>
  &gt;&gt;= safe_div <span class="dv">10</span></code></pre></div>
<blockquote>
<p><strong>NB:</strong> La construction <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="kw">let</span> <span class="kw">open</span> Module <span class="kw">in</span></code> permet d’ouvrir localement un module, pour ne pas devoir préfixer chacun des appels de fonctions dans le scope courant.</p>
</blockquote>
<p><code class="sourceCode ocaml" rundoc-language="ocaml">valueA</code> vaudra <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">Some</span> <span class="dv">1</span></code> car chacune des divisions est valide, par contre, <code class="sourceCode ocaml" rundoc-language="ocaml">valueB</code> vaudra <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">None</span></code> car la première étape divise par zéro.</p>
<p>Utilisons maintenant notre monade <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">List</span></code> en implémentant, par exemple, le produit cartésien de deux listes :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> ( &gt;&lt; ) list_a list_b = <span class="kw">let</span> <span class="kw">open</span> ListM <span class="kw">in</span>
  list_a
  &gt;&gt;= <span class="kw">fun</span> a -&gt; list_b
  &gt;&gt;= <span class="kw">fun</span> b -&gt; pure (a, b)

<span class="kw">let</span> valueC = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] &gt;&lt; [<span class="st">&quot;a&quot;</span>; <span class="st">&quot;b&quot;</span>; <span class="st">&quot;c&quot;</span>]</code></pre></div>
<blockquote>
<p><strong>NB:</strong> Je vous invite à essayer de comprendre au mieux l’implémentation du module <code class="sourceCode ocaml" rundoc-language="ocaml">ListM</code> pour tâcher de comprendre comment la fonction <code class="sourceCode ocaml" rundoc-language="ocaml">&gt;&lt;</code> (pour construire le produit cartésien de deux listes) fonctionne.</p>
</blockquote>
<p>En allant un peu plus loin avec le module <code class="sourceCode ocaml" rundoc-language="ocaml">ListM</code>, il est même possible de simuler le comportement des <a href="https://fr.wikipedia.org/wiki/Ensemble#D%C3%A9finition_d%E2%80%99un_ensemble_en_compr%C3%A9hension">compréhensions</a>. Pour cela, on va construire une fonction qui nous aidera à formaliser les compréhensions sous forme de construction monadique :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> keep_if predicate x = <span class="kw">let</span> <span class="kw">open</span> ListM <span class="kw">in</span>
  <span class="kw">if</span> predicate x <span class="kw">then</span> pure x <span class="kw">else</span> []</code></pre></div>
<p>L’idée générale derrière cette fonction est très proche de <code class="sourceCode ocaml" rundoc-language="ocaml">safe_div</code>. Si le prédicat est respecté, on garde l’élément, sinon on le supprime. On peut maintenant implémenter plusieurs types de compréhensions différentes :</p>
<h3 id="x-2-x-in-1-2-3"><span class="math inline">{ <em>x</em> * 2 | <em>x</em> ∈ [1, 2, 3] }</span></h3>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">[<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] &gt;&gt;= (<span class="kw">fun</span> x -&gt; [x * <span class="dv">2</span>])</code></pre></div>
<h3 id="x-2-x-in-1-2-3-1-x"><span class="math inline">{ <em>x</em> * 2 | <em>x</em> ∈ [1, 2, 3], 1 &lt; <em>x</em> }</span></h3>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">[<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] &gt;&gt;= keep_if ((&lt;) <span class="dv">1</span>) &gt;&gt;= (<span class="kw">fun</span> x -&gt; [x * <span class="dv">2</span>])</code></pre></div>
<h3 id="promotion-de-fonctions">Promotion de fonctions</h3>
<p>On a remarqué que l’opérateur que l’on utilise le plus souvent est <code class="sourceCode ocaml" rundoc-language="ocaml">&gt;&gt;=</code>. Cependant, pour chainer facilement les étapes d’un calcul, la fonction qu’il prend en argument est de type <code class="sourceCode ocaml" rundoc-language="ocaml">('a -&gt; 'b t)</code>. Ça pourrait être ennuyeux, par exemple, quand on travaille avec le type <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">int</span> <span class="dt">option</span></code>, que l’ensemble des opérations/fonctions liées au type <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">int</span></code> doit être emballé. Par exemple, la fonction <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">succ</span></code>, qui pour un entier, renvoie son successeur : <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="kw">fun</span> x -&gt; <span class="dt">Some</span> (<span class="dt">succ</span> x)</code>.</p>
<p>Pour pallier à ce souci, on peut utiliser des fonctions qui promotent des fonctions pour être utilisables avec l’opérateur <code class="sourceCode ocaml" rundoc-language="ocaml">&gt;&gt;=</code>. On en a déjà survolé une, c’est la fonction <code class="sourceCode ocaml" rundoc-language="ocaml">map</code>. Elle permet de promouvoir une fonction à un seul argument en une fonction qui renvoie une monade. De ce fait, plutôt que d’écrire :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">(<span class="dt">Some</span> <span class="dv">10</span>) &gt;&gt;= (<span class="kw">fun</span> x -&gt; <span class="dt">Some</span> (<span class="dt">succ</span> x))</code></pre></div>
<p>Nous aurions pu écrire :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">(<span class="dt">Some</span> <span class="dv">10</span>) |&gt; map <span class="dt">succ</span></code></pre></div>
<p>Le fait de promouvoir une fonction pour être utilisable dans un contexte monadique s’appelle le <em>lifting</em>. On peut implémenter autant de fonctions que l’on veut pour des fonctions à plusieurs arguments :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(* Exactement pareil que map *)</span>
<span class="kw">val</span> liftM : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t
<span class="kw">let</span> liftM f x = x &gt;&gt;= (<span class="kw">fun</span> a -&gt; pure (f a))

<span class="co">(* Pour les fonctions à deux paramètres *)</span>
<span class="kw">val</span> liftM2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a t -&gt; 'b t -&gt; 'c t
<span class="kw">let</span> liftM2 f x y =
  x &gt;&gt;= <span class="kw">fun</span> a -&gt;
  y &gt;&gt;= <span class="kw">fun</span> b -&gt; pure (f a b)

<span class="co">(* Pour les fonctions à trois paramètres *)</span>
<span class="kw">val</span> liftM3 :
  ('a -&gt; 'b -&gt; 'c -&gt; 'd) -&gt; 'a t -&gt; 'b t -&gt; 'c t
  -&gt; 'd t
<span class="kw">let</span> liftM3 f x y =
  x &gt;&gt;= <span class="kw">fun</span> a -&gt;
  y &gt;&gt;= <span class="kw">fun</span> b -&gt;
  z &gt;&gt;= <span class="kw">fun</span> c -&gt; pure (f a b c)

<span class="co">(* Etc ...*)</span></code></pre></div>
<p>En général, les bibliothèques (par exemple celles de Haskell) vont jusqu’à 5. Maintenant, on peut facilement faire des opérations sur des monades, via les fonctions reliées aux types qui les habitent. Par exemple :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">liftM2 (+) (<span class="dt">Some</span> <span class="dv">10</span>) (<span class="dt">Some</span> <span class="dv">11</span>)</code></pre></div>
<p>Qui donnera le résultat <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">Some</span> <span class="dv">21</span></code>.</p>
<h3 id="pour-conclure-sur-lutilisation-des-deux-monades">Pour conclure sur l’utilisation des deux monades</h3>
<p>Nous avons survolé quelques cas d’école liés à ces deux monades. Cette partie de l’article peut être assez touffue (et peut être compliquée) pour les lecteurs non initiés. Dans la section suivante, nous tâcherons de revenir sur les caractéristiques fondamentales des monades au moyen de métaphores. L’objectif sera de clarifier l’usage concret de ces deux monades au travers des bouts de définitions que nous avions évoqués auparavant.</p>
<h2 id="clarifications-et-métaphores">Clarifications et métaphores</h2>
<p>Si j’ai pris la décision de proposer deux monades différentes pour observer des premières utilisations, c’est principalement pour renforcer une phrase que j’avais évoquée précédemment :</p>
<blockquote>
<p>Elle permet d’exprimer plusieurs <strong>types de constructions</strong> pour une <strong>même structure</strong>.</p>
</blockquote>
<p>Dans les exemples précédents, on a pu observer que pour une interface commune, sur des types différents, on effectue des <strong>constructions différentes</strong>. Il arrive parfois que l’on trouve des analogies entre les monades et les motifs de conceptions, je trouve cette analogie très discutable parce qu’à mon sens, l’objectif premier d’un motif de conception est de répondre à un problème de conception logicielle. Les monades, elles, répondent, de manière unifiée, à plusieurs problèmes de conception logicielle. Je trouve ça très différent.</p>
<p>Concrètement, le fait que les monades résolvent plusieurs problèmes implique qu’il peut être difficile de les raisonner comme un tout. Je pense que l’enjeu d’un programmeur qui est amené à se servir de monades doit avant tout comprendre “<em>qu’est-ce-que résout spécifiquement la monade qu’il</em> <em>utilise</em>”.</p>
<p>Par exemple, la monade <code class="sourceCode ocaml" rundoc-language="ocaml">Option</code> permet d’ajouter un contexte d’échec (ou d’absence) à une valeur. Alors que la monade <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">List</span></code> permet de construire une nouvelle liste via une fonction.</p>
<p>Dans la littérature, on trouve souvent deux analogies. Les monades <a href="https://wiki.haskell.org/Monads_as_containers">vues comme des <em>containers</em></a> ou <a href="https://wiki.haskell.org/Monads_as_computation">vues comme des calculs</a>. Bien sûr, ces deux analogies ne s’excluent pas mutuellement. On peut parfaitement imaginer qu’<code class="sourceCode ocaml" rundoc-language="ocaml">Option</code> est un <em>container</em> mais permet aussi d’être évaluée comme un calcul.</p>
<h3 id="les-monades-vues-comme-des-containers">Les monades vues comme des <em>containers</em></h3>
<p>Généralement, la métaphore des <em>containers</em> s’exprime plus facilement avec la première interface (celle qui utilise <code class="sourceCode ocaml" rundoc-language="ocaml">map</code> et <code class="sourceCode ocaml" rundoc-language="ocaml">join</code>). On peut facilement imaginer qu’une monade est une boite. Que la fonction <code class="sourceCode ocaml" rundoc-language="ocaml">map</code> prend la valeur contenue dans la boite, lui applique une fonction et la remet dans une boite. Et la fonction <code class="sourceCode ocaml" rundoc-language="ocaml">join</code> prend une boite dans laquelle se trouve une boite, prend cette dernière boite, prend tout son contenu et le met dans la première boite. En général, l’explication de <code class="sourceCode ocaml" rundoc-language="ocaml">&gt;&gt;=</code> n’est que la combinaison de <code class="sourceCode ocaml" rundoc-language="ocaml">map</code> et <code class="sourceCode ocaml" rundoc-language="ocaml">join</code>.<br />
Dans le cas des listes, je trouve qu’utiliser la première interface est plus simple, et que ça insiste implicitement sur l’aspect <strong>non-déterministe</strong> que peut offrir <code class="sourceCode ocaml" rundoc-language="ocaml">&gt;&gt;=</code>. En effet, l’opérateur se contente de <em>mapper</em>, et ensuite de <em>joindre</em>, de ce fait, il est possible de “supprimer des valeurs” dans la liste, au contraire de l’usage de la fonction <code class="sourceCode ocaml" rundoc-language="ocaml">map</code> seul, mais aussi d’en ajouter. Imaginons par exemple cette fonction, discutablement utile, qui va, pour chaque élément d’une liste d’entiers se comporter ainsi :</p>
<ul>
<li>si le nombre est nul, il est enlevé ;</li>
<li>si le nombre est pair, il est dupliqué ;</li>
<li>si le nombre est impair, il est conservé.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> f my_integer_list =
  my_integer_list
  &gt;&gt;= (<span class="kw">fun</span> x -&gt;
      <span class="kw">if</span> x = <span class="dv">0</span> <span class="kw">then</span> []
      <span class="kw">else</span> <span class="kw">if</span> x <span class="kw">mod</span> <span class="dv">2</span> = <span class="dv">0</span> <span class="kw">then</span> [x; x]
      <span class="kw">else</span> [x]
    )

<span class="kw">let</span> value = f [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">0</span>; <span class="dv">4</span>; <span class="dv">3</span>]
<span class="co">(* int list = [1; 2; 2; 4; 4; 3] *)</span></code></pre></div>
<p>C’est grâce à cet aspect non-déterministe qu’il est possible, relativement facilement, d’encoder des <em>compréhensions</em> avec la monade <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">List</span></code>.</p>
<h3 id="les-monades-vues-comme-des-calculs">Les monades vues comme des calculs</h3>
<p>Dans la première métaphore, on se concentrait sur <strong>le type</strong> habitant de la monade, cette métaphore, complémentaire à la précédente se focalise sur l’opérateur <code class="sourceCode ocaml" rundoc-language="ocaml">&gt;&gt;=</code> et la relation qu’il permet de construire entre plusieurs instances d’une même monade.</p>
<p>L’idée fondamentale derrière cette approche est de ne pas <em>réellement</em> s’intéresser au contenu de “la boite” (d’où sa complémentarité avec la métaphore précédente) mais de s’intéresser à la composition, via l’opérateur <code class="sourceCode ocaml" rundoc-language="ocaml">&gt;&gt;=</code>, ce qui fait que la projection via la seconde interface (celle où l’on implémente src<sub>&gt;&gt;=</sub>, logique) semble plus facile.</p>
<p>En plus de permettre de <strong>chainer</strong> des séquences de calcul (ce qui pourrait potentiellement rappeler une manière idiomatique de transformer des données dans la programmation impérative), cela permet parfois d’encoder des calculs moins standards dans le langage. Par exemple, les <strong>effets de bord</strong> dans un langage de programmation fonctionnel pur (comme la monade <code class="sourceCode ocaml" rundoc-language="ocaml">IO</code> en Haskell), des <strong>constructions asynchrones</strong> (dans des langages autres que JavaScript), ou encore des <strong>continuations</strong> et des <strong>reprises</strong>.</p>
<p><strong>Railway oriented programming</strong></p>
<p>La métaphore du calcul permet parfois de se représenter une séquence de calcul monadique comme des <a href="https://vimeo.com/97344498">rails de train</a> (je recommande d’ailleurs cette vidéo qui est très claire et très pédagogique). On peut ressentir cette métaphore dans l’usage de la monade <code class="sourceCode ocaml" rundoc-language="ocaml">Option</code>. Tant que l’on possède une valeur, <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">Some</span> 'a</code>, on continue les calculs, dès que l’on a <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">None</span></code>, on termine le calcul. Une autre monade permettant d’encoder des <strong>exceptions</strong> est aussi un bon candidat à l’analogie des rails de train.</p>
<h2 id="la-monade-state">La monade <code class="sourceCode ocaml" rundoc-language="ocaml">State</code></h2>
<p>Il arrive souvent qu’un module monadique expose plus de fonctions que celles présentées dans l’interface générale. C’est le cas, par exemple, de la monade <code class="sourceCode ocaml" rundoc-language="ocaml">State</code>.</p>
<p>En parlant de métaphores, nous avions évoqué l’idée que certaines monades encodaient des opérations non-standards dans un langage. Dans un langage fonctionnel pur, les variables sont <strong>immuables</strong>. Cependant, OCaml est un langage fonctionnel impur, qui offre des mécaniques de programmation impérative. On peut donc, entre autre, écrire des cellules de références, qui sont des constructions <strong>mutables</strong>. En général, quand on parle de constructions mutables, on attend, pour un état, les opérations de <strong>lecture</strong> et d’<strong>écriture</strong>.</p>
<p>La monade <code class="sourceCode ocaml" rundoc-language="ocaml">State</code> permet de mimer ce comportement dans un langage fonctionnel pur.</p>
<p>Concrètement, un état dans la monade <code class="sourceCode ocaml" rundoc-language="ocaml">State</code> est une abstraction sur une fonction qui prend un état “courant” et retourne un couple constitué d’une valeur de retour intermédiaire et d’un nouvel état. En plus des combinateurs classiques, on peut étendre le module avec quelques fonctions utiles :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">module</span> State (S : <span class="kw">sig</span> <span class="kw">type</span> t <span class="kw">end</span>) :
<span class="kw">sig</span>
  <span class="kw">type</span> state = S.t
  <span class="kw">include</span> MONAD <span class="kw">with</span> <span class="kw">type</span> 'a t = (state -&gt; 'a * state)
  <span class="kw">val</span> get : state t
  <span class="kw">val</span> put : state -&gt; <span class="dt">unit</span> t
  <span class="kw">val</span> eval : 'a t -&gt; state -&gt; 'a
  <span class="kw">val</span> exec : 'a t -&gt; state -&gt; state
  <span class="kw">val</span> run : 'a t -&gt; state -&gt; ('a * state)
<span class="kw">end</span></code></pre></div>
<blockquote>
<p><strong>NB:</strong> Normalement, le type de la monade est, ici, défini par deux paramètres, cependant, pour être raccord avec l’interface <code class="sourceCode ocaml" rundoc-language="OCAML">MONAD</code> que nous avions défini précédemment, je paramètre le module par un autre module qui fixe le type de l’état, laissant la valeur polymorphique pour le résultat intermédiaire.</p>
<p>De ce fait, on peut créer un module <code class="sourceCode ocaml" rundoc-language="ocaml">Count</code> qui sera une spécialisation du module <code class="sourceCode ocaml" rundoc-language="ocaml">State</code> pour les entiers :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">module</span> Count = State(<span class="kw">struct</span> <span class="kw">type</span> t = <span class="dt">int</span> <span class="kw">end</span>)</code></pre></div>
</blockquote>
<p>Comme on peut le voir dans la signature de notre module, le type de la monade <code class="sourceCode ocaml" rundoc-language="ocaml">State</code> n’est rien de plus qu’une fonction <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="kw">type</span> 'a t = state -&gt; 'a * state</code>. Pour des raisons de commodité, lorsque l’on parlera de <code class="sourceCode ocaml" rundoc-language="ocaml">'a</code>, on utilisera le terme <strong>résultat</strong> et lorsque l’on parlera du <code class="sourceCode ocaml" rundoc-language="ocaml">state</code> à gauche de la flèche, on parlera de <strong>l’état courant</strong> et pour le <code class="sourceCode ocaml" rundoc-language="ocaml">state</code> à droite de la flèche on parlera de <strong>nouvel état</strong>.</p>
<p>Définissons les objectifs des fonctions auxiliaires. La fonction <code class="sourceCode ocaml" rundoc-language="ocaml">get</code> considère que l’état courant devient le résultat du calcul. La fonction <code class="sourceCode ocaml" rundoc-language="ocaml">put</code> prend l’état, lui applique une fonction qui construira un nouvel état. En général, cette fonction est <em>stateful</em>, elle exécute potentiellement un effet, donc le résultat intermédiaire devient <em>unit</em>.</p>
<p>Les trois dernières fonctions, <code class="sourceCode ocaml" rundoc-language="ocaml">run</code>, <code class="sourceCode ocaml" rundoc-language="ocaml">eval</code> et <code class="sourceCode ocaml" rundoc-language="ocaml">exec</code> permettent d’exécuter une monade d’état. <code class="sourceCode ocaml" rundoc-language="ocaml">run</code> renverra le couple de la valeur intermédiaire et de l’état, <code class="sourceCode ocaml" rundoc-language="ocaml">eval</code> ne renverra que le résultat intermédiaire et <code class="sourceCode ocaml" rundoc-language="ocaml">exec</code> ne renverra que le dernier état. Chacune de ces fonctions prend un état initial, qui correspondra à la première valeur du calcul.</p>
<p>Voici comment implémenter la monade <code class="sourceCode ocaml" rundoc-language="ocaml">State</code> :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">module</span> State (S : <span class="kw">sig</span> <span class="kw">type</span> t <span class="kw">end</span>) :
<span class="kw">sig</span>
  <span class="kw">type</span> state = S.t
  <span class="kw">include</span> MONAD <span class="kw">with</span> <span class="kw">type</span> 'a t = (state -&gt; 'a * state)
  <span class="kw">val</span> get : state t
  <span class="kw">val</span> put : state -&gt; <span class="dt">unit</span> t
  <span class="kw">val</span> eval : 'a t -&gt; state -&gt; 'a
  <span class="kw">val</span> exec : 'a t -&gt; state -&gt; state
  <span class="kw">val</span> run : 'a t -&gt; state -&gt; ('a * state)
<span class="kw">end</span> = <span class="kw">struct</span>

  <span class="kw">type</span> state = S.t
  <span class="kw">include</span> With_bind(
    <span class="kw">struct</span>
      <span class="kw">type</span> 'a t = (state -&gt; 'a * state)
      <span class="kw">let</span> pure x = (<span class="kw">fun</span> state -&gt; (x, state))
      <span class="kw">let</span> (&gt;&gt;=) h f =
        (<span class="kw">fun</span> state -&gt;
            <span class="kw">let</span> (x, new_state) = h state <span class="kw">in</span>
            <span class="kw">let</span> g = f x <span class="kw">in</span>
            g new_state
          )
    <span class="kw">end</span>)

  <span class="kw">let</span> get = (<span class="kw">fun</span> state -&gt; (state, state))
  <span class="kw">let</span> put state = (<span class="kw">fun</span> _ -&gt; ((), state))
  <span class="kw">let</span> run f init = f init
  <span class="kw">let</span> eval f state = <span class="dt">fst</span> (f state)
  <span class="kw">let</span> exec f state = <span class="dt">snd</span> (f state)
<span class="kw">end</span></code></pre></div>
<p>Voici quelques exemples de son utilisation :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">run (pure <span class="dv">0</span>) <span class="dv">1</span></code></pre></div>
<p>Dans ce premier exemple, rien d’extraordinaire. On exécute simplement l’instruction d’initialisation, mais en démarrant l’état à 1. L’état courant sera donc égal à <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dv">1</span></code> mais la valeur intermédiaire, auquel on n’a absolument pas touché sera égale à <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dv">0</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">run (
  pure <span class="dv">0</span>
  &gt;&gt;= <span class="kw">fun</span> index -&gt; put (index + <span class="dv">1</span>)
  &gt;&gt;= <span class="kw">fun</span> () -&gt;
  get
) <span class="dv">1</span></code></pre></div>
<p>Ici, on incrémente l’état courant et on associe l’état courant à la valeur de retour intermédiaire. Le résultat final sera donc le couple <code class="sourceCode ocaml" rundoc-language="ocaml">(<span class="dv">1</span>, <span class="dv">1</span>)</code>. Le motif <code class="sourceCode ocaml" rundoc-language="ocaml">put + get</code> est récurrent, il correspond à la modification de l’état, le passage de l’état courant en valeur intermédiaire.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml">run (
  pure <span class="dv">0</span>
  &gt;&gt;= <span class="kw">fun</span> index -&gt; put (index + <span class="dv">1</span>)
  &gt;&gt;= <span class="kw">fun</span> () -&gt; get
  &gt;&gt;= <span class="kw">fun</span> index -&gt; put (index + <span class="dv">1</span>)
  &gt;&gt;= <span class="kw">fun</span> () -&gt; get
  &gt;&gt;= <span class="kw">fun</span> index -&gt; put (index + <span class="dv">1</span>)
  &gt;&gt;= <span class="kw">fun</span> () -&gt; get
  &gt;&gt;= <span class="kw">fun</span> index -&gt;
  pure (<span class="dt">Format</span>.sprintf <span class="st">&quot;Je vaux %d --&gt;&quot;</span> index)
) <span class="dv">0</span></code></pre></div>
<p>Ce dernier exemple est très similaire au précédent, sauf que tout à la fin, on substitue la valeur de retour intermédiaire par une chaine de caractères construite sur la base de l’état courant.</p>
<p>Avec la monade <code class="sourceCode ocaml" rundoc-language="ocaml">State</code>, on peut désormais mimer le comportement des langages impératifs en construisant des états que l’on pourra modifier. Il faut retenir qu’elle ne fait qu’encapsuler une fonction. De ce fait, une fois que l’état est construit, et ça peut avoir lieu en plusieurs étapes, il faut exécuter la séquence de calcul pour restituer l’état final. Concrètement, elle permet d’encoder une construction non-standard dans un langage souche.</p>
<p>J’ai choisi de présenter <code class="sourceCode ocaml" rundoc-language="ocaml">State</code> parce qu’elle est, à mon sens, assez facile à appréhender. Cependant, il existe des monades, “plus complexes pour une initiation”, qui encodent des constructions plus complexes, par exemple, <a href="http://www.haskellforall.com/2012/12/the-continuation-monad.html">Continuation</a> (qui sur beaucoup d’aspects, ressemble un peu aux <strong>Promesses</strong> de JavaScript), qui au lieu de renvoyer une valeur, passe le résultat d’une étape à une autre étape.</p>
<h2 id="apports-réels-des-monades-à-lusage">Apports réels des monades à l’usage</h2>
<p>Bien que l’on ait évoqué la possibilité de mettre en oeuvre des constructions non standard, on pourrait s’en passer. Par exemple, plutôt qu’utiliser une monade d’état, on pourrait, sans se soucier des propriétés des monades, utiliser “simplement” un argument complémentaire à une fonction qui, à chaque itération de la fonction, ferait office d’accumulateur de résultat, et définir chaque étape intermédiaire (ne provoquant pas d’itération) dans des variables différentes. De plus, comme nous avons vu que les monades offrent une interface commune pour beaucoup de problèmes <strong>différents</strong>, il faut tout de même comprendre son intérêt (et le rôle de <code class="sourceCode ocaml" rundoc-language="ocaml">&gt;&gt;=</code>) pour chaque monade différente.</p>
<p>Les monades ne servent pas qu’à augmenter son “jargon de programmeur”. Elles offrent, selon moi, trois axes. Les deux premiers sont liés à la monade en tant qu’interface générale, le troisième est lié à l’usage de certains langages qui favorisent l’utilisation de monades.</p>
<h3 id="de-la-structure">De la structure</h3>
<p>Le premier apport lié à l’usage des monades est qu’elles offrent une manière <strong>systèmatique</strong> de structurer un programme en deux parties bien distinctes :</p>
<ul>
<li>l’algorithme à proprement parler ;</li>
<li>l’outillage nécessaire à cet algorithme (par exemple un état). Et cet outillage peut être masqué dans des bibliothèques (potentiellement réutilisables).</li>
</ul>
<p>De plus, elles permettent aussi de rendre explicite le flot d’un programme, d’une manière assez uniforme. Car même si, comme on l’a vu, le rôle de chaque monade diffère, le fait de partager une interface commune donne tout de même de bonnes informations sur le comportement général du calcul, de manière abstraite. Les monades amènent une notion de <strong>composition</strong> élégante et uniforme.</p>
<h3 id="de-la-réutilisabilité">De la réutilisabilité</h3>
<p>Même si dans les exemples précédents, nous n’avons utilisé que des versions minimales de nos monades, en utilisant une interface (volontairement) limitée, les monades exposent <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Monad.html">un grand nombre de fonctions complémentaires</a>. Ces fonctions ne nécessitent généralement que les fonctions exposées par notre interface minimaliste pour être implémentées, de ce fait, n’implémenter que 2 ou 3 fonctions peut suffire à construire une interface riche, et ce pour toutes les monades. Par exemple, les fonctions de promotion (<em>lifting</em>) que nous avons évoquées précédemment sont génériques et ne peuvent être implémentées qu’une seule fois et être offertes par le module paramétré qui construit une monade.</p>
<p>La capacité à paramétrer une monade (via un module en OCaml, une classe de type en Haskell ou de l’héritage en programmation Orientée objets) est possible grâce au respect des lois monadiques.</p>
<p>En tant que développeur, on n’est bien plus souvent amené à “utiliser des monades” existantes qu’à en “découvrir”. Généralement, la preuve minimale que l’on peut apporter à la découverte d’une monade est le respect des lois monadiques sur l’interface que l’on choisi d’implémenter.</p>
<h2 id="syntaxes-et-notations">Syntaxes et notations</h2>
<p>Bien que les opérateurs et fonctions exposés par les monades permettent de se représenter assez simplement les séquences de calcul, certains langages ont fait le choix de mettre en place des extensions de syntaxes pour offrir une notation plus commode pour le traitement des monades.</p>
<p>Haskell a choisi de mettre en place la <strong>do-notation</strong>. Par exemple, on écrira :</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">cartesian_product ::</span> [(<span class="dt">String</span>, <span class="dt">Int</span>)]
cartesian_product <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> [<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;foobar&quot;</span>]
  y <span class="ot">&lt;-</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">9</span>]
  return (x, y)</code></pre></div>
<p>Plutôt que :</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">cartesian_product ::</span> [(<span class="dt">String</span>, <span class="dt">Int</span>)]
cartesian_product <span class="fu">=</span>
  [<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;foobar&quot;</span>]
  <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">9</span>]
  <span class="fu">&gt;&gt;=</span> \y <span class="ot">-&gt;</span> return (x, y)</code></pre></div>
<p>L’avantage de cette notation est qu’elle permet d’appréhender certains concepts (comme par exemple la lecture/écriture de fichiers) sans se soucier de la notion de monade.</p>
<p>Pour ma part, j’aime beaucoup le choix qu’a fait F#, ils offrent une <a href="https://docs.microsoft.com/fr-fr/dotnet/fsharp/language-reference/computation-expressions">syntaxe alternative</a> qui permet de généraliser l’écriture de <em>workflows</em> monadiques, mais pas <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/computation-zoo.pdf">uniquement</a>. C’est d’ailleurs sur la base de ces constructeurs d’expressions que reposent leurs <em>workflows</em> asynchrones et leurs <em>workflows</em> de requêtage SQL.</p>
<p>Scala, que je ne connais pas très bien, expose aussi <a href="https://docs.scala-lang.org/tutorials/FAQ/yield.html">une syntaxe</a>, qui repose sur celle des compréhensions.</p>
<p>OCaml, actuellement, délègue à une <a href="https://github.com/janestreet/ppx_let">extension de syntaxe externe</a> l’alternative pour écrire de manière commode des <em>workflows</em> monadiques, cependant, <a href="https://github.com/ocaml/ocaml/pull/1947">des conversations ont actuellement lieu</a> pour aboutir à une généralisation proche de celle de F#.</p>
<h2 id="pour-conclure-enfin">Pour conclure, enfin</h2>
<p>Je décide de terminer, ici, cette naïve introduction aux monades ! Ce que l’on va retenir, c’est qu’une monade est un type équipé de deux (ou trois en fonction de l’interface choisie) opérations qui permet de respecter une interface commune de programmation pour solutionner divers problèmes.</p>
<p>Elles permettent plusieurs choses :</p>
<ul>
<li>la réutilisation de code (et la construction de bibliothèques génériques) ;</li>
<li>l’introduction dans un langage de construction non-standards ;</li>
<li>la séparation entre l’algorithme et son outillage alternatif ;</li>
<li>d’ordonner/séquencer des effets (je n’ai pas réellement évoqué cette partie qui fera surement l’objet d’un prochain article) ;</li>
<li>de briller dans les salons !</li>
</ul>
<p>Au-delà des apports concrets, les monades ont aussi été la source d’inspiration de certaines pratiques/outils dans des langages plus <em>mainstream</em>, par exemple pour l’implémentation de <strong>LINQ</strong>, dans le monde .NET ou comme base de raisonnement pour les Promesses en JavaScript.</p>
<p>En plus des apports concrets et indirects, je pense que les monades sont une première étape “souple” à franchir pour s’initier à une étude “un peu plus théorique” des langages de programmation tout en offrant des avantages indéniables, liés, entre autres, à la composition. Bref, la monade est une abstraction puissante.</p>
<p>Il reste encore beaucoup de sujets à couvrir, par exemple, les transformations de monades, pour coupler des monades. Cependant, pour que l’article ne soit pas trop indigeste, j’arrête maintenant. (Mais ce seront, aussi, sûrement des sujets couverts par les prochains articles !)</p>
<p>J’espère que cet article aura été potentiellement utile pour quelqu’un. Merci pour votre lecture et à bientôt !</p>
<blockquote>
<p><strong>NB… FINAL:</strong> Si vous voyez des coquilles, vous trouverez, entre les notes et les commentaires, un lien vers les sources du blog, et donc de cet article, n’hésitez pas à faire une PR ou à écrire un commentaire !</p>
</blockquote>
<p>Je remercie grandement Anne-Charlotte et Jules pour avoir relu (et fait remonter) pleins de petites coquilles !</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Ce n’est pas une moquerie ou une critique, même si le ton est un peu sarcastique, je comprends évidemment ce genre de raccourci.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
  <div id="eof-article"></div>
  <div class="article-footer">
    Cet article est terminé ! <br /> Si jamais vous avez des remarques, n'hésitez pas à écrire un <strong>commentaire</strong> ou à <a href="https://github.com/xvw/blog">contribuer</a>
    <div id="disqus_thread"></div>
    <script>
      var disqus_config = function () {
      this.page.url = "https://xvw.github.io/posts/monad.html";
      this.page.identifier = "posts/monad.org";
      };
      (function() { // DON'T EDIT BELOW THIS LINE
        var d = document,
          s = d.createElement('script');
        s.src = 'https://xvw-blog-1.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</main>
<script src="../js/hl.js"></script>
<script>
  hljs.initHighlightingOnLoad();
  __useResumable("/posts/monad.html");
</script>

  <footer>
    <div>
      <div>
        <a href="http://webring.xxiivv.com/#random" target="_blank">
          <img src="../images/icon.white.svg" />
        </a>
      </div>
      <div>
        <span>Merci</span>
        <a href="https://jaspervdj.be/hakyll/">Hakyll</a>
        <span>, tu es un superbe générateur ❤</span>
      </div>
    </div>
  </footer>
</body>

</html>
