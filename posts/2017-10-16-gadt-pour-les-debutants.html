<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
	<link href="https://fonts.googleapis.com/css?family=Lora:400,400i,700,700i|Playfair+Display:400,700,900|Fira+Mono" rel="stylesheet">
        <link rel="stylesheet" href="../css/default.css" />
        <title>xvw - Un cas d'école à l'utilisation des GADTs</title>
    </head>

    <body>
	<main class="article">
    <a href="../index.html">Revenir à l'accueil</a>
    <h1 class="main-title">Un cas d'école à l'utilisation des GADTs</h1>
    <div class="date">Publié le 16 du 10 2017</div>
    <blockquote>
<p>Cet article fait écho à un <strong>tweet</strong> <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> et à une conversation que nous avons eu sur le Slack de <strong>LilleFP</strong>. L’article propose de survoler un cas d’école de l’usage des types algébriques généralisés (<strong>GADTs</strong>) avec le langage <strong>OCaml<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></strong> qui a l’avantage d’avoir une syntaxe concise est relativement claire.</p>
<p>L’objectif de l’article est avant tout de donner un exemple claire de l’utilisation des <em>GADTs</em>, sans rentrer dans des considérations théoriques complexex (en plus je n’en ai pas les compétences), et de fournir une définition <em>naïve</em> de ce qu’ils sont, par rapport à des types algébriques <em>classiques</em>. A la fin de l’article, on parlera un peu des langages <strong>orientés objets</strong>, de leur manière de représenter des <em>types sommes</em> et de pourquoi il ne s’agit pas réellement de GADTs en donnant une définition un peu plus fine que lors de la première partie de l’article.</p>
<p>Une connaissance d’un langage de la famille <strong>ML</strong> est préférable pour la lecture de cet article.</p>
</blockquote>
<p>Dans le monde des langages de programmation statiquement typés, on veille à toujours tâcher de <em>typer</em> correctement nos données pour que le compilateur puisse vérifier la cohérence d’un programme à la compilation, nous déchargeant ainsi d’un lourd travail de vérification. Dans les langages de la famille ML, on a, à notre disposition, les <strong>types de données algébriques</strong> (ADT<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>), qui, couplé à la récursivité, permettent d’exprimer, de manière assez élégante, des structures de données diverses.</p>
<p>En OCaml, on possède deux formes d’<em>ADTs</em> :</p>
<ul>
<li><strong>les types produits</strong> : les <em>n-uplets</em> et les <em>enregistrements</em> par exemple ;</li>
<li><strong>les types sommes</strong> : que l’on peut aussi appeler <em>types variants</em> ou <em>unions discriminées</em>.</li>
</ul>
<p>Dans cet article, on va surtout s’intéresser aux types sommes. Cependant, n’hésitez pas, pour plus d’informations, à lire cet excellent tutoriel<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> qui survole une grande partie du langage OCaml.</p>
<h1 id="rappel-sur-les-types-sommes">Rappel sur les types sommes</h1>
<p>Les types sommes permettent d’unifier plusieurs types de données au sein d’un même type au moyen de <strong>constructeurs</strong>. Par exemple :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> color = 
 | Red   
 | Blue  
 | Green 

<span class="kw">let</span> a_color = Red 
<span class="kw">let</span> a_color_list = [Red; Green; Blue]</code></pre></div>
<p>Dans cet exemple, la variable <code class="sourceCode ocaml" rundoc-language="ocaml">red</code> aura le type <code class="sourceCode ocaml" rundoc-language="ocaml">color</code> et la variable <code class="sourceCode ocaml" rundoc-language="ocaml">a_color_list</code> aura le type <code class="sourceCode ocaml" rundoc-language="ocaml">color <span class="dt">list</span></code>.</p>
<p>Il est important de préciser que les constructeurs ne sont <strong>pas</strong> des sous-types, ce sont des valeurs qui <strong>appartiennent</strong> au type <code class="sourceCode ocaml" rundoc-language="ocaml">color</code>.</p>
<h2 id="notre-propre-type-pour-les-listes">Notre propre type pour les listes</h2>
<p>Grâce aux types sommes, il est possible de construire facilement, au moyen de types récursifs, des structures de données communes. Par exemple, une liste :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> 'a my_list = 
  | Empty
  | Cons <span class="kw">of</span> ('a * 'a my_list)

<span class="kw">let</span> a_list = Cons (Red, Cons (Blue, Cons (Green, Empty)))</code></pre></div>
<p>Ici, <code class="sourceCode ocaml" rundoc-language="ocaml">a_list</code> aura le type <code class="sourceCode ocaml" rundoc-language="ocaml">color my_list</code>. Les variants sont des outils agréable à utiliser pour unir des valeurs (via des constructeurs) dans un même type. De plus, ils s’utilisent très bien avec <strong>la correspondance de motifs</strong>. Par exemple, voyons comment implémenter la fonction <strong>iterate</strong> pour notre nouveau type liste, dont le type serait :</p>
<p><code class="sourceCode ocaml" rundoc-language="ocaml"><span class="kw">val</span> iterate : ('a -&gt; <span class="dt">unit</span>) -&gt; 'a my_list -&gt; <span class="dt">unit</span></code></p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> <span class="kw">rec</span> iterate f <span class="dt">list</span> = 
  <span class="kw">match</span> <span class="dt">list</span> <span class="kw">with</span> 
  | Empty -&gt; ()          
  | Cons (head, tail) -&gt; 
     <span class="kw">let</span> () = f head <span class="kw">in</span> 
     iterate f tail           </code></pre></div>
<h2 id="implémentation-de-head-et-tail">Implémentation de <em>head</em> et <em>tail</em></h2>
<p>Comme nous le montre notre type et notre fonction <code class="sourceCode ocaml" rundoc-language="ocaml">iterate</code>, il est commun et pratique de caractériser une liste par une <strong>tête</strong> et une <strong>queue</strong>. Dans une valeur de type <code class="sourceCode ocaml" rundoc-language="ocaml">'a my_list</code>, la tête aura le type <code class="sourceCode ocaml" rundoc-language="ocaml">'a</code> et la queue aura le type <code class="sourceCode ocaml" rundoc-language="ocaml">'a my_list</code>. Voyons tout de suite comment implémenter ces fonctions.</p>
<h3 id="traiter-le-cas-des-listes-vides">Traiter le cas des listes vides</h3>
<p>L’implémentation de ces deux fonctions est simple, cependant, que doit-on faire quand on essaye d’avoir la tête ou la queue pour <strong>une liste vide</strong> ? Une approche <em>classique</em> serait de faire comme beaucoup de langages font pour traiter un cas <strong>exceptionnel</strong>, en lançant une exception :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">exception</span> Empty_list <span class="kw">of</span> <span class="dt">string</span>

<span class="kw">let</span> head <span class="dt">list</span> = 
  <span class="kw">match</span> <span class="dt">list</span> <span class="kw">with</span> 
  | Empty -&gt; <span class="dt">raise</span> (Empty_list <span class="st">&quot;head&quot;</span>) 
  | Cons (head, _) -&gt; head                        

<span class="kw">let</span> tail <span class="dt">list</span> = 
  <span class="kw">match</span> <span class="dt">list</span> <span class="kw">with</span> 
  | Empty -&gt; <span class="dt">raise</span> (Empty_list <span class="st">&quot;tail&quot;</span>) 
  | Cons (_, tail) -&gt; tail
</code></pre></div>
<p>Cette approche fonctionne, et c’est d’ailleurs le choix qui a été fait pour la bibliothèque standard de OCaml<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>. D’autres langages, comme <strong>Elm<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a></strong> ont fait le choix de changer le type <em>habituel</em> de <code class="sourceCode ocaml" rundoc-language="ocaml">head</code> et <code class="sourceCode ocaml" rundoc-language="ocaml">tail</code> pour emballer le résultat de la fonction dans une <strong>option</strong>. De cette manière, le type des deux fonctions indique directement qu’il faut traiter, <em>à la main</em>, le cas des listes vides et comme Elm interdit une correspondance de motifs non-exhaustive, on est sur, après la compilation, qu’on aura traité les cas où une liste est vide.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> head <span class="dt">list</span> = 
  <span class="kw">match</span> <span class="dt">list</span> <span class="kw">with</span> 
  | Empty -&gt; <span class="dt">None</span>
  | Cons (head, _) -&gt; <span class="dt">Some</span> head                        

<span class="kw">let</span> tail <span class="dt">list</span> = 
  <span class="kw">match</span> <span class="dt">list</span> <span class="kw">with</span> 
  | Empty -&gt; <span class="dt">None</span>
  | Cons (_, tail) -&gt; <span class="dt">Some</span> tail
</code></pre></div>
<p>Pour peu que l’on possède suffisament d’outils pour manipuler les options, je préfère largement cette approche à celle de lancer une exception. En effet, je trouve le code plus facile à lire, à maintenir, et la signature de type des deux fonctions nous donne directement une indication sur le fait qu’une fonction puisse “échouer”, alors que la signature de type ne donne aucune information sur le fait qu’une fonction lance une exception (c’est le rôle de la documentation de nous informer de ce genre d’informations).</p>
<p>Cependant, il serait intéressant de se demander s’il serait possible, à la compilation et donc, au niveau du système de type, de définir que <code class="sourceCode ocaml" rundoc-language="ocaml">head</code> et <code class="sourceCode ocaml" rundoc-language="ocaml">tail</code> ne peuvent prendre que des listes non-vides.</p>
<h2 id="lutilisation-de-types-fantômes">L’utilisation de types fantômes</h2>
<p>J’avais déjà, à l’époque où je travaillais chez <strong>Dernier Cri</strong>, rédigé un article<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> qui expliquait (de manière abordable, je l’espère), l’idée et l’intérêt des <strong>types fantômes</strong>.</p>
<p>Sans rentrer dans les détails, un type fantômes est un type que l’on va passer en paramètre d’un autre type, et dont le seul intérêt sera de donner des informations supplémentaires que, dans le cas de la liste, le type des données contenues par la liste.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> ('a, 'b) t = 'b my_list</code></pre></div>
<p>Dans cet exemple, <code class="sourceCode ocaml" rundoc-language="ocaml">'b</code> sera le type des données de la liste, et on utilisera <code class="sourceCode ocaml" rundoc-language="ocaml">'a</code> pour définir si la liste est vide ou non.</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> empty_t 
<span class="kw">type</span> not_empty_t 

<span class="kw">type</span> 'a my_list =
 | Empty
 | Cons <span class="kw">of</span> ('a * 'a my_list)

<span class="kw">type</span> ('a, 'b) t = 'b my_list 

<span class="kw">let</span> empty = Empty
<span class="kw">let</span> cons x xs = Cons (x, xs)
<span class="kw">let</span> head <span class="dt">list</span> =
 <span class="kw">match</span> <span class="dt">list</span> <span class="kw">with</span>
 | Cons (x, _) -&gt; x
 <span class="co">(* on ne devrait jamais être ici grâce aux types *)</span>
 | Empty -&gt; <span class="kw">assert</span> <span class="kw">false</span></code></pre></div>
<p>L’implémentation générale ne diffère pas réellement de ce que nous avions fait précédemment. les deux types <code class="sourceCode ocaml" rundoc-language="ocaml">empty_t</code> et <code class="sourceCode ocaml" rundoc-language="ocaml">not_empty_t</code> serviront uniquement à être le paramètre <code class="sourceCode ocaml" rundoc-language="ocaml">'a</code> de notre type <code class="sourceCode ocaml" rundoc-language="ocaml">('a, 'b) t</code>. C’est pour ça qu’ils n’ont pas de forme, la seule chose qui nous intéresse est leur nom. Nous allons pouvoir implémenter l’interface de notre module:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> empty_t
<span class="kw">type</span> not_empty_t 
<span class="kw">type</span> ('a, 'b) t

<span class="kw">val</span> empty : (empty_t, 'a) t
<span class="kw">val</span> cons : 'b -&gt; ('a, 'b) t -&gt; (not_empty_t, 'b) t
<span class="kw">val</span> head : (not_empty_t, 'a) t -&gt; 'a</code></pre></div>
<p>Dans l’interface, nous n’allons pas exposer le types non nécéssaires, par exemple, <code class="sourceCode ocaml" rundoc-language="ocaml">my_list</code>, comme ça, on peut forcer l’utilisation de nos fonctions <code class="sourceCode ocaml" rundoc-language="ocaml">cons</code> et <code class="sourceCode ocaml" rundoc-language="ocaml">empty</code> qui retournent des types <code class="sourceCode ocaml" rundoc-language="ocaml">t</code> bien typés.</p>
<ul>
<li><code class="sourceCode ocaml" rundoc-language="ocaml">empty</code> : retournera toujours une liste vide ;</li>
<li><code class="sourceCode ocaml" rundoc-language="ocaml">cons</code> : retournera toujours une liste non-vide.</li>
</ul>
<p>Maintenant, il suffit de définir le type de la fonction <code class="sourceCode ocaml" rundoc-language="ocaml">head</code> en spécifiant qu’elle ne peut prendre <strong>que</strong> des listes non vides : <code class="sourceCode ocaml" rundoc-language="ocaml">(not_empty_t, 'a) t -&gt; 'a</code>.</p>
<p>Avec un type de liste comme nous l’avons implémenté, il n’est pas possible d’implémenter la fontion <code class="sourceCode ocaml" rundoc-language="ocaml">tail</code>, car on ne pourrait pas savoir si la liste renvoyée est vide. Pour palier à ce manque, il suffirait d’encoder la taille de la liste dans le type fantôme. Pour cela, on peut se servir de <strong>l’axiome de Peano<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a></strong>, qui rend l’implémentation de nombres positifs dans le système de type très aisé.</p>
<p>Cependant, ce n’est pas le sujet de l’article, donc je vous propose d’expérimenter ceci par vous même.</p>
<h2 id="utilisations-des-gadts">Utilisations des GADTs</h2>
<p>Dans l’exemple proposé, on peut rapidement se rendre compte de quelques <em>faiblesses</em> liées à l’usage de types fantômes :</p>
<ul>
<li>on est obligé de restreindre notre interface, pour controller les types des constructeurs ;</li>
<li>ce qui indique que le type fantôme <strong>dépend</strong> du constructeur ;</li>
<li>il faut tout de même gérer les cas du <strong>match</strong> (ici via <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="kw">assert</span> <span class="kw">false</span></code>).</li>
</ul>
<p>C’est pour répondre à ces problématiques que OCaml<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a> intègre, depuis sa version <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="fl">4.00</span></code>, des <strong>types algébriques généralisés</strong>. En effet, les GADTs permettend de séparer le type retourné par les constructeurs d’un autre type. Par exemple, avec notre type <code class="sourceCode ocaml" rundoc-language="ocaml">my_list</code> précédemment définit (que l’on va renommer <code class="sourceCode ocaml" rundoc-language="ocaml">t</code> par soucis de concision) :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> ('a, 'b) t =
  | Empty : (empty_t, 'b) t
  | Cons : ('b * ('a, 'b) t) -&gt; (not_empty_t, 'b) t</code></pre></div>
<p>Avec ce type, OCaml inférera directement le bon type <code class="sourceCode ocaml" rundoc-language="ocaml">'a</code> en fonction du constructeur utilisé, par exemple :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> x = Empty
<span class="kw">val</span> x : (empty_t, 'a) t = Empty</code></pre></div>
<p>Il devient donc très facile d’implémenter la fonction <code class="sourceCode ocaml" rundoc-language="ocaml">head</code> :</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> head <span class="dt">list</span> = 
  <span class="kw">match</span> <span class="dt">list</span> <span class="kw">with</span> 
  | Cons (x, _) -&gt; x

<span class="co">(* ou de manière plus concise *)</span> 
<span class="kw">let</span> head (Cons (x, _)) = x                  </code></pre></div>
<p>Globalement, les GADTs permettent de décrire une <strong>relation</strong> entre un <strong>constructeur</strong> de type et un autre <strong>type</strong>. Ils amènent deux points utiles :</p>
<ul>
<li>l’association d’un constructeur à un type spécifique ;</li>
<li>la restriction des paramètres d’une fonction, comme vu pour la fonction <code class="sourceCode ocaml" rundoc-language="ocaml">head</code>.</li>
</ul>
<p>Ils permettent de faire ce que l’on faisait avec des types fantômes, de manière moins verbeuses et imposent moins de <em>boilerplate</em>.</p>
<p>Comme pour les types fantômes, leur usage peut éliminer des soucis de types ennuyeux et produire du code “plus sur” et pour lesquels on laisse au compilateur une grosse charge de vérifications. On peut trouver beaucoup d’usages où leur utilisation améliore le code, par exemple, dans les récentes modifications apportée à la bibliothèque <strong>Lwt<a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a></strong>.</p>
<p>De plus, comme à la compilation, on <em>perd</em> toute information de typage, leur utilisation n’apporte aucun préjudice à la performance. Cependant, l’usage excessif de GADTs peut entrainer des erreurs de types (à la compilation) plus cryptiques.</p>
<p>Dans la bibliothèque standard de OCaml, les GADTs ont étés utilisés, notamment, pour une nouvelle implémentation des <strong>Formats<a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a></strong>.</p>
<h1 id="les-types-sommes-dans-les-langages-objets">Les types sommes dans les langages objets</h1>
<blockquote>
<p>Tout d’abord, je voudrais sincèrement remercier <strong>Nicolas Rinaudo<a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a></strong> et <strong>Gabriel Scherer<a href="#fn13" class="footnoteRef" id="fnref13"><sup>13</sup></a></strong> pour m’avoir aidé dans l’a rédaction de cet article, respectivement pour m’avoir expliqué des traits relatifs à <strong>Scala<a href="#fn14" class="footnoteRef" id="fnref14"><sup>14</sup></a></strong> et pour m’avoir donné plus d’éléments théoriques sur ce que sont réellement les GADTs et les travers liés à l’anaologie entre GADTs et héritage.</p>
</blockquote>
<p>Dans un langage de programmation orienté objets, on peut faire une rapide analogie entre les types sommes et les <strong>classes unifiés par des liens d’héritage</strong>. Implémentons le type <code class="sourceCode ocaml" rundoc-language="ocaml"><span class="dt">option</span></code> que nous avons utilisé précédemment, en Scala :</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Option[+A]
<span class="kw">case</span> <span class="kw">object</span> None <span class="kw">extends</span> Option[Nothing]
<span class="kw">case</span> <span class="kw">class</span>  Some[A](value: A) <span class="kw">extends</span> Option[A]</code></pre></div>
<p>Sans rentrer dans les détails de l’implémentation, on défini deux <strong>cases</strong>, un objet, qui n’aura qu’une seule valeur habitante possible (un <em>Singleton</em>), et une classe (qui elle pourra avoir plus d’un habitant possible). L’usage de case nous permet de supporter la correspondance de motifs et donc offrir à nos instances, la déconstruction que nous avions évoqués dans les avantages des types sommes.</p>
<p>Ce que l’on remarque assez vite, c’est que, pour créer cette notion d’ <strong>union discriminée</strong>, on va créer une type parent (ici, le trait <code class="sourceCode scala" rundoc-language="scala">Option</code>) et que nos deux types enfants (<code class="sourceCode scala" rundoc-language="scala">None</code> et <code class="sourceCode scala" rundoc-language="scala">Some</code>) <strong>hériteront</strong> du parent. Comme nos constructeurs sont ici des <strong>classes</strong>, l’approche orienté objets des types sommes introduit déjà une notion de <strong>types de constructeurs</strong>. De ce fait, je peux très facilement implémenter une fonction qui ne pourrait prendre <strong>que</strong> des <code class="sourceCode scala" rundoc-language="scala">Some(x)</code>, par exemple :</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> unwrap[A](x : Some[A]) = x.<span class="fu">value</span></code></pre></div>
<p>Obserervons maintenant l’implémentation d’une liste, le code ne varie pas beaucoup du type <code class="sourceCode scala" rundoc-language="scala">Option</code> :</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> MyList[+A]
<span class="kw">case</span> <span class="kw">object</span> Empty <span class="kw">extends</span> MyList[Nothing]
<span class="kw">case</span> <span class="kw">class</span> Cons[A](x: A, xs: MyList[A]) <span class="kw">extends</span> MyList[A] </code></pre></div>
<p>Comme pour la fonction <code class="sourceCode scala" rundoc-language="scala">unwrap</code>, nous pourrions simplement l’écrire dans un objet quelconque, cependant, comme nous sommes dans un langage orienté objet, considérons maintenant que <code class="sourceCode scala" rundoc-language="scala">head</code> est une méthode de notre classe <code class="sourceCode scala" rundoc-language="scala">Some</code> :</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> MyList[+A]
<span class="kw">case</span> <span class="kw">object</span> Empty <span class="kw">extends</span> MyList[Nothing]
<span class="kw">case</span> <span class="kw">class</span> Cons[A](x: A, xs: MyList[A]) <span class="kw">extends</span> MyList[A] {
  <span class="kw">def</span> <span class="fu">head</span>() : A = x
}</code></pre></div>
<p>Ce qui est très amusant, c’est qu’il ne faut pas spécialement un langage <em>futuriste</em> pour encoder ce genre de types. En effet, on pourrait très facilement transposer ce code en <strong>Java</strong>. Nous pouvons donc nous poser deux questions :</p>
<ol>
<li>est-ce que les liens d’héritages produisent la <em>même chose</em> que des GADTs ?</li>
<li>A-t-on besoin de GADTs dans un langage orienté objet (typé statiquement) ?</li>
</ol>
<h2 id="scala-possède-t-il-des-gadts">Scala possède-t-il des GADTs</h2>
<p>De la même manière que Scala ne possède pas, à proprement parlé, de types sommes, Scala ne possède pas de GADTs. La manière d’encoder quelque chose qui s’apparente aux types sommes est l’application de caractéristiques communes aux classes liées par héritage et aux types sommes.</p>
<p>Concernant les GADTs, Nicolas Rinaudo m’a transmis un article<a href="#fn15" class="footnoteRef" id="fnref15"><sup>15</sup></a> qui explique pourquoi, en jouant uniquement sur l’héritage, on ne peut simuler qu’une <em>partie</em> de l’usage des GADTs et il propose une autre implémentation pour tâcher, au mieux, de profiter pleinement des GADTs.</p>
<p>Concrètement, dans l’exemple des listes vides/non-vides, que j’ai choisi parce que je le trouve facile à appréhender (et qu’il permet d’avoir un cheminement linéaire des types sommes aux GADTs en passant par les types fantômes), on ommet un autre point essentiel aux types algébriques généralisés : <strong>l’égalité entre types</strong>.</p>
<p>L’article<a href="#fn16" class="footnoteRef" id="fnref16"><sup>16</sup></a> propose d’ajouter des preuves d’égalités pour typer finement les <strong>consommateurs de données</strong>. On appelle cette méthode <strong>l’encodage final</strong>. Par opposition, les GADTs typent finement les données, on appelle ça un <strong>encodage initial</strong>.</p>
<p>En Scala, le traitement des égalités entre type est trop fragile et pose parfois des soucis au compilateur. De ce fait, Scala ne possède pas de GADTs à proprement parlé, mais permet, via l’héritage, de répondre à certaines problématiques que les GADTs solutionnent aussi. Cependant, <strong>Dotty<a href="#fn17" class="footnoteRef" id="fnref17"><sup>17</sup></a></strong> (un compilateur expérimental pour le langage Scala, qui fait aussi d’incubateur et qui a pour vocation de faire reposer Scala sur des bases plus formalisées) semble intégrer de véritables GADTs… <em>wait and see</em>.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Comme beaucoup <em>d’usages avancés du système de type</em>, il est parfois difficile de trouver des cas d’usages où les GADTs sont essentiel, surtout si comme moi, vous débutez avec les langages fonctionnels statiquement typés. J’espère tout de même que cet article aura, pour certain, pu être une introduction abordable à leurs usages. Je remercie encore sincèrement Nicolas Rinaudo et Gabriel Scherer pour leurs apports techniques sur la question et tous les membres de la communauté <strong>LilleFP</strong> pour m’avoir forcé (voir oppressé) pour la mise en place d’un <em>blog</em> !</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://twitter.com/clementd/status/915635752117129216" class="uri">https://twitter.com/clementd/status/915635752117129216</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="http://ocaml.org" class="uri">http://ocaml.org</a><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><a href="https://en.wikipedia.org/wiki/Algebraic_data_type" class="uri">https://en.wikipedia.org/wiki/Algebraic_data_type</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p><a href="http://form-ocaml.forge.ocamlcore.org/intro.html" class="uri">http://form-ocaml.forge.ocamlcore.org/intro.html</a><a href="#fnref4">↩</a></p></li>
<li id="fn5"><p><a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html" class="uri">https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html</a><a href="#fnref5">↩</a></p></li>
<li id="fn6"><p><a href="http://package.elm-lang.org/packages/elm-lang/core/latest/List#head" class="uri">http://package.elm-lang.org/packages/elm-lang/core/latest/List#head</a><a href="#fnref6">↩</a></p></li>
<li id="fn7"><p><a href="https://derniercri.io/tech-blog/phantom-types" class="uri">https://derniercri.io/tech-blog/phantom-types</a><a href="#fnref7">↩</a></p></li>
<li id="fn8"><p><a href="https://en.wikipedia.org/wiki/Peano_axioms" class="uri">https://en.wikipedia.org/wiki/Peano_axioms</a><a href="#fnref8">↩</a></p></li>
<li id="fn9"><p><a href="https://caml.inria.fr/pub/docs/manual-ocaml-400/manual021.html#toc85" class="uri">https://caml.inria.fr/pub/docs/manual-ocaml-400/manual021.html#toc85</a><a href="#fnref9">↩</a></p></li>
<li id="fn10"><p><a href="https://discuss.ocaml.org/t/lwt-core-refactored/161/7" class="uri">https://discuss.ocaml.org/t/lwt-core-refactored/161/7</a><a href="#fnref10">↩</a></p></li>
<li id="fn11"><p><a href="https://ocaml.org/meetings/ocaml/2013/proposals/formats-as-gadts.pdf" class="uri">https://ocaml.org/meetings/ocaml/2013/proposals/formats-as-gadts.pdf</a><a href="#fnref11">↩</a></p></li>
<li id="fn12"><p><a href="https://twitter.com/NicolasRinaudo" class="uri">https://twitter.com/NicolasRinaudo</a><a href="#fnref12">↩</a></p></li>
<li id="fn13"><p><a href="http://gallium.inria.fr/~scherer/" class="uri">http://gallium.inria.fr/~scherer/</a><a href="#fnref13">↩</a></p></li>
<li id="fn14"><p><a href="https://www.scala-lang.org/" class="uri">https://www.scala-lang.org/</a><a href="#fnref14">↩</a></p></li>
<li id="fn15"><p><a href="https://pchiusano.github.io/2014-05-20/scala-gadts.html" class="uri">https://pchiusano.github.io/2014-05-20/scala-gadts.html</a><a href="#fnref15">↩</a></p></li>
<li id="fn16"><p><a href="https://pchiusano.github.io/2014-05-20/scala-gadts.html" class="uri">https://pchiusano.github.io/2014-05-20/scala-gadts.html</a><a href="#fnref16">↩</a></p></li>
<li id="fn17"><p><a href="http://dotty.epfl.ch/" class="uri">http://dotty.epfl.ch/</a><a href="#fnref17">↩</a></p></li>
</ol>
</div>
    <div class="article-footer">
	Cet article est terminé ! <br /> Si jamais vous avez des
	remarques, n'hésitez pas à écrire un <strong>commentaire</strong>
	ou à <a href="https://github.com/xvw/blog">contribuer</a>

	<div id="disqus_thread"></div>
	<script>
	 
	 var disqus_config = function () {
	     this.page.url = "https://xvw.github.io/";  // Replace PAGE_URL with your page's canonical URL variable
	     this.page.identifier = "posts/2017-10-16-gadt-pour-les-debutants.org"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
	 };
	 
	 (function() { // DON'T EDIT BELOW THIS LINE
	     var d = document, s = d.createElement('script');
	     s.src = 'https://xvw-blog.disqus.com/embed.js';
	     s.setAttribute('data-timestamp', +new Date());
	     (d.head || d.body).appendChild(s);
	 })();
	</script>
	<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
</main>

	<footer>
	    Merci 
	    <a href="https://jaspervdj.be/hakyll/">Hakyll</a>, 
	    tu es un superbe générateur ❤ 
	</footer>
    </body>
    <script src="../js/hl.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</html>
