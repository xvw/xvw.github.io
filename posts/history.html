<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
  <link rel="alternate" type="application/atom+xml" title="xvw blog" href="../atom.xml" />
  <link href="https://fonts.googleapis.com/css?family=Lora:400,400i,700,700i|Playfair+Display:400,700,900|Fira+Mono" rel="stylesheet">
  <link rel="stylesheet" href="../css/default.css" />
  <script src="../js/player.js" type="application/javascript"></script>
  <title>xvw - Voyager dans le temps avec un Zipper</title>
</head>

<body>
  <div id="resume-reader" class="history-tooltip">
  <a href="../index.html">Revenir à l'accueil</a>
  <div id="resume-box"></div>
  <div class="progress">
    <div id="progress-bar"></div>
  </div>
</div>

<main class="article">

  <h1 class="main-title">Voyager dans le temps avec un Zipper</h1>
  <div class="date">Publié le 20 du 11 2017</div>
  <blockquote>
<p>Au contraire des deux précédents articles, je vais tâcher d’être très bref en présentant un usage concret d’une structure de données pour représenter un <strong>historique naviguable</strong>. L’intérêt de l’usage d’un Zipper réside dans la simplicité étonnante avec laquelle il est implémentable. Le code présenté dans cet article sera, une fois de plus, en <a href="http://elm-lang.org/">Elm</a>.</p>
<p>Cet article sera un peu différent des précédents car il présente une expérience concrète et un raisonnement sur quelle structure de données utiliser pour solutionner une problématique spécifique.</p>
<p>Ces derniers jours, j’ai démarré le développement de <a href="https://github.com/xvw/qian">Qian</a>, un tout petit explorateur de fichier pour remplacer <em>Finder</em> (de OSX), que je n’aime pas vraiment pour d’obscures raisons. Bien que mon objectif est de m’en tenir à mes besoins les plus <strong>stricts</strong>, pour permettre au logiciel de sortir rapidement (comme un prototype) et de suivre une évolution portée par mes attentes, j’ai très rapidement considéré la présence d’un historique de navigation. Concrètement, la présence des boutons <strong>suivant</strong> et <strong>précédent</strong>.</p>
<p>Voici un exemple de l’utilisation de ces derniers dans Qian :</p>
<div class="figure">
<img src="../images/history-sample.gif" title="SAMPLE1" alt="Un exemple de navigation" />
<p class="caption">Un exemple de navigation</p>
</div>
<p>Mon application n’étant pas dans un vrai navigateur web mais dans une fenêtre <a href="https://electron.atom.io/">Electron</a>, je ne bénéficie pas des boutons suivant/précédent fourni par le navigateur. D’où l’implémentation manuelle de l’historique.</p>
</blockquote>
<p>Rapellons d’abord ce que nous attendons de notre historique. En définissant bien le périmètre de notre fonctionnalité, nous verrons que le spectre de notre structure de donnée sera réellement emmergera (une autre approche aurait pu être de rédiger une batterie de tests, cependant, je pense que pour la lisibiltié de l’article, une explication textuelle sera plus adaptée).</p>
<h2 id="représentation-visuelle-de-lhistorique">Représentation visuelle de l’historique</h2>
<p>Pour la clareté de l’explication, nous allons imaginer que nous implémentons un historique sur une application web composée de ces différentes pages :</p>
<ul>
<li><code>index.html</code></li>
<li><code>aPropos.html</code></li>
<li><code>contact.html</code></li>
<li><code>liens.html</code></li>
</ul>
<p>Initialement, quand on démarre une session, l’utilisateur ou l’utilisatrice ne possède qu’un <strong>état courant</strong>. En effet, comme il ou elle vient de démarrer l’application, il est impossible qu’il y ait une page précédente et une page suivante et l’état courant est la page <code>index.html</code> :</p>
<div class="figure">
<img src="../images/zipper-init.png" title="SAMPLE2" alt="Un exemple de navigation" />
<p class="caption">Un exemple de navigation</p>
</div>
<p>Imaginons maintenant que la personne utilisant l’application se rende à la page <code>liens.html</code> en passant par la page <code>aPropos.html</code>, nous pouvons techniquement revenir deux fois en arrière :</p>
<div class="figure">
<img src="../images/zipper-init2.png" title="SAMPLE3" alt="Un exemple de navigation avec des prédécesseurs" />
<p class="caption">Un exemple de navigation avec des prédécesseurs</p>
</div>
<p>Concrètement, le fait de se rendre sur une autre page consiste simplement à <strong>empiler</strong> dans la pile de l’historique la page que l’on quitte. À ce stade, nous avons déjà les ingrédients pour implémenter la stratégie d’enregistrement des pages précédentes.</p>
<p>Imaginons maintenant que l’utilisateur ou l’utilisatrice veuille se rendre sur la page <code>aPropos.html</code> en <strong>utilisant le bouton précédent</strong> :</p>
<div class="figure">
<img src="../images/zipper-init3.png" title="SAMPLE4" alt="Un exemple de navigation avec des successeurs" />
<p class="caption">Un exemple de navigation avec des successeurs</p>
</div>
<p>En retournant, une fois de plus, en utilisant le bouton précédent, sur la page <code>index.html</code>, notre <strong>passé</strong> est maintenant vide, et notre <strong>futur potentiel</strong> possède deux éléments :</p>
<div class="figure">
<img src="../images/zipper-init4.png" title="SAMPLE5" alt="Un exemple de navigation avec des successeurs" />
<p class="caption">Un exemple de navigation avec des successeurs</p>
</div>
<p>Nous sommes donc maintenant sur la page <code>index.html</code>, <em>retour aux sources</em>. Revenons à l’état précédent, en utilisant <strong>le bouton suivant</strong> (paradoxal, n’est-ce pas) :</p>
<div class="figure">
<img src="../images/zipper-init3.png" title="SAMPLE4" alt="Un exemple de navigation avec des successeurs" />
<p class="caption">Un exemple de navigation avec des successeurs</p>
</div>
<p>Et décidons de nous rendre à la page <code>contact.html</code>. Dès lors que l’on ne se sert plus des boutons <em>précédent</em> et <em>suivant</em> pour naviguer, notre futur potentiel est <strong>nettoyé</strong> :</p>
<div class="figure">
<img src="../images/zipper-init5.png" title="SAMPLE5" alt="Suppression du futur potentiel" />
<p class="caption">Suppression du futur potentiel</p>
</div>
<p>Pour être honnête (et faire aveu de ma naïveté), au début, j’avais considéré, simplement, que la visite d’une nouvelle page entrainait l’empilement de la page que l’on quitte dans le <strong>passé</strong>, sans vider le futur. Cette approche peut ne pas être pénalisante si on implémente un historique de navigation, cependant, elle introduit un <strong>état incohérent</strong>. Pour bien comprendre l’incohérence de l’état du <strong>futur potentiel</strong>, je vous invite à imaginer l’historique d’un logiciel de peinture numérique. Ici, nous pourrions imaginer, en plus de notre palette d’outils pour le dessins, ces deux commandes :</p>
<ul>
<li><code>ctrl + z</code> : “undo”, qui retourne dans le “passé” ;</li>
<li><code>ctrl + u</code> : “redo”, qui retourne dans le “futur”.</li>
</ul>
<p>Imaginez ce qu’il se passerait si j’intercale une action entre mon passé et mon futur :</p>
<div class="figure">
<img src="../images/zipper-init6.png" title="SAMPLE6" />

</div>
<div class="figure">
<img src="../images/zipper-init7.png" title="SAMPLE7" alt="Dans un logiciel de dessin (libre !)" />
<p class="caption">Dans un logiciel de dessin (libre !)</p>
</div>
<p>On se rend vite compte qu’on crée un état <strong>incohérent</strong>. Même si dans l’historique de navigation d’un explorateur de fichier, ce n’est pas <em>dramatique</em>, dans un éditeur d’image, ça pourrait créer des résultats amusants.</p>
<h1 id="implémentation-de-lhistorique">Implémentation de l’historique</h1>
<p>Il existe plusieurs manières de procéder. En effet, une <a href="https://en.wikipedia.org/wiki/Linked_list">liste chainée</a> pourrait parfaitement convenir. Cependant, comme <strong>Elm</strong> est un langage fonctionnel, je vous propose d’utiliser une variation d’une structure fonctionnelle connue. Le Zipper <a href="http://gallium.inria.fr/~huet/PUBLIC/zip.pdf">a été proposé</a> par <strong>Gerard Huet</strong> en 1993. Il s’agit d’une interface sur une structure pour <strong>naviguer à gauche et à droite</strong>. Bien qu’il existe plusieurs implémentation, nous allons partir d’une variation légère du Zipper (qui d’habitude, agit sur un arbre) utilisant deux listes et un élément courant :</p>
<pre class="elm"><code>type alias History a =
    { past : List a
    , present : a
    , future : List a
    }
</code></pre>
<p>Nous pouvons maintenant définir une interface pour utiliser notre historique. La première étape étant, simplement, de permettre de construire un nouvel historique. Comme je suppose qu’il est impossible de <strong>ne pas avoir d’état initial</strong>, l’implémentation de cette fonction est très aisée :</p>
<pre class="elm"><code>new : a -&gt; History a
new currentState =
    { past = []
    , present = currentState
    , future = []
    }
</code></pre>
<p>Maintenant que nous pouvons créer un nouvel historique, nous pouvons nous intéresser à la navigation.</p>
<h2 id="implémentation-la-navigation">Implémentation la navigation</h2>
<p>Pour aller à gauche ou à droite, nous allons partir du principe que c’est une opération qui peut échouer. En effet, comment <em>remonter dans le temps</em> <strong>s’il n’existe pas de passé</strong> , et inversément, comment <em>avancer dans le temps</em> <strong>s’il n’existe pas de futur</strong> ? Comme l’opération peut échouer, on se servira de ces signatures :</p>
<pre class="elm"><code>backward : History a -&gt; Maybe (History a)
forward  : History a -&gt; Maybe (History a)
</code></pre>
<p>Le seul cas où le voyage dans le temps peut échouer étant l’absence de passé ou de futur, il n’est pas nécéssaire de qualifier l’erreur (en utilisant <code>Result</code>, par exemple).</p>
<p>L’implémentation des deux commandes est assez simple (et récurrente) :</p>
<pre class="elm"><code>backward : History a -&gt; Maybe (History a)
backward zipper =
    case zipper.past of
        [] -&gt;
            Nothing

        x :: xs -&gt;
            Just { past = xs
                 , present = x
                 , future = zipper.present :: zipper.future
                 }
</code></pre>
<p>Si notre <em>Zipper</em> ne possède pas de passé, on renvoie <code>Nothing</code>, par contre, si c’est le cas, notre présent est empilé dans le future, et la tête du passé devient le présent.</p>
<pre class="elm"><code>forward : History a -&gt; Maybe (History a)
forward zipper =
    case zipper.future of
        [] -&gt;
            Nothing

        x :: xs -&gt;
            Just { past = zipper.present :: zipper.past
                 , present = x
                 , future = xs
                 }
</code></pre>
<p>La tâche est identique pour <em>avancer dans le temps</em>, sauf qu’on agit sur le future et non sur le passé. Nous pouvons maintenant très facilement naviguer dans notre <em>Zipper</em>. De plus, nous pouvons aussi nous servir de nos deux fonctions pour implémenter des combinateurs complémentaires :</p>
<pre class="elm"><code>hasPast : History a -&gt; Bool
hasPast zipper =
    case backward zipper of
      Nothing -&gt;
         False

      Just _  -&gt;
         True

hasFuture : History a -&gt; Bool
hasFuture zipper =
    case forward zipper of
      Nothing -&gt;
         False

      Just _  -&gt;
         True
</code></pre>
<p>Maintenant que nous avons la navigation dans l’historique, il ne nous reste plus qu’a intégrer une fonction pour <strong>visiter</strong> l’historique.</p>
<h2 id="pousser-un-nouvel-état-dans-lhistorique">Pousser un nouvel état dans l’historique</h2>
<p>Comme nous l’avions évoqué dans l’introduction de l’article, l’ajout d’un nouvel élément dans l’historique <strong>nettoie</strong> le futur du <em>Zipper</em>, pour garantir que l’on puisse invariablement restituer un état cohérent. Son implémentation est très facile :</p>
<pre class="elm"><code>push : History a -&gt; a -&gt; History a
push zipper newState =
    { past = zipper.present :: zipper.past
    , present = newState
    , future = []
    }
</code></pre>
<p>Et c’est tout…</p>
<h2 id="intérêt-dun-zipper">Intérêt d’un Zipper</h2>
<p>Dans un langage fonctionnel, l’ajout <strong>en tête</strong> (une opération que l’on appelle <code>Cons</code>) est très peu coûteuse : <code>O(1)</code> et la déconstruction de la tête et de la queue d’une liste est elle aussi de complexité <code>O(1)</code>. De ce fait, l’implémentation de notre historique ne repose que sur des opérations peu coûteuse, ce qui le rend très efficace. De plus, le <em>Zipper</em> permet de ne jamais faire de <strong>mutations</strong>, on renvoie sans arrêt un nouveau <em>Zipper</em> et le glâneur de cellules s’occupe d’allouer/désallouer ce qui est nécéssaire. En plus d’être, dans ce contexte, très efficace, je trouve que le <em>Zipper</em> est une structure élégante et facile à utiliser.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Dans cet article (très court), nous avons vu l’utilisation d’une structure de données issue du monde de la programmation fonctionnelle. Sans vouloir faire de comparaisons capilotractées, connaître ces structures est, en analogie avec la programmation Orienté Objets, aussi important que la connaissance des <strong>motifs de conceptions</strong>.</p>
<p>Je suis parfaitement conscient que sur beaucoup d’aspects, cet article est naïf, cependant, il est possible qu’il soit le premier d’une série, un peu plus technique, sur des usages concrets de structures de données fonctionnelles.</p>
  <div id="eof-article"></div>
  <div class="article-footer">
    Cet article est terminé ! <br /> Si jamais vous avez des remarques, n'hésitez pas à écrire un <strong>commentaire</strong> ou à <a href="https://github.com/xvw/blog">contribuer</a>
    <div id="disqus_thread"></div>
    <script>
      var disqus_config = function () {
      this.page.url = "https://xvw.github.io/posts/history.html";
      this.page.identifier = "posts/history.org";
      };
      (function() { // DON'T EDIT BELOW THIS LINE
        var d = document,
          s = d.createElement('script');
        s.src = 'https://xvw-blog-1.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</main>
<script src="../js/hl.js"></script>
<script>
  hljs.initHighlightingOnLoad();
  __useResumable("/posts/history.html");
</script>

  <footer>
    <div>
      <div>
        <a href="http://webring.xxiivv.com/#random" target="_blank">
          <img src="../images/icon.white.svg" />
        </a>
      </div>
      <div>
        <span>Merci</span>
        <a href="https://jaspervdj.be/hakyll/">Hakyll</a>
        <span>, tu es un superbe générateur ❤</span>
      </div>
    </div>
  </footer>
</body>

</html>
