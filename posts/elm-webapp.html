<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
  <link rel="alternate" type="application/atom+xml" title="xvw blog" href="../atom.xml" />
  <link href="https://fonts.googleapis.com/css?family=Lora:400,400i,700,700i|Playfair+Display:400,700,900|Fira+Mono" rel="stylesheet">
  <link rel="stylesheet" href="../css/default.css" />
  <script src="../js/player.js" type="application/javascript"></script>
  <title>xvw - Une application web moderne en Elm</title>
</head>

<body>
  <div id="resume-reader" class="history-tooltip">
  <a href="../index.html">Revenir à l'accueil</a>
  <div id="resume-box"></div>
  <div class="progress">
    <div id="progress-bar"></div>
  </div>
</div>

<main class="article">

  <h1 class="main-title">Une application web moderne en Elm</h1>
  <div class="date">Publié le 25 du 10 2017</div>
  <blockquote>
<p><strong>Note du 5 Décembre 2017</strong></p>
<p>Attention, bien que le laïus sur la morphologie des messages et des modèles et toujours d’actualité. La proposition des <strong>Patch</strong> des messages <strong>Discrets</strong> a été, à juste titre, remise en question (car cela impose un style <strong>impératif</strong>). Je laisse tout de même l’article parce que je pense que sa première partie et celle sur le routing sont pertinentes et que j’assume mes erreurs… aha.</p>
<p><strong>Reprise de l’article</strong></p>
</blockquote>
<blockquote>
<p>Depuis 2003, comme nous l’indique <a href="https://openclassrooms.com/courses/le-javascript-moderne">cet article, </a>le JavaScript est utilisé comme un <strong>bytecode</strong>, beaucoup de compilateurs/transpilateurs ciblent le JavaScript pour permettre à des développeuses et développeurs d’écrire des applications web clientes dans leur langage favori.</p>
<p>Les applications devenant de plus en plus complexes, principalement grâce à l’évolution des navigateurs web (qui est une conséquence de l’amélioration de notre matériel), beaucoup de développeuses et développeurs ont fait le choix d’utiliser des <strong>langages statiquement typés</strong> pour faciliter le développement. On peut citer, entre autres, <a href="https://www.typescriptlang.org/">TypeScript</a>, <a href="http://www.purescript.org/">PureScript</a>, <a href="https://reasonml.github.io/">ReasonML</a> / <a href="https://ocaml.org/">OCaml</a> (avec <a href="https://bucklescript.github.io/bucklescript/Manual.html">BuckleScript</a> ou <a href="http://ocsigen.org/js_of_ocaml/">Js_of_ocaml</a>) et <a href="http://elm-lang.org/">Elm</a>. Tous ces outils proposant chacun des avantages (et aussi des inconvénients).</p>
<p>Au contraire de beaucoup d’autres technologies, Elm embarque une architecture qui fait office de <strong>framework</strong> pour construire des applications web. Même si dans un premier temps, chaque exercice proposé par le site est très clair, lorsque l’on doit écrire une application “riche” qui propose plusieurs formes d’interactivité, il faut parfois ruser, et remettre en question des pratiques que l’on estimait bonne.</p>
<p>Dans cet article, je vous propose, via des cas concrets, de mettre en place une nouvelle architecture au sein de la Elm-architecture pour permettre, de facilement faire croître une application Elm.</p>
<p>Cet article n’est pas un tutoriel d’apprentissage au langage Elm, une connaissance sommaire du langage est requise pour comprendre le code présenté. De plus, les morceaux de code présentés n’utilisent pas <a href="https://github.com/avh4/elm-format">Elm-format</a>, non pas pour être rebelle, mais ça aurait pu rendre l’article plus difficilement lisible.</p>
</blockquote>
<p>Elm est un langage qui s’inscrit dans la famille des langages <strong>ML</strong>, et sa syntaxe s’inspire fortement de <a href="https://haskell.org">Haskell</a>. On écrit une application “entière” en Elm et ensuite, elle est <strong>transpilée</strong> en JavaScript. En plus d’offrir une syntaxe confortable, Elm offre un système de types puissant et expressif (par rapport à JavaScript), qui évite au maxium les erreurs au <strong>Runtime</strong>. De plus, le compilateur de Elm est très bavard et éloquent sur les manières de résoudre une erreur à la compilation.</p>
<p>En plus d’être un très beau langage (argument subjectif, je l’accorde), Elm impose une manière de structurer son application web que l’on appelle la <a href="https://guide.elm-lang.org/architecture/">Elm-architecture</a>. Cette architecture permet <a href="http://elm-lang.org/blog/farewell-to-frp">d’abstraire</a> les concepts complexes qui sont liés, entre autre, à la <strong>programmation fonctionnelle réactive</strong> (comme, par exemple, les <a href="http://haskell.cs.yale.edu/wp-content/uploads/2011/02/oxford02.pdf">flèches</a> ou les <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming#Formulations_of_FRP">signaux</a>). De ce fait, Elm est un langage facile à appréhender, ce qui explique sans doute son succès grandissant dans le monde des applications <em>front-end</em>. De ce fait, l’auteur lui même dit que Elm n’est pas un langage fonctionnel reactif, cependant, il tient beaucoup des promesses liés à cette famille de langage.</p>
<h1 id="utilisation-de-la-elm-architecture">Utilisation de la Elm-architecture</h1>
<p>La Elm-architecture repose sur quelques pilliers :</p>
<ol>
<li>On représente l’état de l’application via un type <code class="elm rundoc-block" rundoc-language="elm">Model</code> ;</li>
<li>la représentation de la page est une fonction qui prend en paramètre un <code class="elm rundoc-block" rundoc-language="elm">Model</code> ;</li>
<li>dans la fonction de vue, on peut envoyer des messages (de type <code class="elm rundoc-block" rundoc-language="elm">Message</code>) à une fonction de rafraîchissement ;</li>
<li>la fonction de rafraîchissement prend en argument un <code class="elm rundoc-block" rundoc-language="elm">Message</code> et un <code class="elm rundoc-block" rundoc-language="elm">Model</code> et renvoie une nouvelle version du <code class="elm rundoc-block" rundoc-language="elm">Model</code> ;</li>
<li>une application Elm est appelée un <strong>programme</strong> et initialise le <code class="elm rundoc-block" rundoc-language="elm">Model</code> et définit la fonction de vue et celle de rafraîchissement.</li>
</ol>
<p>Dans ce premier exemple, nous allons simplement créer deux boutons et un texte qui affichera une valeur entière. Quand on appuyera sur le premier bouton, on incrémentera la valeur du texte, quand on appuyera sur le second, on décrémentera la valeur du texte.</p>
<p>(Vous pouvez retrouver une version exécutable de ce code <a href="http://elm-lang.org/examples/buttons">ici</a>.)</p>
<p>Dans cet exemple, notre modèle sera un nombre entier, celui qui sera affiché dans notre espace de texte. Et nous aurons deux messages possibles :</p>
<ol>
<li>un message pour incrémenter le modèle ;</li>
<li>un message pour décrémenter le modèle.</li>
</ol>
<p>Comme notre modèle est assez simple, la fonction de rafraîchissement est assez facile à implémenter.</p>
<pre class="elm"><code>type Msg 
 = Increment 
 | Decrement

update msg model =
  case msg of
    Increment -&gt; model + 1
    Decrement -&gt; model - 1
</code></pre>
<p>Rien de très complexe, on se sert <strong>d’unions discriminées</strong> pour définir les différents messages recevables (parce que c’est commun) et la fonction de rafraîchissement se contente, en cas de réception du message <code class="elm rundoc-block" rundoc-language="elm">Increment</code>, on renvoie le modèle auquel on ajoute <code class="elm rundoc-block" rundoc-language="elm">1</code>, en cas de réception du message <code class="elm rundoc-block" rundoc-language="elm">Decrement</code>, on renvoie le modèle auquel on retire <code class="elm rundoc-block" rundoc-language="elm">1</code>.</p>
<p>Maintenant que nous avons notre logique de traitement des messages, nous pouvons implémenter notre vue. En Elm, le HTML s’écrit au moyen de <strong>fonctions</strong> :</p>
<pre class="elm"><code>view model =
  div []
    [ button [ onClick Decrement ] [ text &quot;-&quot; ]
    , div [] [ text (toString model) ]
    , button [ onClick Increment ] [ text &quot;+&quot; ]
    ]
</code></pre>
<p>L’attribut <code class="elm rundoc-block" rundoc-language="elm">onClick</code>, qui est aussi une fonction, <strong>enverra</strong> un message à la fonction de rafraîchissement. Maintenant, il ne reste plus qu’a créer notre fonction <code class="elm rundoc-block" rundoc-language="elm">main</code> qui instanciera un <strong>programme</strong> :</p>
<pre class="elm"><code>main =
  beginnerProgram { 
    model = 0
  , view = view
  , update = update 
  }
</code></pre>
<p>Et voila, je vous invite à <a href="http://elm-lang.org/examples/buttons">tester le code en ligne</a>, au delà de quelques importations complémentaires, il n y a rien de plus que ce que j’ai montré.</p>
<p>La génération de la vue est largement optimisée grâce à l’utilisation d’un <a href="https://www.reddit.com/r/javascript/comments/2jav2q/is_there_any_good_standalone_implementation_of/cl9zrz1/?utm_content=permalink&amp;utm_medium=front&amp;utm_source=reddit&amp;utm_name=javascript">DOM virtuel</a>, qui va minimiser les transformations nécéssaire pour rendre la vue.</p>
<p>La Elm-architecture propose plusieurs types de programmes pour démarrer une application dans le contexte idéal. Elle introduit aussi une notion de <strong>signaux discrets</strong> qui sont appelés des <strong>souscriptions</strong>. En résumé, elle <em>fit</em> très bien avec les attentes <em>fonctionnelles</em> d’une application web moderne.</p>
<h3 id="en-résumé">En résumé</h3>
<p>La Elm-architecture est vraiment agréable à utiliser, elle n’est pas trop rigide et permet donc d’organiser son code (via des <strong>modules</strong>) de manière assez libre. Cependant, l’écriture d’une application complète se réveler complexe pour plusieurs raisons. En effet, même si l’architecture décrit un <em>flot</em> assez évident (et donc, compréhensible), la difficulté peut résider dans la <strong>morphologie des messages et des modèles</strong>.</p>
<p><span id="ingredients"></span>Voyons, avant de nous ateler à la construction, ce que l’on pourrait attendre d’une application web <em>moderne</em> :</p>
<ul>
<li>du <em>routing</em> (côté client) ;</li>
<li>de l’interactivité ponctuelle (ouverture/fermeture de <code class="sourceCode html" rundoc-language="html"><span class="kw">&lt;div&gt;</span></code> par exemple) ;</li>
<li>des messages discrets (venant de <a href="https://developer.mozilla.org/fr/docs/Utilisation_des_web_workers">Workers</a>, de <a href="https://developer.mozilla.org/fr/docs/Web/API/BroadcastChannel">Channels</a> ou encore de <a href="https://developer.mozilla.org/fr/docs/WebSockets">Sockets</a> par exemple).</li>
</ul>
<p>Le <em>routing</em> introduit une notion d’<strong>état bookmarkable</strong>, l’interactivité ponctuelle amène des éléments <strong>d’ergonomie</strong> qui améliorent la navigation et les messages discrets permettent de s’approcher des <strong>applications temps réel</strong>.</p>
<h2 id="forme-des-messages-et-des-modèles">Forme des messages et des modèles</h2>
<blockquote>
<p>Il est important de préciser que cet article est avant tout un retour d’expérience; il n’a pas du tout pour vocation à prétendre à une quelconque révolution. Lorsque <strong>j</strong>’ai été amené à m’intéresser à Elm, les exemples “classiques” ont été assez faciles à appréhender. Cependant, quand j’ai été amené à structurer une application plus ambitieuse, j’ai dû expérimenter plusieurs voies. Je ne prétend pas que c’est la seule (ni même la meilleure) et je serai ravi de lire vos critiques en commentaire ou par courrier éléctronique !</p>
</blockquote>
<p>Avec l’architecture proposée, on est souvent tenté de faire ce qui, à mon sens, est une <strong>erreur monumentale</strong> si l’on veut que notre application puisse croître en fonctionnalités. Avant d’entamer les retours concrets sur l’implémentation d’une application, j’aimerais mettre en lumière un point de vue que j’ai fait mûrir en développant des applications de plus en plus ambitieuses avec Elm.</p>
<ol>
<li><p>Le modèle ne doit pas servir <strong>que</strong> à décrire le modèle de données (dans le sens qu’on lui donne dans le <em>back-end</em>), il décrit <strong>l’état</strong> courant de l’application. De ce fait, dans une application <em>complexe</em>, on devrait souvent <strong>privilégier</strong> <strong>l’usage d’unions discriminées</strong> paramétrés qui n’exposent que les informations nécéssaires pour naviguer dans l’application plutôt que de tenter d’être exhaustif en exposant un enregistrement aplatit.</p></li>
<li><p>les messages n’ont <strong>pas tous le même niveau sémantique</strong> dans une application, ils peuvent donc être regroupés et ordonnés au moyen, une fois de plus, <strong>d’unions discriminées</strong>.</p></li>
</ol>
<p>Rappelons le type de la fonction <code class="elm rundoc-block" rundoc-language="elm">update</code> qui va ponctuellement <strong>générer des</strong> <strong>fragments de la vue</strong> :</p>
<pre class="elm"><code>update : Message -&gt; Model -&gt; Model
</code></pre>
<p>Cette signature indique que pour <strong>un message</strong> et un <strong>modèle</strong>, on produit le modèle à l’état suivant. Donc, le <strong>message reçu collabore avec le modèle courant</strong> pour produire le modèle suivant.</p>
<p>Cette <em>petite mise en garde</em> peut sembler, à bien des égards, très naïve. Cependant, je sais que pour ma part, ma première idée, quand j’ai été amené à développer mes premières applications Elm, a été de vouloir, instinctivement, considérer mon modèle comme <em>un modèle de données</em> (et donc tâcher, au mieux, de le rendre exhaustif) et mes messages comme <em>des actions atomiques</em> ayant toutes le même niveau sémantique. Cette manière de procéder a eu comme conséquence que mon modèle était toujours invariablement trop peuplé, la séparation de mes vues en fonctions plus complexe, et ma fonction de rafraîchissement beaucoup trop longue et difficilement fragmentable.</p>
<h1 id="construire-une-application">Construire une application</h1>
<p>Comme Elm ne propose pas d’outils de construction générique (comme <a href="http://form-ocaml.forge.ocamlcore.org/modules/foncteurs.html">les foncteurs applicatifs de OCaml</a> par exemple), l’architecture que je propose n’est pas figé et devra <strong>s’adapter aux besoins de l’application</strong>. Cette partie de l’article est donc à prendre comme une méthodologie et non comme une architecture figée, au contraire de la Elm-architecture.</p>
<p>Je ne détaillerai pas tous les points techniques liés à Elm, par soucis de concision, cependant, le code utilisé pour expérimenter cette infrastructure est accessible <a href="https://github.com/xvw/gromel/tree/master/assets/elm/src">sur ce dépôt</a> (qui fait office d’expérimentation, le code n’est pas un exemple sur beaucoup d’aspects… désolé), il s’agit d’un projet <a href="https://elixir-lang.org/">Elixir</a> / <a href="http://phoenixframework.org/">Phoenix</a>. Cependant la partie Elixir n’est pas très intéressante (et n’a été mise en place que pour tester les <em>Websockets</em>).</p>
<p>Attention, je n’ai pas du tout la prétention d’innover; cependant, les exemples liés à l’utilisation de Elm-architecture couvrent généralement la partie SPA et j’ai la conviction que le mélange des actions ponctuelle avec celle du <em>routing</em> client peuvent parfois entraîner des difficultés à modeliser les types de messages et de modèles à utiliser.</p>
<h2 id="principe-général-de-lapplication">Principe général de l’application</h2>
<p>L’application est vraiment <em>cheap</em> (et laide), cependant, elle survole plusieurs cas d’usages relatifs <a href="#ingredients">aux ingrédients</a> que nous avions établi comme étant les pré-requis à l’implémentation d’une application web moderne, on retrouve donc plusieurs pages qui utilisent différents concepts relatifs à ces ingrédients :</p>
<ul>
<li>des pages qui n’exposent aucune interactivité ;</li>
<li>des pages qui intègrent des élements interactifs ;</li>
<li>la possibilité de publier des messages partagés entre les différents clients ;</li>
<li>une notion d’erreur générale.</li>
</ul>
<h3 id="bibliothèques-utilisées">Bibliothèques utilisées</h3>
<p>Voici un rapide récapitulatif des outils utilisés dans l’implémentation de cette expérience :</p>
<ul>
<li><a href="https://elixir-lang.org/">Elixir</a> <code class="sourceCode elixir" rundoc-language="elixir"><span class="op">~&gt;</span> <span class="fl">1.4</span></code> ;</li>
<li><a href="http://phoenixframework.org/">Phoenix</a> <code class="sourceCode elixir" rundoc-language="elixir"><span class="op">~&gt;</span> <span class="fl">1.3</span><span class="op">.</span><span class="dv">0</span></code> ;</li>
<li><a href="http://elm-lang.org/">Elm</a> <code class="elm rundoc-block" rundoc-language="elm">0.18</code></li>
<li><a href="http://package.elm-lang.org/packages/elm-lang/navigation/latest">elm-lang/navigation</a> <code class="elm rundoc-block" rundoc-language="elm">2.1.0 &lt;= v &lt; 3.0.0</code> ;</li>
<li><a href="http://package.elm-lang.org/packages/evancz/url-parser/latest/">evancz/url-parser</a> <code class="elm rundoc-block" rundoc-language="elm">2.0.1 &lt;= v &lt; 3.0.0</code>.</li>
</ul>
<p>Comme cet article à été écrit à l’aube de la sortie de Elm <code class="elm rundoc-block" rundoc-language="elm">0.19</code>, il est possible que dans un futur proche, certaines des propositions présentées dans l’article deviennent obsolètes !</p>
<h2 id="implémentation-des-états-bookmarkables">Implémentation des états <em>bookmarkables</em></h2>
<p>Dans un premier temps, nous n’allons nous occuper que des <strong>états <em>bookmarkables</em></strong>, il s’agit de page <em>normales</em> accessible via un point d’entrée, en l’occurence, l’URL.</p>
<p>Premièrement, nous allons définir qu’un modèle est composé de valeurs <strong>constantes</strong>, celles dont nous aurons besoin sur toutes les pages et de valeurs <strong>variables</strong>, soit la description de la page sur laquelle nous nous trouvons. Concrètement, l’état courant.</p>
<pre class="elm"><code>type alias Model =
    { state : State
    , messages : List String
    , total : Int
    }
</code></pre>
<p><code class="elm rundoc-block" rundoc-language="elm">messages</code> correspondra à la liste de messages que l’on recevra (plus tard) et <code class="elm rundoc-block" rundoc-language="elm">total</code> au nombre de messages postés que l’on n’aurait pas vu (provenant d’autres clients). C’est dans <code class="elm rundoc-block" rundoc-language="elm">state</code> que l’on stockera la page courante.</p>
<p>Un état peut être deux choses :</p>
<ol>
<li>une page accessible ;</li>
<li>une erreur, si par exemple la page n’existe pas.</li>
</ol>
<pre class="elm"><code>type State
    = Routed Page.Page -- Si une page existe
    | Error Int String -- Si on doit remonter une erreur
</code></pre>
<p>Le type <code class="elm rundoc-block" rundoc-language="elm">Page.Page</code> est une union disciminée qui énumère toutes les pages statiques de l’application web :</p>
<pre class="elm"><code>type Page
    = Home
    | About Bool
    | Post { input : String }
</code></pre>
<p>L’avantage d’utiliser une union disciminée est qu’il ne faut pas normaliser le modèle de données d’une page. De ce fait, chaque page peut avoir son modèle spécialisé, ne contenant que les informations nécéssaires à son affichage. Les données communes à toutes les pages seront, elles, stockées dans le modèle, au même niveau que l’état courant.</p>
<p>Avec cette approche on peut déjà implémenter un mécanisme de vue via des fonctions :</p>
<pre class="elm"><code>-- Vue globale de l'application
global : Model -&gt; Html Message
global model =
    let 
       content = case model.state of 
           Error code message -&gt; [ error code message ]
           Routed content -&gt; page model content
    in
      div [ Attributes.class &quot;content&quot; ]
          [ h1 []
              [ text &quot;My page&quot; ]
          , nav [] [{- Ici on mettra le menu -}]
          , div [] content
          ]

-- Vue d'une erreur
error : Int -&gt; String -&gt; Html message
error code message =
    div [ Attributes.class &quot;error&quot; ]
        [ h2 [] [ text (toString code) ]
        , text message
        ]
</code></pre>
<p>Et on peut implémenter la fonction <code class="elm rundoc-block" rundoc-language="elm">page</code> qui affichera, au cas par cas, les informations nécéssaires à l’affichage de la page :</p>
<p><span id="renderpage"></span></p>
<pre class="elm"><code>page : Model -&gt; Page -&gt; List (Html Message)
page model page =
  case page of 
    Home -&gt; 
       {- Code ou fonction pour afficher la page Home -}
    About toggle -&gt; 
       {- Pareil pour About -}
    {- etc ... -}
</code></pre>
<p>Le module qui s’occupe de rendre le HTML peut se contenter de n’exposer que la fonction <code class="elm rundoc-block" rundoc-language="elm">global</code> car c’est au final la seule qui, en-dehors du module, sera réellement utile.</p>
<h3 id="implémentation-du-router">Implémentation du <em>router</em></h3>
<p>Maintenant que nous avons des éléments pour construire des pages ayant chacun leur modèle spécifique, nous allons pouvoir implémenter le <em>routing</em> à proprement parlé.</p>
<p>Pour cela, nous allons, un peu à la manière de <code class="elm rundoc-block" rundoc-language="elm">Page</code>, implémenter une union disciminée pour définir les routes. Comme une URL peut ne pas aboutir à une route existante, la notion de route potentiellement aboutissable peut être modelisée par un <code class="elm rundoc-block" rundoc-language="elm">Maybe Route</code>. L’implémentation du module de <em>routing</em> est une tâche assez récurrente, et ne fais rien de plus qu’exploiter les modules <a href="http://package.elm-lang.org/packages/elm-lang/navigation/latest">elm-lang/navigation</a> et <a href="http://package.elm-lang.org/packages/evancz/url-parser/latest/">evancz/url-parser</a>. On ajoute des fonctions utilitaires pour transformer une <code class="elm rundoc-block" rundoc-language="elm">Navigation.Location</code> en <code class="elm rundoc-block" rundoc-language="elm">Route</code> et de quoi générer rapidement les attributs HTML <strong>href</strong> pour pointer vers une route :</p>
<p>On défini d’abord les différentes routes possibles et ensuite le <em>parseur</em> qui servira à transformer une <code class="elm rundoc-block" rundoc-language="elm">Navigation.Location</code> en <code class="elm rundoc-block" rundoc-language="elm">Route</code> :</p>
<pre class="elm"><code>type Route
    = Home
    | About
    | Post


routeParser : Parser (Route -&gt; a) a
routeParser =
    Url.oneOf
        [ map Home (s &quot;&quot;)
        , map About (s &quot;about&quot;)
        , map Post (s &quot;publish-message&quot;)
        ]

</code></pre>
<p>Ensuite, on peut créer une fonction pour transformer une <code class="elm rundoc-block" rundoc-language="elm">Route</code> en chaîne de caractères qui sera utilisé dans la fonction pour générer l’attribut <strong>href</strong>. Si j’utilise <code class="elm rundoc-block" rundoc-language="elm">String.join</code> c’est pour anticiper le moment où j’aurai des URLs avec plusieurs membres (séparés par des <code class="elm rundoc-block" rundoc-language="elm">/</code>) :</p>
<pre class="elm"><code>toString : Route -&gt; String
toString route =
    let
        fragment =
            case route of
                Home -&gt; [ &quot;&quot; ]
                About -&gt; [ &quot;about&quot; ]
                Post -&gt; [ &quot;publish-message&quot; ]
    in  
      &quot;#/&quot; ++ (String.join &quot;/&quot; fragment)

href : Route -&gt; Attribute messsage
href route =
    Attributes.href (toString route)
</code></pre>
<p>On peut ensuite implémenter la fonction qui tâchera de produire notre route sur base de l’objet <code class="elm rundoc-block" rundoc-language="elm">Navigation.Location</code> :</p>
<pre class="elm"><code>fromLocation : Location -&gt; Maybe Route
fromLocation location =
    if String.isEmpty (location.hash) then
        Just Home
    else
        parseHash routeParser location
</code></pre>
<p>Même si le code est un peu récurrent, on défini les routes accessibles au moyen d’un <strong>Parseur</strong> dont on se servira pour <em>parser</em> la <em>location</em> courante.</p>
<p>En utilisant un <a href="http://package.elm-lang.org/packages/elm-lang/navigation/2.1.0/Navigation#program">programme issu du module Navigation</a> on pourra créer un écouteur qui a chaque changement dans l’URL, enverra un message contenant la route potentielle (via la fonction <code class="elm rundoc-block" rundoc-language="elm">fromLocation</code>). On peut donc créer un premier message :</p>
<pre class="elm"><code>type Message
    = Routing (Maybe Route) 
</code></pre>
<p>Maintenant que le changement d’URL <em>broadcast</em> un message, il faut le traiter dans la <strong>fonction de rafraîchissement</strong>.</p>
<p>J’ai décidé de créer une fonction dont le type est <code class="elm rundoc-block" rundoc-language="elm">Model -&gt; Maybe Route -&gt; Model</code> qui se chargera de construire le modèle adéquat pour une route donnée. De cette manière, je peux réutiliser cette fonction dans la phase <strong>d’initialisation</strong> de l’application :</p>
<pre class="elm"><code>doRouting : Model -&gt; Maybe Route -&gt; Model
doRouting model potentialRoute =
    case potentialRoute of
        Nothing -&gt;
            { model | state = 
                Error 404 &quot;The route does not exists&quot; 
            }
        Just route -&gt;
            case route of
                Home -&gt;  
                  { model | state = Routed Page.Home }
                About -&gt; 
                  { model | state = Routed (Page.About False) }
                Post -&gt;  
                  { model 
                     | total = 0
                     , state = 
                          Routed (Page.Post { input = &quot;&quot; }) 
                  }
</code></pre>
<p>Globalement, je me contente de lancer une erreur si jamais la route n’existe pas et je me contente chaque fois de modifier le membre <code class="elm rundoc-block" rundoc-language="elm">state</code> de mon modèle (sauf dans le cas de <code class="elm rundoc-block" rundoc-language="elm">Post</code>, mais nous reviendrons sur ce point plus tard).</p>
<p>Je peux maintenant modifier le membre <code class="elm rundoc-block" rundoc-language="elm">init</code> de mon programme pour qu’il charge, au démarrage de l’application, la route adéquate, et donc qu’il génère le modèle que l’on attend :</p>
<pre class="elm"><code>init : Navigation.Location -&gt; ( Model, Cmd Message )
init location =
    let
        route = fromLocation location
        model = { 
           messages = []
         , state = Routed Page.Home
         , total = 0 
        }
    in ( doRouting model route, Cmd.none )
</code></pre>
<p>Ensuite, il suffit de s’occuper de la fontion de rafraîchissement, dont le travail sera simplement d’utiliser la fonction <code class="elm rundoc-block" rundoc-language="elm">doRouting</code>, comme dans la fonction <code class="elm rundoc-block" rundoc-language="elm">init</code> :</p>
<pre class="elm"><code>update : Message -&gt; Model -&gt; ( Model, Cmd Message )
update message model =
    case message of
        Routing potentialRoute -&gt;
            (doRouting model potentialRoute, Cmd.none)
</code></pre>
<h3 id="utilisation-du-router">Utilisation du <em>router</em></h3>
<p>Nous avons maintenants des <strong>états bookmarkables</strong>, même si on pourra se plaindre de la redondance des définitions (notamment entre <code class="elm rundoc-block" rundoc-language="elm">Page</code> et <code class="elm rundoc-block" rundoc-language="elm">Route</code>) et du fait qu’il faille modifier la fonction <code class="elm rundoc-block" rundoc-language="elm">doRouting</code> et les vues pour ajouter des nouvelles pages, le compilateur nous aide en nous soulignant les cas de correspondance de motifs non-exhaustive (c’est en partie pour ça qu’il vaut mieux, dans la mesure du possible, <strong>éviter les captures générales</strong> via <code class="elm rundoc-block" rundoc-language="elm">_ -&gt;</code>. Cependant, parfois, il est compliqué de s’en passer.</p>
<p>Nous pouvons rapidement ajouter un menu dans notre vue globale, c’est très facile à mettre en place grâce à la fonction <code class="elm rundoc-block" rundoc-language="elm">Router.href</code> :</p>
<pre class="elm"><code>global : Model -&gt; Html Message
global model =
    let 
       content = case model.state of 
           Error code message -&gt; [ error code message ]
           Routed content -&gt; page model content
    in
      div [ Attributes.class &quot;content&quot; ]
          [ h1 []
              [ text &quot;My Page&quot; ]
          , nav []
              [ a [ Router.href Router.Home ] [ text &quot;Home&quot; ]
              , a [ Router.href Router.About ] [ text &quot;About&quot; ]
              , a [ Router.href Router.Post ]
                  [ text 
                     -- Ici on affiche le nombre 
                     -- de messages reçus depuis
                     -- la dernière visite
                     ( &quot;Post a  message (&quot; 
                       ++ (toString model.total) 
                       ++ &quot;)&quot;) 
                   ]
              ]
          , div [] (fragment model)
          ]
</code></pre>
<p>Ce que l’on retiendra principalement de l’implémentation des états <em>bookmarkables</em> pour le développement de notre application est :</p>
<ul>
<li><p>on joint chacune des pages possibles via un type qui énumère les pages possibles permettant de spécialiser le modèle de chaque page ;</p></li>
<li><p>l’ ajout de pages imposent (hélas) un réplicat entre les routes exposées et l’énumération des pages ;</p></li>
<li><p>la notion d’état <em>bookmarkable</em> est offerte par la fonction <code class="elm rundoc-block" rundoc-language="elm">init</code> qui démarre la session de navigation dans l’application en fonction de la route courante.</p></li>
</ul>
<h2 id="implémentation-des-actions-ponctuelles">Implémentation des actions ponctuelles</h2>
<p>En plus de pouvoir “formellement” changer d’URL, on voudrait pouvoir effectuer des actions <strong>ponctuelles</strong>, qui elles, seraient des <strong>états <em>non-bookmarkables</em></strong>. Cela permettrait, entre autre, de faire des modifications relatives à une page que l’on est en train de visiter, par exemple “ouvrir” ou “fermer” une <code class="elm rundoc-block" rundoc-language="elm">&lt;div&gt;</code> ou modifier l’état général (le modèle) de l’application.</p>
<p>Prenons par exemple la page <code class="elm rundoc-block" rundoc-language="elm">About</code> qui est paramétrée par un booléen, imaginons que nous voudrions qu’en fonction de la valeur de ce paramètre, un fragment de HTML soit affiché ou non à l’écran.</p>
<p>Voyons une fonction que nous aurions pu appeler dans notre <a href="#renderpage">fonction</a> pour rendre les vues des pages :</p>
<pre class="elm"><code>about : Bool -&gt; List (Html Message)
about toggle =
    let
        toggler =
            if toggle then &quot;opened&quot;
            else &quot;closed&quot;
    in
        [ button [] [ text &quot;Toggle content&quot; ] -- THE button ;)
        , div [ Attributes.class &quot;page&quot; ]
            [ h2 [] [ text &quot;About&quot; ]
            , text &quot;This is an &quot;
            , span [ Attributes.class toggler ] [ text &quot;ugly&quot; ]
            , text &quot; experience !&quot;
            ]
        ]
</code></pre>
<p>Actuellement, grâce à l’organisation de notre code, l’utilisation du booléen est déjà prise en charge, cependant, il faut implémenter un message pour demander <strong><strong>explicitement</strong></strong> de changer la valeur du booléen.</p>
<h3 id="les-patches">Les patches</h3>
<p>Concrètement, ce que l’on veut faire ici, c’est simplement <strong>modifier un modèle</strong>, un <strong>patch</strong> n’est donc rien de plus qu’une fonction qui prend en argument un modèle et renvoie la version modifiée de ce modèle. On peut donc étendre nos messages pour prendre en charge les patches :</p>
<pre class="elm"><code>type Message
    = Routing (Maybe Route)
    | Patch (Model -&gt; ( Model, Cmd Message ))
</code></pre>
<p>L’ajout d’un nouveau message implique la transformation de la fonction de rafraîchissement. Lorsque l’on reçoit un message <code class="elm rundoc-block" rundoc-language="elm">Patch f</code>, il suffit d’appliquer la fonction au modèle courant (car on <strong>délègue</strong> au <em>patch</em> la responsabilité de savoir s’il peut s’appliquer au modèle en cours ou non) :</p>
<pre class="elm"><code>update : Message -&gt; Model -&gt; ( Model, Cmd Message )
update message model =
    case message of
        Routing potentialRoute -&gt;
            (doRouting model potentialRoute, Cmd.none)

        Patch apply_patch -&gt;
            apply_patch model
</code></pre>
<p>Pour reprendre notre exemple précédent, voici une implémentation possible pour changer le modèle de notre page <code class="elm rundoc-block" rundoc-language="elm">About</code> :</p>
<pre class="elm"><code>toggleAbout : Model -&gt; ( Model, Cmd message )
toggleAbout model =
   let 
       state = case model.state of 
          Routed (Page.About t) -&gt; Routed (Page.About (not t))
          _ -&gt; Error 401 &quot;Unauthorized case&quot;
    in ({ model | state = state}, Cmd.none)
</code></pre>
<p>Une fois que la fonction de <em>patch</em> est créée, on peut s’en servir assez facilement dans la <strong>vue</strong> :</p>
<pre class="elm"><code>button [onClick (Patch toggleAbout)] [ text &quot;Toggle content&quot; ]
</code></pre>
<p>Si je ne <em>wrappe</em> pas directement le résultat de ma fonction dans le constructeur <code class="elm rundoc-block" rundoc-language="elm">Patch</code>, c’est en partie pour pouvoir m’en reservir dans d’autres contextes que les patches. Cependant, je n’ai pas réellement d’avis sur ce qu’il serait mieux de faire, donc je tâche de prôner la réutilisabilité.</p>
<p>Le seul problème “cosmétique” à cette méthode est qu’elle est oblige à traiter un cas <strong>trivial</strong> et donc, par soucis de confort, à faire une clause universelle, donc, potentiellement, occulter certaines erreurs. Même si cette approche ne me satisfait pas totalement, je pense qu’en considérant qu’un <em>patch</em> ne concerne à priori qu’une seule page, ce n’est pas dramatique.</p>
<p>En opposition, le fait de pouvoir traiter “plusieurs cas” de modèle dans un <em>patch</em> peut aussi être intéressant dans certains cas de figures.</p>
<p>Actuellement, je pense que le fait que Elm <strong>occulte certains aspects liés à</strong> <strong>l’algèbre des types</strong> implique qu’il n’existe (pour peu que l’on respecte ce type d’architecture) pas de solution satisfaisante. Cependant, si vous avez des idées ou pistes, n’hésitez pas à laisser un commentaire ou à m’écrire un courrier électronique !</p>
<h3 id="des-patches-plus-complexes">Des patches plus complexes</h3>
<p>On se rend vite compte que les patches fonctionnent très bien avec des émetteurs d’événements comme <code class="elm rundoc-block" rundoc-language="elm">onClick</code>, mais pourrait-on les utiliser avec, par exemple, l’émetteur <code class="elm rundoc-block" rundoc-language="elm">onInput</code> (<a href="https://guide.elm-lang.org/architecture/user_input/forms.html">préconisé</a> pour le traitement de données liés à des champs de textes) ? Observons le modèle de la page <code class="elm rundoc-block" rundoc-language="elm">Post</code> :</p>
<pre class="elm"><code>type Page
    = Home
    | About Bool
    | Post { input : String }
</code></pre>
<p>Le type de <code class="elm rundoc-block" rundoc-language="elm">onInput</code> est : <code class="elm rundoc-block" rundoc-language="elm">(String -&gt; msg) -&gt; Attribute msg</code>, pour cela, nous allons passer à la fonction <code class="elm rundoc-block" rundoc-language="elm">onInput</code> une fonction dont l’argument unique sera la chaine de caractères demandée par l’événement, dans notre fonction anonyme, nous pourrons passer cette chaine à notre patch :</p>
<pre class="elm"><code>input
   [ Attributes.placeholder &quot;A message&quot;
   , Attributes.value state.input
   , onInput (\s -&gt; Patch (recordInput s))
   ] []
</code></pre>
<p>Voyons, par exemple, comment sauvegarder dans le modèle de la page <code class="elm rundoc-block" rundoc-language="elm">Post</code> le contenu du champ de texte :</p>
<pre class="elm"><code>recordInput : String -&gt; Model -&gt; ( Model, Cmd message )
recordInput text model  =
   let 
       state = case model.state of 
          Routed (Page.Step state) -&gt;
              { model
                | state = 
                   Routed (Page.Step {state | input = text})    
              }
          _ -&gt; Error 401 &quot;Unauthorized case&quot;
    in ({ model | state = state}, Cmd.none)
</code></pre>
<p>Même si l’on peut se plaindre d’une certaine redondance et, peut être, d’un excès de verbosité, les patches <strong>offrent une manière commode de gérer les mutations</strong> <strong>de modèles</strong> et si on les avait remplacés par une succession de messages, il aurait tout de même fallu gérer les modèles “pertinents” au cas par cas, de ce fait, ils me semblent tout indiquer pour mettre en place facilement une notion d’action ponctuelle qui n’implique pas la modification de la fonction de rafraîchissement.</p>
<p>De plus, ils n’empiètent pas sur le <em>router</em>, ils semblent donc convenir relativement bien pour des <strong>applications hybrides</strong>, qui imposent l’usage d’un <em>router</em> et d’actions ponctuelles.</p>
<h2 id="les-messages-discrets">Les messages discrets</h2>
<p>Le mécanisme de <a href="https://www.elm-tutorial.org/en/03-subs-cmds/01-subs.html">Souscriptions</a> de Elm est largement suffisant pour implémenter les <strong>messages discrets</strong>, de plus, ils se marient très bien avec les <a href="https://hexdocs.pm/phoenix/channels.html">channels</a> de Elixir. De plus, comme généralement, le nombre de messages discrets étant pris en charge par une application de taille normale est assez limité (au contraire des actions ponctuelle), il n’y a, à mon sens, rien de mal à les traiter au cas par cas. Cependant, si nous voulions traiter ces messages discrets de la même manière que nous traitons les patches, je peux proposer cette extension au type <code class="elm rundoc-block" rundoc-language="elm">Message</code> :</p>
<pre class="elm"><code>type Message
    = Routing (Maybe Route)
    | Patch (Model -&gt; ( Model, Cmd Message ))
    | Discrete (Chan -&gt; Model -&gt; ( Model, Cmd Message )) Chan

type Chan
    = Anonymous { body : String } -- I'm a stereotype !
    | Indentified { body: String, name: String }
</code></pre>
<p>(Dans cet exemple, j’utilise un <strong>port</strong> qui communique avec les channels de Phoenix).</p>
<p>Comme pour les routes, je <strong>sépare</strong> mes différents types de messages discrets au moyen d’une union discriminée, ce qui me permettra de traiter au cas par cas, dans mes fonctions équivalentes à des patches, les données que je reçois.</p>
<p>A la différence d’un patche normal, qui se contente, sur base d’un modèle, d’en produire un nouveau, cette fois, les messages discrets <strong>agissent comme la fonction de</strong> <strong>rafraîchissement</strong> de la Elm-architecture, ils joignent un message (de type <code class="elm rundoc-block" rundoc-language="elm">Chan</code>) et un modèle pour construire un nouvau modèle :</p>
<pre class="elm"><code>update : Message -&gt; Model -&gt; ( Model, Cmd Message )
update message model =
    case message of
        Routing potentialRoute -&gt;
            (doRouting model potentialRoute, Cmd.none)

        Patch apply_patch -&gt;
            apply_patch model

        Discrete apply_patch pub -&gt;
            apply_patch pub model
</code></pre>
<p>Implémentons maintenant un patch discret. Sans rentrer dans les détails (inintéressants) de la partie serveur, l’idée est que quand un client arrive sur l’application, il joint un channel quelconque et sur la page <code class="elm rundoc-block" rundoc-language="elm">Post</code>, il a la possiblité d’envoyer un message anonyme qui sera <em>broadcasté</em> à toutes les personnes qui se trouvent sur la page au même moment.</p>
<p>Dans le modèle, on garde la liste des messages (des chaines de caractères) qui ont été publiées durant la session de navigation de l’utilisateur et on compte le nombre de message qu’il reçoit pendant qu’il n’est pas sur la page <code class="elm rundoc-block" rundoc-language="elm">Post</code>. Donc, à chaque fois qu’il se rend sur la page <code class="elm rundoc-block" rundoc-language="elm">Post</code>, ce compteur de message est remis à zéro :</p>
<pre class="elm"><code>handleMessage : Chan -&gt; Model -&gt; ( Model, Cmd message )
handleMessage channel model =
    let
        offset =
            case model.state of
                Routed (Page.Post _) -&gt; 0
                _ -&gt; 1
    in
        case channel of
            Anonymous message -&gt;
                ( { model
                    | messages = message.body :: model.messages
                    , total = model.total + offset
                  } , Cmd.none
                )
            _ -&gt; (model, Cmd.none)       
</code></pre>
<p>On peut maintenant ajouter ça aux <code class="elm rundoc-block" rundoc-language="elm">subscriptions</code> de l’application. On convertit les résultats que l’on obtient (potentiellement) <strong>en continu</strong> via des <strong>ports</strong> en <strong>messages discrets</strong> :</p>
<pre class="elm"><code>subscriptions : Model -&gt; Sub Message
subscriptions model =
  Sub.batch [ 
     Ports.subAnonymMessage
       (\s -&gt; Discrete handleMessage (Anonymous s)) 
  ]
</code></pre>
<p>Par soucis d’extensibilité, j’utilise <a href="http://package.elm-lang.org/packages/elm-lang/core/5.1.1/Platform-Sub#batch"><code class="elm rundoc-block" rundoc-language="elm">Sub.batch</code></a> dans le cas où je devrais manipuler plusieurs signaux discrets différents.</p>
<p>Comme l’entièreté de la logique des patches discrets repose sur les souscriptions, il ne faut que rajouter des <em>producers</em> et des traitement dans le <em>batch</em> pour être capable de manipuler n’importe quel type de signaux (<em>Workers</em>, <em>Websockets</em> ou encore des <em>BroadcastChannels</em>).</p>
<h1 id="conclusion">Conclusion</h1>
<p>Dans cet article, nous avons couvert certains éléments d’interactions utiles pour la conception d’une application web moderne. Comme je l’ai répété à de multiple reprises tout au long de l’article, je ne propose pas une architecture inclue dans la Elm-architecture et le code présenté ici n’est, hélas, pas générique.</p>
<p>Le manque d’expressivité du système de types et des modules<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> prive le code général d’une certaine forme de réutilisabilité. Même si je le regrette un peu, je dois avouer que c’est loin d’être dramatique et que le langage et son <em>framework</em> me sont très agréables !</p>
<p>En organisant son code entre des modules (qui unissent des fonctionnalités sémantiquement proches), et en n’hésitant pas à ne pas aplatir les modèles et les messages on peut facilement approcher l’idée derrière les <em>composants</em> que l’on nous vend à toutes les sauces et le passage par la fonction de rafraîchissement permet <strong>d’unifier l’ensemble</strong> <strong>des composants</strong> (qui sont en fait la conjonction d’un type, et d’une interface).</p>
<p>Quoi qu’il en soit, j’attend avec impatience la sortie de Elm <code class="elm rundoc-block" rundoc-language="elm">0.19</code> et même si, à mon sens, il serait sûrement possible de faire quelques améliorations au niveau du système de types et de modules (mais à quel prix ?), Elm reste très utilisable en production et très agréable à utiliser. Comme l’ensemble des concepts qu’il manipule sont exposé dans la Elm-architecture, sa <em>learn-curve</em> est très souple ce qui fait de Elm un langage accessible, y comprit pour les gens n’ayant pas un très gros bagage en programmation fonctionnelle statiquement typée.</p>
<p>Le compilateur est une véritable aide pour les phase de <em>refactoring</em> et pour tâcher de traiter un maximum de cas dans toutes les membranes du programme.</p>
<p>Même si actuellement, je ne suis pas satisfait à 100% des premières conclusions que j’amène pour construire une application web hybride en Elm, l’écriture de cet article m’a réellement donné envie de me plonger plus en profondeur dans le langage pour, pourquoi pas, aboutir sur un autre article plus technique.</p>
<p>J’espère que cet article aura tout de même pu mettre en lumière certaines idées qui me semblent pertinentes. Et je résumerai l’ensemble de cet article par quelques points :</p>
<ul>
<li>ne stockez que ce dont vous avez besoin dans vos modèles ;</li>
<li>n’hésitez pas à dénormaliser vos modèles et normaliser vos messages ;</li>
<li>profitez au maximum de la Elm-architecture (par exemple pour les souscriptions).</li>
</ul>
<p>Pour finir, Elm c’est vraiment cool et facile à appréhender (pour preuve, la partie la plus dure a été, selon moi, la mise en place de <a href="https://webpack.github.io/">Webpack</a>) !</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Attention, ce n’est évidemment pas une critique, mais une constatation en comparaison avec des langages comme OCaml ou Haskell. En aucun cas je considère ce manque d’expressivité comme une faiblesse sur tous les autres aspects. Je suis cependant conscient que la tournure de phrase peut être prise comme une critique virulente… d’où cette note en bas de page …<a href="#fnref1">↩</a></p></li>
</ol>
</div>
  <div id="eof-article"></div>
  <div class="article-footer">
    Cet article est terminé ! <br /> Si jamais vous avez des remarques, n'hésitez pas à écrire un <strong>commentaire</strong> ou à <a href="https://github.com/xvw/blog">contribuer</a>
    <div id="disqus_thread"></div>
    <script>
      var disqus_config = function () {
      this.page.url = "https://xvw.github.io/posts/elm-webapp.html";
      this.page.identifier = "posts/elm-webapp.org";
      };
      (function() { // DON'T EDIT BELOW THIS LINE
        var d = document,
          s = d.createElement('script');
        s.src = 'https://xvw-blog-1.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</main>
<script src="../js/hl.js"></script>
<script>
  hljs.initHighlightingOnLoad();
  __useResumable("/posts/elm-webapp.html");
</script>

  <footer>
    <div>
      <div>
        <a href="http://webring.xxiivv.com/#random" target="_blank">
          <img src="../images/icon.white.svg" />
        </a>
      </div>
      <div>
        <span>Merci</span>
        <a href="https://jaspervdj.be/hakyll/">Hakyll</a>
        <span>, tu es un superbe générateur ❤</span>
      </div>
    </div>
  </footer>
</body>

</html>
