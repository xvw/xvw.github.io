<!doctype html>
<html>
  <head><meta charset="utf-8"><meta name="keywords" content="programming, ocaml, modules" /><meta name="description" content="Using the module system open and include statements to reproduce common import patterns from other languages" /><meta name="generator" content="YOCaml" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:title" content="OCaml, modules, and import schemes" /><meta name="og:title" content="OCaml, modules, and import schemes" /><meta name="twitter:description" content="Using the module system open and include statements to reproduce common import patterns from other languages" /><meta name="og:description" content="Using the module system open and include statements to reproduce common import patterns from other languages" /><meta name="og:site_name" content="xvw.lol" /><meta name="og:type" content="article" /><meta name="og:article:published_time" content="2025-06-30 00:00:00" /><meta name="og:article:section" content="programming" /><meta name="og:article:tag" content="programming" /><meta name="og:article:tag" content="ocaml" /><meta name="og:article:tag" content="modules" /><meta name="author" content="xvw, Xavier Van de Woestyne" /><meta name="twitter:site" content="@vdwxv" /><meta name="twitter:creator" content="@vdwxv" /><meta name="og:profile:username" content="xvw" /><meta name="og:profile:first_name" content="Xavier" /><meta name="og:profile:last_name" content="Van de Woestyne" /><meta name="og:image" content="https://xvw.lol/images/xvw-cover.png" /><meta name="og:image:url" content="https://xvw.lol/images/xvw-cover.png" /><meta name="og:image:type" content="image/png" /><meta name="og:image:width" content="1200" /><meta name="og:image:height" content="630" /><meta name="og:image:alt" content="Cover image xvw.lol" /><meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="/css/capsule.css" rel="stylesheet">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="me" href="https://x.com/vdwxv"><link rel="manifest" href="/site.webmanifest">
    <link rel="canonical" href="https://xvw.lol/en/articles/modules-import.html">
    <link rel="alternate" type="application/atom+xml" href="/en/atom.xml" />
    <title>xvw.lol - OCaml, modules, and import schemes</title>
  </head>
  <body>
    <header>
      <div id="header-content">
        <div><h3><a href="/">xvw.lol</a></h3></div>
        <div>
          <nav class="set breadcrumb">
            <a href="/">Fr</a>
            <a href="/en/">Index</a></nav>
        </div>
      </div>
    </header>
    <main>
      <div id="main-content" class="en-content"><h1>OCaml, modules, and import schemes</h1><div class="set publication-date"><time class="date-repr"
        data-prefix="published on"
        datetime="2025-06-30 00:00:00">
    2025-06-30
  </time></div><section class="origin">
  This article is a translation, the <a href="/pages/modules-import.html">original version is
  available here</a>.
</section><article class="synopsis"><p>The <a href="https://ocaml.org">OCaml</a> module system can be intimidating, and it typically involves the use of many keywords—for example, <code>open</code> and <code>include</code>, which allow importing definitions into a module. Since version OCaml <code>4.08</code>, the <code>open</code> primitive has been <em>generalized</em> to allow the opening of <strong>arbitrary module expressions</strong>. In this article, we’ll explore how to use this generalization to reproduce a common practice in other languages, what I somewhat pompously call <em>import strategies</em>, to describe patterns like <code>import {a, b as c} from K</code>, without relying on a (<em>sub-</em>)language dedicated specifically to importing.</p>
</article><section class="toc"><ul><li><a href="#importing-module-components" data-toc-target="importing-module-components">Importing Module Components</a><ul><li><a href="#module-opening" data-toc-target="module-opening">Module Opening</a><ul><li><a href="#local-module-opening" data-toc-target="local-module-opening">Local module opening</a></li></ul></li><li><a href="#module-inclusion" data-toc-target="module-inclusion">Module inclusion</a></li><li><a href="#opening-vs-inclusion-before-ocaml-408" data-toc-target="opening-vs-inclusion-before-ocaml-408">Opening VS Inclusion before OCaml 4.08</a></li><li><a href="#a-first-benefit" data-toc-target="a-first-benefit">A first benefit</a></li></ul></li><li><a href="#import-schemes" data-toc-target="import-schemes">Import Schemes</a><ul><li><a href="#unqualified-import" data-toc-target="unqualified-import">Unqualified Import</a></li><li><a href="#renamed-qualification" data-toc-target="renamed-qualification">Renamed Qualification</a><ul><li><a href="#presence-of-the-renamed-module" data-toc-target="presence-of-the-renamed-module">Presence of the renamed module</a></li><li><a href="#nested-renaming" data-toc-target="nested-renaming">Nested renaming</a></li></ul></li><li><a href="#selective-import" data-toc-target="selective-import">Selective Import</a><ul><li><a href="#selective-import-with-renaming" data-toc-target="selective-import-with-renaming">Selective import with renaming</a></li></ul></li><li><a href="#import-by-exclusion" data-toc-target="import-by-exclusion">Import by Exclusion</a><ul><li><a href="#empty-variant" data-toc-target="empty-variant">Empty Variant</a></li><li><a href="#function-suppression" data-toc-target="function-suppression">Function Suppression</a></li></ul></li></ul></li><li><a href="#type-anchoring" data-toc-target="type-anchoring">Type Anchoring</a></li><li><a href="#conclusion" data-toc-target="conclusion">Conclusion</a></li></ul></section><article><p>The generalization of <code>open</code> is documented in the paper <a href="https://www.cl.cam.ac.uk/~jdy22/papers/extending-ocamls-open.pdf"><em>&quot;Extending
OCaml's</em>
<code>open</code>&quot;</a>,
presented at the <a href="https://ocaml.org/workshops/ocaml-users-and-developers-workshop-2017">OCaml Workshop
2017</a>,
and implemented—in OCaml version <code>4.08</code>, in pull requests
<a href="https://github.com/ocaml/ocaml/pull/1506"><code>#1506</code></a> and
<a href="https://github.com/ocaml/ocaml/pull/2147"><code>#2147</code></a> (likely followed
by a few fixes after merging). This generalization greatly increases
the flexibility of the <code>open</code> construct, making it possible to use
various tricks to finely control the import of <em>module components</em>
into another module.</p>
<blockquote>
<p>Some of the techniques shown here are directly adapted from the
paper, which, beyond discussing implementation strategies, also
explores various use cases—though some of them fall outside the
scope of this article, as they don't relate to <em>import strategies</em>.</p>
</blockquote>
<p>It's likely that many of the <em>tricks</em> presented here won't become
<em>idiomatic</em> in OCaml codebases. In my view, their main purpose is to
highlight the increased flexibility of the <code>open</code> primitive, without
relying on a <strong>dedicated syntactic extension</strong> for importing
components—while also showcasing a few somewhat <em>far-fetched</em>
encodings... just for the sake of demonstration.</p>
<h2 id="importing-module-components"><a class="anchor" aria-hidden="true" href="#importing-module-components"></a>Importing Module Components</h2>
<p>When describing an OCaml program, one constructs collections of
modules that export components (types, <em>submodules</em>, exceptions, and
functions). It is therefore crucial to finely control their
accessibility from other modules. For this, we have two primitives —
<code>open</code> and <code>include</code> — whose difference is subtle. To clearly describe
the differences between these two primitives, we will base ourselves
on this (somewhat artificial) module, which we will use in the
following examples:</p>
<div class="side-by-side">
<pre><code><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>A</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>type</span><span class='ocaml-source'> </span><span class='ocaml-source'>a</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>T_a</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>a_a</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-integer'>1</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>a_b</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>T_a</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>B</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>    </span><span class='ocaml-keyword-other'>type</span><span class='ocaml-source'> </span><span class='ocaml-source'>b</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>T_b</span><span class='ocaml-source'>
</span><span class='ocaml-source'>    </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>b_a</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>T_b</span><span class='ocaml-source'>
</span><span class='ocaml-source'>    </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>b_b</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>T_a</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span></code></pre>
<pre><code><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>A</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>sig</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>type</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>a</span><span class='ocaml-source'> = T_a
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>a_a</span><span class='ocaml-source'> : int
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>a_b</span><span class='ocaml-source'> : a
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other-ocaml'>module</span><span class='ocaml-source'> B : </span><span class='ocaml-keyword-other-ocaml'>sig</span><span class='ocaml-source'>
</span><span class='ocaml-source'>    </span><span class='ocaml-keyword'>type</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>b</span><span class='ocaml-source'> = T_b
</span><span class='ocaml-source'>    </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>b_a</span><span class='ocaml-source'> : b
</span><span class='ocaml-source'>    </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>b_b</span><span class='ocaml-source'> : a
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span></code></pre>
</div>
<p>As you may notice, the implementation—and <em>de facto</em>, the signature —
of the module is not very interesting; it will only serve to
illustrate my point. What we want is to use, in a file <code>c.ml</code> (which
will denote the module <code>C</code>), the components described in <code>A</code>.</p>
<p>The first approach, and the most obvious one, is to use their full
names (a <strong>fully qualified</strong> call) by using the module <strong>path</strong>. For
example, let's create a pair of <code>int</code> and <code>A.a</code>:</p>
<pre><code><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>c_a</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-constant-language-capital-identifier'>A</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>a_a</span><span class='ocaml-keyword-other-ocaml punctuation-comma punctuation-separator'>,</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>A</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-constant-language-capital-identifier'>B</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>b_b</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span></code></pre>
<p>However, using fully qualified paths can sometimes be <em>tedious</em> (or
even completely unreadable). That’s why we’ll look at how to <strong>import
components from module <code>A</code> into module <code>C</code></strong>. However, since the goal
of this article is not to be a tutorial on <code>open</code> and <code>include</code>, but
to explore generalized opens to describe import schemes, we won’t go
into detail about these two features, which are already thoroughly
documented in the <a href="https://v2.ocaml.org/releases/5.1/htmlman/index.html">language
manual</a> — in the
sections dedicated to
<a href="https://v2.ocaml.org/releases/5.1/htmlman/moduleexamples.html">modules</a>,
<a href="https://v2.ocaml.org/releases/5.1/htmlman/overridingopen.html">overriding through
opens</a>,
and <a href="https://v2.ocaml.org/releases/5.1/htm">generalized opens</a></p>
<h3 id="module-opening"><a class="anchor" aria-hidden="true" href="#module-opening"></a>Module Opening</h3>
<p>The <code>open</code> primitive allows <em>importing</em> the components of a module
into another module, <strong>without re-exporting</strong> them in the current
module. For example, let's use <code>open</code> to rewrite the function <code>c_a</code>:</p>
<div class="side-by-side">
<pre><code><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>A</span><span class='ocaml-source'>
</span><span class='ocaml-source'>
</span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>c_a</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-source'>a_a</span><span class='ocaml-keyword-other-ocaml punctuation-comma punctuation-separator'>,</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>B</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>b_b</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span></code></pre>
<pre><code><span class='ocaml-keyword-other'>val</span><span class='ocaml-source'> </span><span class='ocaml-source'>c_a</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>int</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>*</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>A</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>a</span><span class='ocaml-source'>
</span></code></pre>
</div>
<p>As we can see from the (<em>inferred</em>) signature, it <strong>does not export</strong>
the <em>components</em> of module <code>A</code> and references the type <code>a</code> by its full
path. It would also be possible to open <code>A.B</code> using <code>open A.B</code> or even
<code>open B</code> (since <code>A</code> is already open).</p>
<p>In the same way that it's possible to open modules in the
<em>implementation</em>, it's also possible to open modules in the
<em>signature</em>, allowing shorter paths when referring to types (or
modules).</p>
<h4 id="local-module-opening"><a class="anchor" aria-hidden="true" href="#local-module-opening"></a>Local module opening</h4>
<p>The opening cases we previously observed were <strong>global</strong> to the module
in which they were invoked, which can be somewhat restrictive when you
want to open multiple modules, exposing, for example, arithmetic
operators. Fortunately, it's possible to open <strong>at the expression
level</strong>, in two different ways:</p>
<ul>
<li>
<p><code>let open Module in ...</code> opens the module <em>locally</em> — lexically
scoped — within the following expression block. This is very useful
when you want to open a module only within a function;</p>
</li>
<li>
<p><code>Module.(...)</code> opens the module — also lexically scoped — only
within the parentheses. This is very useful when you want to open a
module just within a single expression. For example, imagine the
<code>Float</code> module exposes a submodule <code>Infix</code> providing the usual
arithmetic operators; you could describe a floating-point operation
like this: <code>let x = Float.Infix.(1.2 + 3.14 + 1.68)</code>.</p>
</li>
</ul>
<p>The absence of local opening can be very limiting. For example, the
language <a href="https://fsharp.org/"><code>F#</code></a> only allows <a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/import-declarations-the-open-keyword">global
openings</a>,
which makes defining operators in a dedicated module cumbersome. This
encourages the use of <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading">operator
overloading</a>
(or even <a href="https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/statically-resolved-type-parameters">Statically Resolved Type
Parameters</a>),
sometimes resulting in considerable complexity.</p>
<h3 id="module-inclusion"><a class="anchor" aria-hidden="true" href="#module-inclusion"></a>Module inclusion</h3>
<p>The <code>include</code> primitive is very similar to the <code>open</code> primitive except
that it — as its name suggests — includes the contents of the targeted
module into the body of the module where it is called. For example, if
we had used <code>include</code> instead of <code>open</code> in our previous example, let’s
observe the impact on the inferred signature:</p>
<div class="side-by-side">
<pre><code><span class='ocaml-keyword-other'>include</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>A</span><span class='ocaml-source'>
</span><span class='ocaml-source'>
</span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>c_a</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-source'>a_a</span><span class='ocaml-keyword-other-ocaml punctuation-comma punctuation-separator'>,</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>B</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>b_b</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span></code></pre>
<pre><code><span class='ocaml-keyword-other'>type</span><span class='ocaml-source'> </span><span class='ocaml-source'>a</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>A</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>a</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>T_a</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>val</span><span class='ocaml-source'> </span><span class='ocaml-source'>a_a</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>int</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>val</span><span class='ocaml-source'> </span><span class='ocaml-source'>a_b</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-source'>a</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>B</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>A</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-constant-language-capital-identifier'>B</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>val</span><span class='ocaml-source'> </span><span class='ocaml-source'>c_a</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>int</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>*</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>A</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>a</span><span class='ocaml-source'>
</span></code></pre>
</div>
<p>Even though the signature <em>varies slightly</em> from the one we defined
earlier — there are some subtleties regarding the propagation of
<strong>type and module equalities</strong>, described in the section <a href="https://v2.ocaml.org/releases/5.1/htmlman/moduletypeof.html">&quot;Recovering
the type of a
module&quot;</a>,
related to
<a href="https://discuss.ocaml.org/t/extend-existing-module/1389/7">strengthening</a>
— we can see that the contents of module <code>A</code> have been <em>included</em>,
<em>added</em> to module <code>C</code>. Unlike opening, it is <strong>not possible to do
local inclusion</strong>, which makes perfect sense because <strong>inclusion at a
local level would have exactly the same effect as opening</strong>.</p>
<p>From my personal experience, I generally identify two specific use
cases for using <code>include</code>:</p>
<ul>
<li>
<p>Extending an existing module (for example, adding a function to the
<code>List</code> module within my project, or to extend the standard library);</p>
</li>
<li>
<p>Including submodules within a parent module. For example, it is
quite common that within a module, there are operators (or <a href="https://v2.ocaml.org/releases/5.1/htmlman/bindingops.html#start-section">binding
operators</a>)
which are often <em>confined</em> in dedicated submodules (usually <code>Infix</code>
and <code>Syntax</code>). For API reasons, re-exporting them at the <em>parent
module</em> level can be a good idea. This is, in fact, <a href="https://github.com/xvw/preface/blob/master/lib/preface_specs/indexed_functor.mli#L72">intensively
used in
Preface</a>.</p>
</li>
</ul>
<p>Inclusions are a powerful tool for extension, but also for code
sharing, and there is <strong>much to say</strong> because it often involves
<em>substitution</em>, <em>destructive substitution</em>, or <em>strengthening</em>, which
would require writing a dedicated article!</p>
<h3 id="opening-vs-inclusion-before-ocaml-408"><a class="anchor" aria-hidden="true" href="#opening-vs-inclusion-before-ocaml-408"></a>Opening VS Inclusion before OCaml <code>4.08</code></h3>
<p>Before the merge of the proposal for <strong>generalizing opens</strong>, there was
a <strong>significant</strong> difference in the usage of <code>open</code> versus <code>include</code>:
the parameter each primitive accepted.</p>
<ul>
<li>
<p><code>open</code> took a <a href="https://v2.ocaml.org/releases/4.07/htmlman/names.html#module-path">module
path</a>,
for example: <code>A</code> or even <code>A.B.C</code> ;</p>
</li>
<li>
<p><code>include</code> took <a href="https://v2.ocaml.org/releases/4.07/htmlman/modules.html#module-expr">a module
expression</a>,
for example: paths like <code>A</code> or <code>A.B.C</code>, but also functor
applications like <code>F(X)</code>, modules constrained by signatures <code>(M : S)</code>, or directly the module body <code>struct ... end</code>.</p>
</li>
</ul>
<p>This difference in flexibility involved rather cumbersome workarounds
to achieve the same level of expressiveness for <code>open</code> compared to
<code>include</code>. Indeed, to allow <code>open</code> to work with functor applications
or constraints, it was necessary to use intermediate modules.</p>
<p>In the case of using a path, the two calls are — in terms of
expressiveness — identical, because a path can also be a module
expression:</p>
<div class="side-by-side">
<pre><code><span class='ocaml-keyword-other'>include</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>A</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-constant-language-capital-identifier'>B</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-constant-language-capital-identifier'>C</span><span class='ocaml-source'>
</span></code></pre>
<pre><code><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>A</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-constant-language-capital-identifier'>B</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-constant-language-capital-identifier'>C</span><span class='ocaml-source'>
</span></code></pre>
</div>
<p>However, as soon as we try to open somewhat more complex cases,
natively supported by <code>include</code>, we quickly had to introduce
intermediate modules:</p>
<div class="side-by-side">
<pre><code><span class='ocaml-keyword-other'>include</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>F</span><span class='ocaml-source'>(</span><span class='ocaml-constant-language-capital-identifier'>X</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>include</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-constant-language-capital-identifier'>M</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>S</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>include</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>x</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-integer'>10</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span></code></pre>
<pre><code><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>A</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>F</span><span class='ocaml-source'>(</span><span class='ocaml-constant-language-capital-identifier'>X</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>A</span><span class='ocaml-source'>
</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>B</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>S</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>M</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>B</span><span class='ocaml-source'>
</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>C</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>x</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-integer'>10</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>C</span><span class='ocaml-source'>
</span></code></pre>
</div>
<p>Even if at first glance it may not seem dramatic, introducing
intermediate modules requires not exporting them in the signature of
the module that opens them (in its <code>mli</code> or signature). Additionally,
although <code>open</code> and <code>include</code> are often presented symmetrically, their
asymmetry in the parameters they take was regrettable. Fortunately,
since version <code>4.08</code> (released in June 2019), thanks to the
generalization of openings, <code>open</code> now accepts an arbitrary module
expression, just like <code>include</code>, allowing us to use it to mimic those
import schemes mentioned at the beginning of this article.</p>
<h3 id="a-first-benefit"><a class="anchor" aria-hidden="true" href="#a-first-benefit"></a>A first benefit</h3>
<p>The fact that the <code>open</code> primitive can take arbitrary module
expressions offers a first benefit — <em>probably trivial if you like
writing your module signatures</em>: <strong>the definition of local
expressions</strong>. Indeed, opening a module does not export its contents,
so it is possible to very easily define non-exported top-level values
by defining them inside an <code>open struct ... end</code> expression. For
example:</p>
<div class="side-by-side">
<pre><code><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>x</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-integer'>10</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>y</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-integer'>20</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>z</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>x</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>+</span><span class='ocaml-source'> </span><span class='ocaml-source'>y</span><span class='ocaml-source'>
</span></code></pre>
<pre><code><span class='ocaml-keyword-other'>val</span><span class='ocaml-source'> </span><span class='ocaml-source'>z</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>int</span><span class='ocaml-source'>
</span></code></pre>
</div>
<p>The functions <code>x</code> and <code>y</code> are <strong>confined within an open block</strong>, so
they are not exported, which can be very useful when you want to
define values (types or modules) locally. Moreover, since <strong>a
structure can be constrained by a signature</strong>, it is also possible,
for example, to encapsulate shared mutable state within the local
open, <strong>preventing it from escaping the scope of its opening</strong>. Here
are two examples where it is impossible to modify the reference cell
without going through the exported combinators, the first using a
constraint, the second using nested local opens:</p>
<div class="side-by-side">
<pre><code><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>    </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>cell</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>ref</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-integer'>0</span><span class='ocaml-source'>
</span><span class='ocaml-source'>    </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>incr</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-unit'>()</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>cell</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>!</span><span class='ocaml-source'>cell</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>+</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-integer'>1</span><span class='ocaml-source'>
</span><span class='ocaml-source'>    </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>decr</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-unit'>()</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>cell</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>!</span><span class='ocaml-source'>cell</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-integer'>1</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'>
</span><span class='ocaml-source'>    </span><span class='ocaml-keyword-other'>sig</span><span class='ocaml-source'>
</span><span class='ocaml-source'>      </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>incr</span><span class='ocaml-source'> : unit -&gt; unit
</span><span class='ocaml-source'>      </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>decr</span><span class='ocaml-source'> : unit -&gt; unit
</span><span class='ocaml-source'>    </span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span></code></pre>
<pre><code><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'> 
</span><span class='ocaml-source'>    </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>cell</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>ref</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-integer'>0</span><span class='ocaml-source'> 
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>incr</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-unit'>()</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>cell</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>!</span><span class='ocaml-source'>cell</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>+</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-integer'>1</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>decr</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-unit'>()</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>cell</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>!</span><span class='ocaml-source'>cell</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-</span><span class='ocaml-source'> </span><span class='ocaml-constant-numeric-decimal-integer'>1</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span><span class='ocaml-source'>
</span></code></pre>
</div>
<p>Even though the classic approach used by an OCaml developer is to use
signatures for <strong>encapsulation</strong> concerns, when used as such, the
generalized module opening allows you to hide, in a relatively elegant
way, certain <em>boilerplate elements</em> necessary for building a module
(which should expose a public API via a signature).</p>
<p>Now that we have looked at <em>some examples</em> of using generalized
opening, let's see how it makes having a dedicated language for import
schemes <strong>questionably useful</strong>.</p>
<h2 id="import-schemes"><a class="anchor" aria-hidden="true" href="#import-schemes"></a>Import Schemes</h2>
<p>Since <strong>modularity</strong> has become a cornerstone of software design —
JavaScript, for example, has <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">layered many
proposals</a>
where the modularization and import strategy depends on the framework
or build system used — languages like
<a href="https://www.python.org/">Python</a> and
<a href="https://www.haskell.org/">Haskell</a> have introduced features similar
to OCaml's <code>open</code> primitive to import components into the current
module. Generally, these import directives form <em>a small language of
their own</em>, governed by specific rules and grammar. Since <code>open</code> has
been generalized in OCaml, it is possible to <em>encode</em> much of the
usual import patterns — even though some, like those proposed by
Haskell, may be somewhat verbose to encode.</p>
<p>For the example, we will use the following module as the import
target:</p>
<pre><code><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Foo</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>sig</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>x</span><span class='ocaml-source'> : int
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>y</span><span class='ocaml-source'> : string
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>z</span><span class='ocaml-source'> : char
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span></code></pre>
<p>However, there is an <strong>essential nuance</strong> regarding the notion of
<strong>qualified import</strong>: in Haskell, to use a module, it <strong>must be
imported</strong>, whereas in OCaml, it is the build system (compilation
scheme) that indicates whether a module is present or not. In our
various examples, we will assume that the module <code>Foo</code>, which we
described earlier, is present in our compilation scheme. Therefore,
for qualified imports — where terms are always prefixed by their
module path — no additional ceremony is necessary. It is important to
keep in mind that the tricks presented below can be combined to build
very specific (and probably unrealistic) import schemes, demonstrating
that with a bit of verbosity, the <em>language</em> approach still allows
more flexibility than a rigid import <em>DSL</em>.</p>
<h3 id="unqualified-import"><a class="anchor" aria-hidden="true" href="#unqualified-import"></a>Unqualified Import</h3>
<p>The first directive simply imports the definitions from <code>Foo</code> into the
current module, namely the functions <code>x</code>, <code>y</code>, and <code>z</code>:</p>
<div class="side-by-side">
<pre><code><span class='haskell-keyword-other'>import</span><span class='haskell-meta-import'> * from </span><span class='haskell-support-other-module'>Foo</span><span class='haskell-source'>
</span></code></pre>
<pre><code><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Foo</span><span class='ocaml-source'>
</span></code></pre>
</div>
<p>There is no subtlety here; importing all the terms exposed by <code>Foo</code>
simply consists of opening it. There isn't much more to say, as we are
not leveraging any particular language subtlety here.</p>
<h3 id="renamed-qualification"><a class="anchor" aria-hidden="true" href="#renamed-qualification"></a>Renamed Qualification</h3>
<p>Another common directive consists of renaming the module, for example,
importing <code>Foo</code> under the name <code>Bar</code> so that <code>Bar.x</code>, <code>Bar.y</code>, and
<code>Bar.z</code> are accessible in the module. For this, one can use
<a href="https://v2.ocaml.org/releases/5.1/htmlman/modulealias.html">type-level module
aliases</a>.</p>
<div class="side-by-side">
<pre><code><span class='haskell-keyword-other'>import</span><span class='haskell-meta-import'> </span><span class='haskell-support-other-module'>Foo</span><span class='haskell-meta-import'> </span><span class='haskell-keyword-other'>as</span><span class='haskell-meta-import'> </span><span class='haskell-support-other-module'>Bar</span><span class='haskell-source'>
</span></code></pre>
<pre><code><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Bar</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Foo</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span></code></pre>
</div>
<p>We use the <code>open struct ... end</code> construct to keep our alias hidden
from the module's public API. This ensures that the alias doesn’t leak
outside the module. However, if the module has an explicit signature,
this is less critical, as simply omitting <code>Bar</code> from the signature
will prevent it from being exposed.</p>
<h4 id="presence-of-the-renamed-module"><a class="anchor" aria-hidden="true" href="#presence-of-the-renamed-module"></a>Presence of the renamed module</h4>
<p>Using a <strong>module alias</strong> leaves the module <code>Foo</code> accessible, and in
some cases, we might want to make it inaccessible. The simplest
solution is to simply <em>empty the module</em> and, to clarify the error
related to its undesired use, we can add an
<a href="https://v2.ocaml.org/releases/5.1/htmlman/alerts.html#start-section">alert</a>
indicating that the module has been removed:</p>
<pre><code><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Bar</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Foo</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Foo</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'> </span><span class='ocaml-source'>[</span><span class='ocaml-keyword-operator-attribute'>@@</span><span class='ocaml-keyword-other-attribute'>alert</span><span class='ocaml-source'> </span><span class='ocaml-source'>erased</span><span class='ocaml-source'>]</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span></code></pre>
<p>Making the use of the module <code>Foo</code> within the current module
impossible by raising an alert.  However, since it is common practice
to provide module signatures — and thereby control the public API — you
will more often encounter renamings like: <code>module Bar = Foo</code>.
Furthermore, I am not convinced that restricting access to the
original module is truly problematic.</p>
<h4 id="nested-renaming"><a class="anchor" aria-hidden="true" href="#nested-renaming"></a>Nested renaming</h4>
<p>One might imagine renaming like this: <code>import Foo as Bar.Baz</code>, but
OCaml does not allow full path descriptions of the form <code>module Bar.Baz = Foo</code>. Instead, you need to describe the module nesting
hierarchy explicitly, like this, making the functions <code>Bar.Baz.x</code>,
<code>Bar.Baz.y</code>, and <code>Bar.Baz.z</code> available in the current module:</p>
<pre><code><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'> 
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Bar</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'> 
</span><span class='ocaml-source'>    </span><span class='ocaml-keyword-other'>module</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Baz</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Foo</span><span class='ocaml-source'> 
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'> 
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span></code></pre>
<p>Which, I admit, is a bit verbose, but if for some obscure reason you
want to rename an existing module using a composed path, you can do so
by explicitly declaring the module hierarchy.</p>
<h3 id="selective-import"><a class="anchor" aria-hidden="true" href="#selective-import"></a>Selective Import</h3>
<p>Sometimes, importing the <strong>entire</strong> module is overkill, and we only
want a few components exposed by it. That’s why it’s possible to
import just a part of a module. In this example, we want to import
only <code>x</code> and <code>y</code>:</p>
<div class="side-by-side">
<pre><code><span class='haskell-keyword-other'>import</span><span class='haskell-meta-import'> {x, y} from </span><span class='haskell-support-other-module'>Foo</span><span class='haskell-source'>
</span></code></pre>
<pre><code><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>x</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Foo</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>x</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>y</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Foo</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>y</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span></code></pre>
</div>
<p>Although this approach is also somewhat verbose, it imports only the
functions <code>x</code> and <code>y</code> into the current module. It’s possible to
simplify this syntax by using <em>tuples</em> and local openings:</p>
<pre><code><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>let</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-source'>x</span><span class='ocaml-keyword-other-ocaml punctuation-comma punctuation-separator'>,</span><span class='ocaml-source'> </span><span class='ocaml-source'>y</span><span class='ocaml-source'>)</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Foo</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>(</span><span class='ocaml-source'>x</span><span class='ocaml-keyword-other-ocaml punctuation-comma punctuation-separator'>,</span><span class='ocaml-source'> </span><span class='ocaml-source'>y</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span></code></pre>
<p>Alternatively, it is also possible to <strong>constrain the opening</strong> using
a signature, which requires specifying the types of the functions to
export:</p>
<pre><code><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-constant-language-capital-identifier'>Foo</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>sig</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>x</span><span class='ocaml-source'> : int
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>y</span><span class='ocaml-source'> : string </span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span></code></pre>
<p>Several proposals
(<a href="https://github.com/ocaml/ocaml/pull/10013"><code>#10013</code></a> and
<a href="https://github.com/ocaml/ocaml/issues/11558#issuecomment-1255946104"><code>#11558</code></a>)
have been made to enable the use of
<a href="https://v2.ocaml.org/releases/5.1/htmlman/bindingops.html#ss%3Aletops-punning"><em>let-punning</em></a>,
which would make the syntax less verbose. However, the first proposal
dropped punning for module members, and the second is still at the
issue stage.</p>
<h4 id="selective-import-with-renaming"><a class="anchor" aria-hidden="true" href="#selective-import-with-renaming"></a>Selective import with renaming</h4>
<p>Since the first two proposals leave the user in control of naming
(it’s just <em>function redefinition</em>), renaming can be trivially
integrated. In this example, we expose <code>x</code> and <code>new_y_name</code>, which
calls <code>Foo.y</code>:</p>
<div class="side-by-side">
<pre><code><span class='haskell-keyword-other'>import</span><span class='haskell-meta-import'> {x, y </span><span class='haskell-keyword-other'>as</span><span class='haskell-meta-import'> new_y_name} from </span><span class='haskell-support-other-module'>Foo</span><span class='haskell-source'>
</span></code></pre>
<pre><code><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>let</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-source'>x</span><span class='ocaml-keyword-other-ocaml punctuation-comma punctuation-separator'>,</span><span class='ocaml-source'> </span><span class='ocaml-source'>new_y_name</span><span class='ocaml-source'>)</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Foo</span><span class='ocaml-keyword-other-ocaml punctuation-other-period punctuation-separator'>.</span><span class='ocaml-source'>(</span><span class='ocaml-source'>x</span><span class='ocaml-keyword-other-ocaml punctuation-comma punctuation-separator'>,</span><span class='ocaml-source'> </span><span class='ocaml-source'>y</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span></code></pre>
</div>
<p>Unsurprisingly, renaming is quite straightforward. However, if we
wanted to use the signature-based approach, it would require a bit
more trickery by combining an <code>open</code> with an <code>include</code>:</p>
<pre><code><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>    </span><span class='ocaml-keyword-other'>include</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Foo</span><span class='ocaml-source'>
</span><span class='ocaml-source'>    </span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>new_y_name</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>y</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>sig</span><span class='ocaml-source'>
</span><span class='ocaml-source'>    </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>x</span><span class='ocaml-source'> : int
</span><span class='ocaml-source'>    </span><span class='ocaml-keyword'>val</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>new_y_name</span><span class='ocaml-source'> : string </span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>)</span><span class='ocaml-source'>
</span></code></pre>
<p>However, this last proposal is so verbose that it becomes somewhat
irrational — especially compared to the previous one — and I imagine
it’s the kind of code you’ll never see — or at least never want to see
— in a regular codebase. That said, even though it’s heavy, I find it
still quite clearly demonstrates <strong>how it is possible to compose the
different constructions and tools we’ve seen earlier</strong>.</p>
<h3 id="import-by-exclusion"><a class="anchor" aria-hidden="true" href="#import-by-exclusion"></a>Import by Exclusion</h3>
<p>Haskell has a somewhat special import modifier that I hesitated to
mention for a long time because I had no idea how to implement it. But
once again, thanks to the invaluable help of
<a href="https://github.com/Octachron">@octachron</a> and
<a href="https://github.com/xhtmlboi">@xhtmlboi</a>, who both gave me roughly the
same solution, here it is. This modifier allows importing an entire
module <strong>except</strong> for a list of components. In this example, <code>x</code> and
<code>y</code> will be imported because we import <strong>the whole <code>Foo</code> module</strong>,
except for the function <code>z</code>.</p>
<pre><code><span class='haskell-keyword-other'>import</span><span class='haskell-meta-import'> </span><span class='haskell-support-other-module'>Foo</span><span class='haskell-meta-import'> hidding </span><span class='haskell-meta-declaration-exports'>(</span><span class='haskell-entity-name-function'>z</span><span class='haskell-meta-declaration-exports'>)</span><span class='haskell-source'>
</span></code></pre>
<p>OCaml does not natively support constructing <strong>intersections</strong> or
<strong>differences</strong> of modules. The solution proposed by
<a href="https://github.com/Octachron">@octachron</a> and
<a href="https://github.com/xhtmlboi">@xhtmlboi</a> relies on function rewriting
combined with the use of an alert, in a way somewhat similar to what
we did to exclude a renamed module. However, before examining their
solution, let's take a brief detour into the <strong>empty variant</strong>.</p>
<h4 id="empty-variant"><a class="anchor" aria-hidden="true" href="#empty-variant"></a>Empty Variant</h4>
<p>In OCaml, it is possible to define a sum type with no constructors
using <a href="https://v2.ocaml.org/releases/5.1/htmlman/emptyvariants.html#start-section"><strong>the empty
variant</strong></a>,
which essentially allows you to <em>describe unrepresentable values</em>. To
define it, you simply create a sum type with an empty branch (which,
<strong>important</strong>, is not the <a href="https://en.wikipedia.org/wiki/Bottom_type">bottom
type</a>, denoted <code>⊥</code>):</p>
<pre><code><span class='ocaml-keyword-other'>type</span><span class='ocaml-source'> </span><span class='ocaml-source'>empty</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>|</span><span class='ocaml-source'>
</span></code></pre>
<p>To convince yourself that the compiler can reject cases containing a
value of type <code>empty</code>, you can easily experiment with pattern
matching. In the example below, the compiler raises no warnings
because the patterns are exhaustive. Since it's impossible to
construct a value of type <code>empty</code> (except by cheating, for instance
using sorcery like the infamous <code>Obj.magic</code> function), we can <em>refute</em>
handling the error case:</p>
<pre><code><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>f</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-storage-type'>'a</span><span class='ocaml-keyword-other-ocaml punctuation-comma punctuation-separator'>,</span><span class='ocaml-source'> </span><span class='ocaml-source'>empty</span><span class='ocaml-source'>)</span><span class='ocaml-source'> </span><span class='ocaml-source'>result</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-storage-type'>'a</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>function</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>|</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Ok</span><span class='ocaml-source'> </span><span class='ocaml-source'>x</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-source'>x</span><span class='ocaml-source'>
</span></code></pre>
<p>But in our use case, it’s not the refutation that interests us, rather
the fact that it’s impossible to describe a value of type <code>empty</code>,
which we can leverage to exclude certain functions.</p>
<h4 id="function-suppression"><a class="anchor" aria-hidden="true" href="#function-suppression"></a>Function Suppression</h4>
<p>The solution proposed to me is to make the functions we want to remove
from the module <strong>impossible to call</strong>. To do this, we will first
create a <em>placeholder</em> function that we will use to override an
existing function:</p>
<pre><code><span class='ocaml-keyword-other'>type</span><span class='ocaml-source'> </span><span class='ocaml-source'>empty</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>|</span><span class='ocaml-source'>
</span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>expelled</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other-ocaml punctuation-other-colon punctuation'>:</span><span class='ocaml-source'> </span><span class='ocaml-source'>empty</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-support-type'>unit</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>fun</span><span class='ocaml-source'> </span><span class='ocaml-constant-language'>_</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>-&gt;</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-unit'>()</span><span class='ocaml-source'>
</span></code></pre>
<p>At first glance, our <code>expelled</code> function is impossible to call because
it requires a value of type <code>empty</code>, which cannot be
produced. Therefore, we can <strong>include the module we want to refine</strong>
and then <strong>override the functions we want to exclude</strong> with our
<code>expelled</code> function, associating them with an alert to clarify the
error triggered by using a removed function:</p>
<pre><code><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>include</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>Foo</span><span class='ocaml-source'>
</span><span class='ocaml-source'>  </span><span class='ocaml-keyword-other'>let</span><span class='ocaml-source'> </span><span class='ocaml-source'>(</span><span class='ocaml-source'>z</span><span class='ocaml-source'> </span><span class='ocaml-source'>[</span><span class='ocaml-keyword-operator-attribute'>@</span><span class='ocaml-keyword-other-attribute'>alert</span><span class='ocaml-source'> </span><span class='ocaml-source'>expelled</span><span class='ocaml-source'>]</span><span class='ocaml-source'>)</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-source'>expelled</span><span class='ocaml-source'>
</span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span></code></pre>
<p><em>And there you have it</em>, we can be pretty sure that using <code>z</code> will
cause a compilation error, and compiling a module that uses it will
raise a warning. However, the solution is far from perfect because it
<strong>does not remove</strong> the component from the module. To be honest, I've
<strong>very rarely</strong> found myself missing this feature natively. From my
perspective, selective importation usually suffices quite well.</p>
<h2 id="type-anchoring"><a class="anchor" aria-hidden="true" href="#type-anchoring"></a>Type Anchoring</h2>
<p>Before concluding this article,
<a href="https://github.com/Octachron">@octachron</a> pointed out to me the
partial asymmetry between <code>open</code> and <code>include</code> when it comes to
anonymous modules (i.e., module expressions <code>struct ... end</code>). This is
an issue I had already encountered theoretically, having attended the
May 2023 event of <a href="https://oups.frama.io/">OCaml Users in Paris</a> where
<a href="https://clement.blaudeau.net/">Clément Blaudeau</a> gave his talk
<a href="https://www.irill.org/videos/OUPS/2023-05/blaudeau.html"><em>Retrofitting OCaml
Modules</em></a>,
which was a summary of his paper <a href="https://inria.hal.science/hal-03526068/file/main.pdf"><em>OCaml modules: formalization,
insights and
improvements</em></a>.</p>
<p>Since <code>open</code> does not export the opened components, without
associating an explicit signature, some expressions cannot be
typed. For example:</p>
<pre><code><span class='ocaml-keyword-other'>open</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>struct</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>type</span><span class='ocaml-source'> </span><span class='ocaml-source'>t</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>A</span><span class='ocaml-source'> </span><span class='ocaml-keyword-other'>end</span><span class='ocaml-source'>
</span><span class='ocaml-keyword'>let</span><span class='ocaml-source'> </span><span class='ocaml-entity-name-function-binding'>x</span><span class='ocaml-source'> </span><span class='ocaml-keyword-operator'>=</span><span class='ocaml-source'> </span><span class='ocaml-constant-language-capital-identifier'>A</span><span class='ocaml-source'>
</span></code></pre>
<p>In this example, the type <code>t</code> (and its constructor <code>A</code>) is present in
the current scope; however, since it is not exported, it is impossible
to correctly type <code>x</code>. If the module had a signature, one could easily
realize that there is no acceptable type for <code>x</code> and that one should
either change the <code>open</code> directive or avoid exporting <code>x</code>. This issue
is known as <strong>type anchoring</strong>, which is extensively described in the
paper cited at the beginning of this section.</p>
<h2 id="conclusion"><a class="anchor" aria-hidden="true" href="#conclusion"></a>Conclusion</h2>
<p>I sincerely believe that in daily OCaml use, we very rarely encounter
such needs. The goal of this article was essentially to show how to
use certain primitives related to the module system, alongside the
generalized <code>open</code> feature, to demonstrate that having expressive and
composable primitives allows one to reproduce, sometimes trivially
(and sometimes less so), common import patterns found in other
programming languages. There are probably other <em>fun</em> encodings —
likely based on <em>functors</em> — so don’t hesitate to share them with me
so I can update this article!</p>
<p>To conclude, I would add that even though I proudly <em>boasted</em> that
programming this way in OCaml is uncommon, the existence of packages
like <a href="https://ocaml.org/p/ppx_import/latest">ppx_import</a> or
<a href="https://github.com/johnyob/ppx-open">ppx_open</a> shows that some
syntactic sugar wouldn’t hurt—especially for selective imports.</p>
</article>

</div>
    </main>
    <footer>
      <div id="footer-content">
        <div>
          <section>
            <h3>Ring.muhokama.fun</h3>
            <p>
              This website if part of the
              <a href="https://ring.muhokama.fun">Muhokama webring</a>.
              I invite you to browse it!
            </p>
            <nav class="set">
              <a class="btn" href="https://ring.muhokama.fun/u/xvw/pred">
                predecessor
              </a>
              <a class="btn" href="https://ring.muhokama.fun/u/xvw/succ">
                successor
              </a>
            </nav>
          </section>
          <section>
            <h3>Diffusion</h3>
            <p>
              Generator's <a href="https://github.com/xvw/capsule">source code</a>
              is released under the
              <a href="https://opensource.org/license/mit">
                MIT license</a>
             and the content is released (<i>unless mention</i>) under
              <a href="https://creativecommons.org/licenses/by-sa/4.0/">
                CC BY-SA license</a>.
            </p>
            <nav class="set">
              <a class="btn" href="https://github.com/xvw/capsule/blob/main/content/en/articles/modules-import.md">
                page source
              </a>
            </nav>
          </section>
          <section>
            <h3>Feeds</h3>
            <nav class="set svg-light">
              <a href="/en/atom.xml"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Rss</title><path d="M19.199 24C19.199 13.467 10.533 4.8 0 4.8V0c13.165 0 24 10.835 24 24h-4.801zM3.291 17.415c1.814 0 3.293 1.479 3.293 3.295 0 1.813-1.485 3.29-3.301 3.29C1.47 24 0 22.526 0 20.71s1.475-3.294 3.291-3.295zM15.909 24h-4.665c0-6.169-5.075-11.245-11.244-11.245V8.09c8.727 0 15.909 7.184 15.909 15.91z"/></svg></a><a rel="me" href="https://bsky.app/profile/xvw.lol"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Bluesky</title><path d="M12 10.8c-1.087-2.114-4.046-6.053-6.798-7.995C2.566.944 1.561 1.266.902 1.565.139 1.908 0 3.08 0 3.768c0 .69.378 5.65.624 6.479.815 2.736 3.713 3.66 6.383 3.364.136-.02.275-.039.415-.056-.138.022-.276.04-.415.056-3.912.58-7.387 2.005-2.83 7.078 5.013 5.19 6.87-1.113 7.823-4.308.953 3.195 2.05 9.271 7.733 4.308 4.267-4.308 1.172-6.498-2.74-7.078a8.741 8.741 0 0 1-.415-.056c.14.017.279.036.415.056 2.67.297 5.568-.628 6.383-3.364.246-.828.624-5.79.624-6.478 0-.69-.139-1.861-.902-2.206-.659-.298-1.664-.62-4.3 1.24C16.046 4.748 13.087 8.687 12 10.8Z"/></svg></svg></a><a rel="me" href="https://x.com/vdwxv"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>X</title><path d="M18.901 1.153h3.68l-8.04 9.19L24 22.846h-7.406l-5.8-7.584-6.638 7.584H.474l8.6-9.83L0 1.154h7.594l5.243 6.932ZM17.61 20.644h2.039L6.486 3.24H4.298Z"/></svg></a><a rel="me" href="https://merveilles.town/@xvw"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Mastodon</title><path d="M23.268 5.313c-.35-2.578-2.617-4.61-5.304-5.004C17.51.242 15.792 0 11.813 0h-.03c-3.98 0-4.835.242-5.288.309C3.882.692 1.496 2.518.917 5.127.64 6.412.61 7.837.661 9.143c.074 1.874.088 3.745.26 5.611.118 1.24.325 2.47.62 3.68.55 2.237 2.777 4.098 4.96 4.857 2.336.792 4.849.923 7.256.38.265-.061.527-.132.786-.213.585-.184 1.27-.39 1.774-.753a.057.057 0 0 0 .023-.043v-1.809a.052.052 0 0 0-.02-.041.053.053 0 0 0-.046-.01 20.282 20.282 0 0 1-4.709.545c-2.73 0-3.463-1.284-3.674-1.818a5.593 5.593 0 0 1-.319-1.433.053.053 0 0 1 .066-.054c1.517.363 3.072.546 4.632.546.376 0 .75 0 1.125-.01 1.57-.044 3.224-.124 4.768-.422.038-.008.077-.015.11-.024 2.435-.464 4.753-1.92 4.989-5.604.008-.145.03-1.52.03-1.67.002-.512.167-3.63-.024-5.545zm-3.748 9.195h-2.561V8.29c0-1.309-.55-1.976-1.67-1.976-1.23 0-1.846.79-1.846 2.35v3.403h-2.546V8.663c0-1.56-.617-2.35-1.848-2.35-1.112 0-1.668.668-1.67 1.977v6.218H4.822V8.102c0-1.31.337-2.35 1.011-3.12.696-.77 1.608-1.164 2.74-1.164 1.311 0 2.302.5 2.962 1.498l.638 1.06.638-1.06c.66-.999 1.65-1.498 2.96-1.498 1.13 0 2.043.395 2.74 1.164.675.77 1.012 1.81 1.012 3.12z"/></svg></a><a rel="me" href="https://github.com/xvw"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Github</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><a href="/feeds.html">Other feeds (FR)</a>
            </nav>
          </section><section>
            <h3>States</h3>
            <p>
              <strong>
                190
                logs
              </strong>
              for a period of
              <strong>20 days</strong>,
              <strong>17 hours</strong>,
              <strong>53 minutes</strong> et
              <strong>47 seconds</strong>.
              <br />
              <a href="/activity.html">Activity (FR)</a>
            </p>
          </section></div>
        <div>
          <div class="set svg-light">
            <a href="https://ocaml.org"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>OCaml</title><path d="M12.178 21.637c-.085-.17-.187-.524-.255-.676-.067-.135-.27-.506-.37-.625-.22-.253-.27-.27-.338-.608-.12-.574-.405-1.588-.76-2.296-.187-.372-.49-.677-.761-.947-.236-.236-.777-.624-.878-.607-.895.169-1.166 1.046-1.587 1.739-.237.388-.473.71-.66 1.115-.167.371-.151.793-.439 1.115a2.952 2.952 0 00-.624 1.097c-.034.084-.101.929-.186 1.131l1.318-.084c1.233.085.877.557 2.787.456l3.022-.1a5.376 5.376 0 00-.27-.71zM20.96 1.539H3.023A3.02 3.02 0 000 4.56v6.587c.44-.152 1.047-1.08 1.25-1.3.337-.389.405-.895.574-1.2.389-.709.456-1.215 1.334-1.215.406 0 .575.1.845.473.186.253.523.743.675 1.064.186.371.474.86.609.962.1.068.185.136.27.17.135.05.253-.051.354-.12.118-.1.17-.286.287-.556.17-.39.339-.827.44-.997.169-.27.236-.608.422-.76.27-.236.641-.253.743-.27.557-.118.81.27 1.08.507.186.168.423.49.609.91.135.339.304.661.388.846.068.185.237.49.338.86.101.322.337.575.44.744 0 0 .152.406 1.03.778a7.505 7.505 0 00.81.286c.39.135.76.12 1.233.068.338 0 .524-.49.676-.878.084-.237.185-.895.236-1.081.05-.185-.085-.32.034-.49.135-.186.22-.203.287-.439.17-.523 1.114-.54 1.655-.54.456 0 .389.44 1.149.287.439-.085.86.05 1.318.185.388.102.76.22.98.473.134.17.489.997.134 1.031.033.033.067.118.118.151-.085.322-.422.085-.625.051-.253-.05-.44 0-.693.118-.439.187-1.063.17-1.452.49-.32.271-.32.861-.473 1.2 0 0-.422 1.063-1.317 1.722-.237.17-.692.574-1.672.726-.44.068-.86.068-1.318.05-.22-.016-.438-.016-.658-.016-.136 0-.575-.017-.558.034l-.05.119a.6.6 0 00.033.169c.017.1.017.185.034.27 0 .185-.017.388 0 .574.017.388.17.743.186 1.148.017.44.236.913.456 1.267.085.135.203.152.254.32.067.186 0 .406.033.609.118.794.355 1.638.71 2.364v.017c.439-.067.895-.236 1.47-.32 1.063-.153 2.532-.085 3.478-.17 2.399-.22 3.7.98 5.844.49V4.562a3.045 3.045 0 00-3.04-3.023zm-8.951 14.187c0-.034 0-.034 0 0zm-6.47 2.769c.17-.372.271-.778.406-1.15.135-.354.337-.86.693-1.046-.05-.05-.744-.068-.929-.085a7.406 7.406 0 01-.608-.084 22.976 22.976 0 01-1.15-.236c-.22-.051-.979-.322-1.13-.39-.39-.168-.642-.658-.93-.607-.185.034-.37.101-.49.287-.1.152-.134.423-.202.608-.084.203-.22.405-.32.608-.238.354-.626.676-.795 1.03-.033.085-.05.169-.084.254v4.07c.202.034.405.068.624.135 1.69.456 2.095.49 3.75.304l.152-.017c.118-.27.22-1.165.304-1.435.067-.22.153-.39.187-.591.033-.203 0-.406-.017-.59-.034-.491.354-.661.54-1.065z"/></svg></a>
            <span>Proudly generated by
              <a href="https://github.com/xhtmlboi/yocaml">YOCaml
            </a></span>
          </div>
          <div class="svg-cc-light">
            <a href="https://creativecommons.org/licenses/by-sa/4.0/"><svg role="img" viewBox="5.5 -3.5 64 64" xmlns="http://www.w3.org/2000/svg"><g><circle cx="37.785" cy="28.501" r="28.836"/><path d="M37.441-3.5c8.951,0,16.572,3.125,22.857,9.372c3.008,3.009,5.295,6.448,6.857,10.314
	  c1.561,3.867,2.344,7.971,2.344,12.314c0,4.381-0.773,8.486-2.314,12.313c-1.543,3.828-3.82,7.21-6.828,10.143
	  c-3.123,3.085-6.666,5.448-10.629,7.086c-3.961,1.638-8.057,2.457-12.285,2.457s-8.276-0.808-12.143-2.429
	  c-3.866-1.618-7.333-3.961-10.4-7.027c-3.067-3.066-5.4-6.524-7-10.372S5.5,32.767,5.5,28.5c0-4.229,0.809-8.295,2.428-12.2
	  c1.619-3.905,3.972-7.4,7.057-10.486C21.08-0.394,28.565-3.5,37.441-3.5z M37.557,2.272c-7.314,0-13.467,2.553-18.458,7.657
	  c-2.515,2.553-4.448,5.419-5.8,8.6c-1.354,3.181-2.029,6.505-2.029,9.972c0,3.429,0.675,6.734,2.029,9.913
	  c1.353,3.183,3.285,6.021,5.8,8.516c2.514,2.496,5.351,4.399,8.515,5.715c3.161,1.314,6.476,1.971,9.943,1.971
	  c3.428,0,6.75-0.665,9.973-1.999c3.219-1.335,6.121-3.257,8.713-5.771c4.99-4.876,7.484-10.99,7.484-18.344
	  c0-3.543-0.648-6.895-1.943-10.057c-1.293-3.162-3.18-5.98-5.654-8.458C50.984,4.844,44.795,2.272,37.557,2.272z M37.156,23.187
	  l-4.287,2.229c-0.458-0.951-1.019-1.619-1.685-2c-0.667-0.38-1.286-0.571-1.858-0.571c-2.856,0-4.286,1.885-4.286,5.657
	  c0,1.714,0.362,3.084,1.085,4.113c0.724,1.029,1.791,1.544,3.201,1.544c1.867,0,3.181-0.915,3.944-2.743l3.942,2
	  c-0.838,1.563-2,2.791-3.486,3.686c-1.484,0.896-3.123,1.343-4.914,1.343c-2.857,0-5.163-0.875-6.915-2.629
	  c-1.752-1.752-2.628-4.19-2.628-7.313c0-3.048,0.886-5.466,2.657-7.257c1.771-1.79,4.009-2.686,6.715-2.686
	  C32.604,18.558,35.441,20.101,37.156,23.187z M55.613,23.187l-4.229,2.229c-0.457-0.951-1.02-1.619-1.686-2
	  c-0.668-0.38-1.307-0.571-1.914-0.571c-2.857,0-4.287,1.885-4.287,5.657c0,1.714,0.363,3.084,1.086,4.113
	  c0.723,1.029,1.789,1.544,3.201,1.544c1.865,0,3.18-0.915,3.941-2.743l4,2c-0.875,1.563-2.057,2.791-3.541,3.686
	  c-1.486,0.896-3.105,1.343-4.857,1.343c-2.896,0-5.209-0.875-6.941-2.629c-1.736-1.752-2.602-4.19-2.602-7.313
	  c0-3.048,0.885-5.466,2.658-7.257c1.77-1.79,4.008-2.686,6.713-2.686C51.117,18.558,53.938,20.101,55.613,23.187z"/></g></svg><svg role="img" viewBox="5.5 -3.5 64 64" xmlns="http://www.w3.org/2000/svg"><g><circle cx="37.637" cy="28.806" r="28.276"/>
 <g><path d="M37.443-3.5c8.988,0,16.57,3.085,22.742,9.257C66.393,11.967,69.5,19.548,69.5,28.5c0,8.991-3.049,16.476-9.145,22.456
 C53.879,57.319,46.242,60.5,37.443,60.5c-8.649,0-16.153-3.144-22.514-9.43C8.644,44.784,5.5,37.262,5.5,28.5
 c0-8.761,3.144-16.342,9.429-22.742C21.101-0.415,28.604-3.5,37.443-3.5z M37.557,2.272c-7.276,0-13.428,2.553-18.457,7.657
 c-5.22,5.334-7.829,11.525-7.829,18.572c0,7.086,2.59,13.22,7.77,18.398c5.181,5.182,11.352,7.771,18.514,7.771
 c7.123,0,13.334-2.607,18.629-7.828c5.029-4.838,7.543-10.952,7.543-18.343c0-7.276-2.553-13.465-7.656-18.571
 C50.967,4.824,44.795,2.272,37.557,2.272z M46.129,20.557v13.085h-3.656v15.542h-9.944V33.643h-3.656V20.557
 c0-0.572,0.2-1.057,0.599-1.457c0.401-0.399,0.887-0.6,1.457-0.6h13.144c0.533,0,1.01,0.2,1.428,0.6
 C45.918,19.5,46.129,19.986,46.129,20.557z M33.042,12.329c0-3.008,1.485-4.514,4.458-4.514s4.457,1.504,4.457,4.514
 c0,2.971-1.486,4.457-4.457,4.457S33.042,15.3,33.042,12.329z"/>
 </g></g></svg><svg role="img" viewBox="5.5 -3.5 64 64" xmlns="http://www.w3.org/2000/svg"><g><circle cx="36.944" cy="28.631" r="29.105"/><g>
<path d="M37.443-3.5c8.951,0,16.531,3.105,22.742,9.315C66.393,11.987,69.5,19.548,69.5,28.5c0,8.954-3.049,16.457-9.145,22.514
			     C53.918,57.338,46.279,60.5,37.443,60.5c-8.649,0-16.153-3.143-22.514-9.429C8.644,44.786,5.5,37.264,5.5,28.501
			     c0-8.723,3.144-16.285,9.429-22.685C21.138-0.395,28.643-3.5,37.443-3.5z M37.557,2.272c-7.276,0-13.428,2.572-18.457,7.715
			     c-5.22,5.296-7.829,11.467-7.829,18.513c0,7.125,2.59,13.257,7.77,18.4c5.181,5.182,11.352,7.771,18.514,7.771
			     c7.123,0,13.334-2.609,18.629-7.828c5.029-4.876,7.543-10.99,7.543-18.343c0-7.313-2.553-13.485-7.656-18.513
			     C51.004,4.842,44.832,2.272,37.557,2.272z M23.271,23.985c0.609-3.924,2.189-6.962,4.742-9.114
			     c2.552-2.152,5.656-3.228,9.314-3.228c5.027,0,9.029,1.62,12,4.856c2.971,3.238,4.457,7.391,4.457,12.457
			     c0,4.915-1.543,9-4.627,12.256c-3.088,3.256-7.086,4.886-12.002,4.886c-3.619,0-6.743-1.085-9.371-3.257
			     c-2.629-2.172-4.209-5.257-4.743-9.257H31.1c0.19,3.886,2.533,5.829,7.029,5.829c2.246,0,4.057-0.972,5.428-2.914
			     c1.373-1.942,2.059-4.534,2.059-7.771c0-3.391-0.629-5.971-1.885-7.743c-1.258-1.771-3.066-2.657-5.43-2.657
			     c-4.268,0-6.667,1.885-7.2,5.656h2.343l-6.342,6.343l-6.343-6.343L23.271,23.985L23.271,23.985z"/></g></g></svg></a>
          </div>
        </div>
      </div>
    </footer>
  </body>
</html>
