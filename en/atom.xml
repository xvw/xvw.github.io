<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://xvw.lol/articles.xml</id>
  <title type="text">xvw.articles</title>
  <subtitle type="text">English articles</subtitle>
  <generator uri="https://github.com/xhtmlboi/yocaml" version="2">YOCaml</generator>
  <updated>2025-08-13T00:00:00Z</updated>
  <author>
    <name>xvw, Xavier Van de Woestyne</name>
    <uri>https://xvw.lol</uri>
  </author>
  <entry>
    <id>https://xvw.lol/en/articles/why-ocaml.html</id>
    <title type="text">Why I chose OCaml as my primary language</title>
    <updated>2025-08-13T00:00:00Z</updated>
    <summary type="text">
      I started using the [OCaml](https://ocaml.org) language regularly around 2012, and since then, my interest and enthusiasm for this language have only grown. It has become my preferred choice for almost all my personal projects, and it has also influenced my professional choices.
Since 2014, I have been actively participating in public conferences dedicated to programming and software development, where I often express my enthusiasm for OCaml in ways that may be a bit over the top (but always passionate). This has earned me, in a friendly way, the nickname _OCaml evangelist_ — a title that, I admit, I find very flattering.
Moreover, I’m not alone in thinking this. Despite the common misconception that OCaml wouldn’t be a pragmatic choice for industry, major companies such as [Meta](https://engineering.fb.com/?s=ocaml), [Microsoft](https://www.microsoft.com/en-us/research/project/slam/?from=https://research.microsoft.com/en-us/projects/slam/&amp;type=exact), [Ahref](https://tech.ahrefs.com/tagged/ocaml), [Tarides](https://tarides.com), [OCamlPro](https://ocamlpro.com/), [Bloomberg](https://www.bloomberg.com/company?s=ocaml), [Docker](https://github.com/moby/vpnkit), [Janestreet](https://www.janestreet.com/technology/), [Citrix](https://xapi-project.github.io/), [Tezos](https://tezos.com), and [many others](https://ocaml.org/industrial-users) actively use it.
    </summary>
    <link href="https://xvw.lol/en/articles/why-ocaml.html" rel="alternate" title="Why I chose OCaml as my primary language"/>
    <category term="programming"/>
    <category term="ocaml"/>
    <category term="opinion"/>
  </entry>
  <entry>
    <id>https://xvw.lol/en/articles/tetra-master.html</id>
    <title type="text">The Hell of Tetra Master</title>
    <updated>2025-07-02T00:00:00Z</updated>
    <summary type="text">
      _Tetra Master_ is the optional card game in **Final Fantasy IX**. At first glance, it seems similar to _Triple Triad_ — the card game from Final Fantasy VIII. And while you can develop a general intuition for how to win, especially if you have strong cards, after playing over a hundred matches, I had to admit something: just playing the game and reading all the _in-game_ tutorials wasn’t enough to truly understand the rules. Eventually, I gave in and started looking things up to figure out what I was missing. The complete absence of **any actual rules** — whether in the game or the manual — left me utterly frustrated, which is what led me to write this article, illustrated in OCaml.
    </summary>
    <link href="https://xvw.lol/en/articles/tetra-master.html" rel="alternate" title="The Hell of Tetra Master"/>
    <category term="final-fantasy"/>
    <category term="game-design"/>
    <category term="videogame"/>
    <category term="ocaml"/>
  </entry>
  <entry>
    <id>https://xvw.lol/en/articles/modules-import.html</id>
    <title type="text">OCaml, modules, and import schemes</title>
    <updated>2025-06-30T00:00:00Z</updated>
    <summary type="text">
      The [OCaml](https://ocaml.org) module system can be intimidating, and it typically involves the use of many keywords—for example, `open` and `include`, which allow importing definitions into a module. Since version OCaml `4.08`, the `open` primitive has been *generalized* to allow the opening of **arbitrary module expressions**. In this article, we’ll explore how to use this generalization to reproduce a common practice in other languages, what I somewhat pompously call _import strategies_, to describe patterns like `import {a, b as c} from K`, without relying on a (_sub-_)language dedicated specifically to importing.
    </summary>
    <link href="https://xvw.lol/en/articles/modules-import.html" rel="alternate" title="OCaml, modules, and import schemes"/>
    <category term="programming"/>
    <category term="ocaml"/>
    <category term="modules"/>
  </entry>
  <entry>
    <id>https://xvw.lol/en/articles/oop-refl.html</id>
    <title type="text">Guarded methods in OCaml</title>
    <updated>2025-06-29T00:00:00Z</updated>
    <summary type="text">
      **Guarded methods** allow attaching **constraints** to the receiver (`self`) **only for certain methods**, thus allowing these methods to be called only if the receiver satisfies these constraints (these _guards_). [OCaml](https://ocaml.org) does not syntactically allow defining this kind of method _directly_. In this note, we will see how to encode them using a **type equality witness**.
    </summary>
    <link href="https://xvw.lol/en/articles/oop-refl.html" rel="alternate" title="Guarded methods in OCaml"/>
    <category term="programming"/>
    <category term="type"/>
    <category term="oop"/>
    <category term="ocaml"/>
    <category term="gadt"/>
  </entry>
</feed>