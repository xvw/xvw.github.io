<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://xvw.lol/articles.xml</id>
  <title type="text">xvw.articles</title>
  <subtitle type="text">English articles</subtitle>
  <generator uri="https://github.com/xhtmlboi/yocaml" version="2">YOCaml</generator>
  <updated>2025-07-02T00:00:00Z</updated>
  <author>
    <name>xvw, Xavier Van de Woestyne</name>
    <uri>https://xvw.lol</uri>
  </author>
  <entry>
    <id>https://xvw.lol/en/articles/tetra-master.html</id>
    <title type="text">The Hell of Tetra Master</title>
    <updated>2025-07-02T00:00:00Z</updated>
    <summary type="text">
      _Tetra Master_ is the optional card game in **Final Fantasy IX**. At first glance, it seems similar to _Triple Triad_ — the card game from Final Fantasy VIII. And while you can develop a general intuition for how to win, especially if you have strong cards, after playing over a hundred matches, I had to admit something: just playing the game and reading all the _in-game_ tutorials wasn’t enough to truly understand the rules. Eventually, I gave in and started looking things up to figure out what I was missing. The complete absence of **any actual rules** — whether in the game or the manual — left me utterly frustrated, which is what led me to write this article, illustrated in OCaml.
    </summary>
    <link href="https://xvw.lol/en/articles/tetra-master.html" rel="alternate" title="The Hell of Tetra Master"/>
    <category term="final-fantasy"/>
    <category term="game-design"/>
    <category term="videogame"/>
    <category term="ocaml"/>
  </entry>
  <entry>
    <id>https://xvw.lol/en/articles/modules-import.html</id>
    <title type="text">OCaml, modules, and import schemes</title>
    <updated>2025-06-30T00:00:00Z</updated>
    <summary type="text">
      The [OCaml](https://ocaml.org) module system can be intimidating, and it typically involves the use of many keywords—for example, `open` and `include`, which allow importing definitions into a module. Since version OCaml `4.08`, the `open` primitive has been *generalized* to allow the opening of **arbitrary module expressions**. In this article, we’ll explore how to use this generalization to reproduce a common practice in other languages, what I somewhat pompously call _import strategies_, to describe patterns like `import {a, b as c} from K`, without relying on a (_sub-_)language dedicated specifically to importing.
    </summary>
    <link href="https://xvw.lol/en/articles/modules-import.html" rel="alternate" title="OCaml, modules, and import schemes"/>
    <category term="programming"/>
    <category term="ocaml"/>
    <category term="modules"/>
  </entry>
  <entry>
    <id>https://xvw.lol/en/articles/oop-refl.html</id>
    <title type="text">Guarded methods in OCaml</title>
    <updated>2025-06-29T00:00:00Z</updated>
    <summary type="text">
      **Guarded methods** allow attaching **constraints** to the receiver (`self`) **only for certain methods**, thus allowing these methods to be called only if the receiver satisfies these constraints (these _guards_). [OCaml](https://ocaml.org) does not syntactically allow defining this kind of method _directly_. In this note, we will see how to encode them using a **type equality witness**.
    </summary>
    <link href="https://xvw.lol/en/articles/oop-refl.html" rel="alternate" title="Guarded methods in OCaml"/>
    <category term="programming"/>
    <category term="type"/>
    <category term="oop"/>
    <category term="ocaml"/>
    <category term="gadt"/>
  </entry>
</feed>