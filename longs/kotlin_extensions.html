<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="author" content="Xavier Van de Woestyne">
    
    
    <meta name="description" content="Kotlin, extensions et génériques: Quelques encodages farfelus avec les extensions.">
    
    <title>
      xvw - Kotlin, extensions et génériques  : Quelques encodages farfelus avec les extensions. 
    </title>
    <link rel="stylesheet" href="../css/fonts.css" />
    <link rel="stylesheet" href="../css/hl.css" />
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="alternate" type="application/atom+xml" title="xvw-planet" href="../atom.xml" />
    <script src="../facade.bc.js"></script>
  </head>
  <body>
    <header>
      <div class="container">
        <div>
          <div class="header-bar">
            <h1>Xavier Van de Woestyne</h1>
            
            <h2>Tentative</h2>
            
          </div>
        </div>
      </div>
    </header>
    <main>
      <div class="navbar">
        <nav class="container">
          <a href="../">Accueil</a>
          <a href="../tags.html">Tags</a>
          <a href="../longs.html">Articles</a>
          <a href="../projects.html">Projets</a>
          <a href="../galleries.html">Galeries</a>
          <a href="../journal.html">Activité</a>
        </nav>
      </div>
      <div class="main-block">
        <div id="resume-details" class="page-small-cover black-block small-refutable"></div>
<div class="container base-content uniq-content">
  <div class="qexp-metadata" id="story-qexp-metadata">
    <textarea data-planet-qexp="story">(:permaname "kotlin_extensions")
(:title "Kotlin, extensions et génériques")
(:synopsis "Quelques encodages farfelus avec les extensions.")
(:links
  (("Kotlin"
     (("Site officiel" "https://kotlinlang.org")
       ("Les extensions en Kotlin"
         "https://kotlinlang.org/docs/reference/extensions.html")))
    ("Les classes de types en Kotlin"
      (("Arrow-kt" "https://arrow-kt.io/")
        ("KEEP sur les typeclasses" "https://github.com/Kotlin/KEEP/pull/87")))))
(:content "external" #org "content/posts/kotlin-extension.org")
(:published true) (:category "programmation")
(:tags ("programmation" "kotlin" "extension" "types")) (:date #020D29)
(:kind #long)</textarea>
  </div>

  <div class="content-page">
    <div class="major-header">
      <div class="major-details">
        <h1>Kotlin, extensions et génériques</h1>
        <span class="synopsis">
          Quelques encodages farfelus avec les extensions.
        </span>
        <div>
          <span class="badge published">2020-04-29</span>
          <span class="badge">programmation</span>
        </div>
      </div>
    </div>
    <div class="major-content">
      <div class="long-text structured-text" id="roe-container">
        <blockquote>
<p>Depuis un peu plus d’un an, j’utilise quotidiennement le langage <a href="https://kotlinlang.org">Kotlin</a> pour mon activité professionnelle. En tant qu’étudiant, j’ai <strong>vraiment</strong> détesté utiliser le langage Java. Je le trouvais verbeux, peu expressif et imposant une collection de pratiques, les motifs de conceptions, que je trouvais compliqué. Heureusement, Kotlin est, selon moi, bien plus expressif et agréable à utiliser que son prédécesseur.</p>
<p>Kotlin apporte beaucoup d’innovations. Les couroutines, les familles scellées, un support décent des fonctions anonymes, les extensions et beaucoup d’autres, tout en permettant d’interopérer facilement avec Java (et donc le milliards d’outils peuplant son ecosystème). Ces apports font du langage un outil relativement agréable à utiliser. En complément, Kotlin bénéficie d’une communauté très large et très productive en bibliothèques, présentations, articles et tutoriels.</p>
<p>Dans cet article, je vous propose de découvrir une de ces nouveautés, les <strong>extensions</strong>, au travers d’un exemple plutôt réaliste, suivi d’exemples beaucoup moins utiles mais rigolos (enfin… je trouve) ! Comme évoqué, la communauté Kotlin étant très productive, il est possible que ces “techniques” soient déjà longuement expliquées dans d’autres articles… je suis “un peu” désolé pour mon manque d’originalité !</p>
</blockquote>
<p>Comme l’indique très précisemment <a href="https://kotlinlang.org/docs/reference/extensions.html">la section dédiée aux extensions</a> dans le manuel de Kotlin, ces dernières permettent d’étendre facilement une classe existante. Quand on ne bénéficie pas de mécanisme d’extension, il faut ruser pour étendre les fonctionnalité d’un objet, par exemple, en utilisant l’héritage (ce qui peut être très ennuyant quand la <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html">classe est finale</a>…), en utilisant des décorateurs ou en construisant une bibliothèque dont l’interface n’exposerait que des méthodes statiques (par exemple). Heureusement, les extensions permettent d’étendre les fonctionnalités d’une classe de manière homogène. Par exemple, je peux facilement, au moyen des extensions, ajouter dans mon <em>scope</em> une méthode <code class="sourceCode kotlin">String#emphasis</code> qui mettra le contenu de ma chaine en majuscule et lui ajoutera un point d’exclamation, pour marquer l’emphase !</p>
<div class="sourceCode" id="cb1" data-roe-kind="code" data-line-number="true"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">fun</span> <span class="fu">String</span>.<span class="fu">emphasis</span>() = </a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="st">&quot;${this.toUpperCase()} !&quot;</span></a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">fun</span> <span class="fu">main</span>() {</a>
<a class="sourceLine" id="cb1-5" title="5">    println(<span class="st">&quot;Hello World&quot;</span>.emphasis())</a>
<a class="sourceLine" id="cb1-6" title="6">}</a></code></pre></div>
<p>Le premier usage de ces extensions est… comme leur nom l’indique, d’étendre des classes existantes. Comme il s’agit de leur raison d’être principal, je ne vais pas m’étendre sur cet usage spécifique, la section qui leur est dédiée est claire et couvre tous les <em>edge-cases</em>. Commençons par un usage, de mon point de vue, très utile !</p>
<h2 id="préciser-le-receveur">Préciser le receveur</h2>
<p>Bien que les extensions offrent un moyen confortable d’étendre une classe déjà existante. Je trouve que leur usage va beaucoup plus loin. Quand on veut étendre une classe qui <em>est paramétrée</em>, il suffit de transporter ses génériques, comme lorsque l’on rédige une fonction générique <em>normale</em> :</p>
<div class="sourceCode" id="cb2" data-roe-kind="code" data-line-number="true"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">fun</span> &lt;<span class="dt">A</span>, <span class="dt">B</span>&gt; <span class="fu">List</span>&lt;<span class="dt">A</span>&gt;.<span class="fu">zipWith</span>(<span class="va">l</span>: <span class="dt">List</span>&lt;<span class="va">B</span>&gt;) : <span class="dt">List</span>&lt;<span class="dt">Pair</span>&lt;<span class="dt">A</span>, <span class="dt">B</span>&gt;&gt; =</a>
<a class="sourceLine" id="cb2-2" title="2">    mapIndexed { index, left -&gt;</a>
<a class="sourceLine" id="cb2-3" title="3">        <span class="kw">val</span> <span class="va">right</span> = l[index]</a>
<a class="sourceLine" id="cb2-4" title="4">        Pair(left, right)</a>
<a class="sourceLine" id="cb2-5" title="5">    }</a></code></pre></div>
<p>On observe que le type <code class="sourceCode kotlin">A</code>, qui normalement fait partie de la définition de la classe doit être transporté dans sa définition. <code class="sourceCode kotlin">A</code> étant un paramètre de type de fonction classique, il est possible de le fixer. Par exemple, définissons une fonction qui n’est disponible <strong>que</strong> pour les listes d’entiers :</p>
<div class="sourceCode" id="cb3" data-roe-kind="code" data-line-number="true"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">fun</span> <span class="fu">List</span>&lt;<span class="dt">Int</span>&gt;.<span class="fu">sumElements</span>() =</a>
<a class="sourceLine" id="cb3-2" title="2">    reduce { x, y -&gt; x + y }</a></code></pre></div>
<p>Même si ça peut sembler anodin, les extensions offrent plus de finesses dans la déclaration des receveurs. Observons tout de suite un cas un peu plus précis.</p>
<h3 id="le-cas-de-flatten">Le cas de <code class="sourceCode kotlin">flatten()</code></h3>
<p>Un des reproches souvent exprimé à l’encontre de la programmation orientée objets (statiquement typés) est l’incapacité d’exprimer certaines méthodes, notamment à cause du manque de contrôle sur le type du receveur habitant une classe. Par exemple, la méthode <code class="sourceCode kotlin">flatten()</code> dont le type serait <code class="sourceCode kotlin">T&lt;T&lt;A&gt;&gt; -&gt; T&lt;A&gt;</code>. Cette méthode est assez utile (notamment pour les <code class="sourceCode kotlin">List&lt;A&gt;</code> ou encore les <code class="sourceCode kotlin">Option&lt;A&gt;</code>). Prenons le cas de <strong>Option</strong>, qui est plus court à implémenter que des listes.</p>
<p>On voudrait exprimer, au moyen de classes, la présence ou l’absence de valeur, soit encoder l’équivalent du <code class="sourceCode kotlin"><span class="kw">null</span></code>. On distingue deux cas :</p>
<ul>
<li>Présence de valeur : <code class="sourceCode kotlin">Some(value)</code> ;</li>
<li>Son absence : <code class="sourceCode kotlin">None()</code>.</li>
</ul>
<p>Pour lier les deux constructeurs à un seul type on utilise une famille scellée, voici une proposition d’implémentation (qui ne se soucie pas du tout de la variance pour simplifier la lecture) :</p>
<div class="sourceCode" id="cb4" data-roe-kind="code" data-line-number="true"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">sealed</span> <span class="kw">class</span> Option&lt;<span class="dt">A</span>&gt; {</a>
<a class="sourceLine" id="cb4-2" title="2">    abstract <span class="kw">fun</span> &lt;<span class="dt">B</span>&gt; <span class="fu">flatMap</span>(<span class="va">f</span>:(<span class="dt">A</span>) -&gt; <span class="dt">Option</span>&lt;<span class="va">B</span>&gt;): <span class="dt">Option</span>&lt;<span class="dt">B</span>&gt;</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">fun</span> &lt;<span class="dt">B</span>&gt; <span class="fu">map</span>(<span class="va">f</span>:(<span class="dt">A</span>) -&gt; <span class="dt">B</span>) = flatMap { wrap(f(it)) }</a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="kw">companion</span> <span class="kw">object</span> {</a>
<a class="sourceLine" id="cb4-6" title="6">        <span class="kw">fun</span> &lt;<span class="dt">A</span>&gt; <span class="fu">wrap</span>(<span class="va">value</span>: <span class="dt">A</span>): <span class="dt">Option</span>&lt;<span class="dt">A</span>&gt; =</a>
<a class="sourceLine" id="cb4-7" title="7">            Some(value)</a>
<a class="sourceLine" id="cb4-8" title="8">    }</a>
<a class="sourceLine" id="cb4-9" title="9">}</a>
<a class="sourceLine" id="cb4-10" title="10"><span class="kw">class</span> None&lt;<span class="dt">A</span>&gt; : <span class="dt">Option</span>&lt;<span class="dt">A</span>&gt;() {</a>
<a class="sourceLine" id="cb4-11" title="11">    <span class="kw">override</span> <span class="kw">fun</span> &lt;<span class="dt">B</span>&gt; <span class="fu">flatMap</span>(<span class="va">f</span>: (<span class="dt">A</span>) -&gt; <span class="dt">Option</span>&lt;<span class="va">B</span>&gt;): <span class="dt">Option</span>&lt;<span class="dt">B</span>&gt; =</a>
<a class="sourceLine" id="cb4-12" title="12">        None()</a>
<a class="sourceLine" id="cb4-13" title="13">}</a>
<a class="sourceLine" id="cb4-14" title="14"><span class="kw">data</span> <span class="kw">class</span> Some&lt;<span class="dt">A</span>&gt;(<span class="kw">val</span> <span class="va">value</span>: <span class="dt">A</span>) : <span class="dt">Option</span>&lt;<span class="dt">A</span>&gt;() {</a>
<a class="sourceLine" id="cb4-15" title="15">    <span class="kw">override</span> <span class="kw">fun</span> &lt;<span class="dt">B</span>&gt; <span class="fu">flatMap</span>(<span class="va">f</span>: (<span class="dt">A</span>) -&gt; <span class="dt">Option</span>&lt;<span class="va">B</span>&gt;): <span class="dt">Option</span>&lt;<span class="dt">B</span>&gt; =</a>
<a class="sourceLine" id="cb4-16" title="16">        f(value)</a>
<a class="sourceLine" id="cb4-17" title="17">}</a></code></pre></div>
<p>On peut noter que <code class="sourceCode kotlin">map</code> s’exprime très bien au moyen de <code class="sourceCode kotlin">flatMap</code> et notre structure a le comportement attendu :</p>
<div class="sourceCode" id="cb5" data-roe-kind="code" data-line-number="true" data-line-start="18"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">val</span> <span class="va">x</span> = Option.wrap(<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb5-2" title="2">  .map { it + <span class="dv">10</span>}</a>
<a class="sourceLine" id="cb5-3" title="3">  .flatMap { None&lt;<span class="kw">Int</span>&gt;() } <span class="co">// L'inférence fonctionne rarement :lol:</span></a>
<a class="sourceLine" id="cb5-4" title="4">  .map { it + <span class="dv">20</span>}</a></code></pre></div>
<p>Un combinateur que l’on aime adjoindre à <code class="sourceCode kotlin">map</code> et <code class="sourceCode kotlin">flatMap</code> est le combinateur <code class="sourceCode kotlin">flatten</code> (ou <code class="sourceCode kotlin">join</code> dans d’autres langages) qui pourrait très bien s’exprimer via <code class="sourceCode kotlin">flatMap</code>. Mais comment l’exprimer dans la classe <code class="sourceCode kotlin">Option</code> ?</p>
<div class="sourceCode" id="cb6" data-roe-kind="code" data-line-number="true" data-hl="4"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">sealed</span> <span class="kw">class</span> Option&lt;<span class="dt">A</span>&gt; {</a>
<a class="sourceLine" id="cb6-2" title="2">    abstract <span class="kw">fun</span> &lt;<span class="dt">B</span>&gt; <span class="fu">flatMap</span>(<span class="va">f</span>:(<span class="dt">A</span>) -&gt; <span class="dt">Option</span>&lt;<span class="va">B</span>&gt;): <span class="dt">Option</span>&lt;<span class="dt">B</span>&gt;</a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="kw">fun</span> &lt;<span class="dt">B</span>&gt; <span class="fu">map</span>(<span class="va">f</span>:(<span class="dt">A</span>) -&gt; <span class="dt">B</span>) = flatMap { wrap(f(it)) }</a>
<a class="sourceLine" id="cb6-4" title="4">    ??? <span class="kw">fun</span> <span class="fu">flatten</span>() : = <span class="dt">flatMap</span> { it }</a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="kw">companion</span> <span class="kw">object</span> {</a>
<a class="sourceLine" id="cb6-7" title="7">        <span class="kw">fun</span> &lt;<span class="dt">A</span>&gt; <span class="fu">wrap</span>(<span class="va">value</span>: <span class="dt">A</span>): <span class="dt">Option</span>&lt;<span class="dt">A</span>&gt; =</a>
<a class="sourceLine" id="cb6-8" title="8">            Some(value)</a>
<a class="sourceLine" id="cb6-9" title="9">    }</a>
<a class="sourceLine" id="cb6-10" title="10">}</a></code></pre></div>
<p>Ici, on voit rapidement le manque de contrôle que le traitement uniforme des paramètres génériques peut engendrer. Une astuce pour palier à ça serait de déplacer la fonction <code class="sourceCode kotlin">flatten</code> dans l’objet compagnon :</p>
<div class="sourceCode" id="cb7" data-roe-kind="code" data-line-number="true" data-hl="9;10"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">sealed</span> <span class="kw">class</span> Option&lt;<span class="dt">A</span>&gt; {</a>
<a class="sourceLine" id="cb7-2" title="2">    abstract <span class="kw">fun</span> &lt;<span class="dt">B</span>&gt; <span class="fu">flatMap</span>(<span class="va">f</span>:(<span class="dt">A</span>) -&gt; <span class="dt">Option</span>&lt;<span class="va">B</span>&gt;): <span class="dt">Option</span>&lt;<span class="dt">B</span>&gt;</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="kw">fun</span> &lt;<span class="dt">B</span>&gt; <span class="fu">map</span>(<span class="va">f</span>:(<span class="dt">A</span>) -&gt; <span class="dt">B</span>) = flatMap { wrap(f(it)) }</a>
<a class="sourceLine" id="cb7-4" title="4"></a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="kw">companion</span> <span class="kw">object</span> {</a>
<a class="sourceLine" id="cb7-6" title="6">        <span class="kw">fun</span> &lt;<span class="dt">A</span>&gt; <span class="fu">wrap</span>(<span class="va">value</span>: <span class="dt">A</span>): <span class="dt">Option</span>&lt;<span class="dt">A</span>&gt; =</a>
<a class="sourceLine" id="cb7-7" title="7">            Some(value)</a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9">        <span class="kw">fun</span> &lt;<span class="dt">A</span>&gt; <span class="fu">flatten</span>(<span class="va">x</span>: <span class="dt">Option</span>&lt;<span class="va">Option</span>&lt;<span class="va">A</span>&gt;&gt;) = </a>
<a class="sourceLine" id="cb7-10" title="10">            x.flatMap { it }</a>
<a class="sourceLine" id="cb7-11" title="11">    }</a>
<a class="sourceLine" id="cb7-12" title="12">}</a></code></pre></div>
<p>On pourrait se plaindre que cela ruine notre belle <em>pipeline</em>, cependant, grâce à la petite méthode <code class="sourceCode kotlin">let</code>, on ne peut y voir que du feu :</p>
<div class="sourceCode" id="cb8" data-roe-kind="code" data-line-number="true" data-line-start="18"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">val</span> <span class="va">x</span> = Option.wrap(<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb8-2" title="2">  .map { it + <span class="dv">10</span>}</a>
<a class="sourceLine" id="cb8-3" title="3">  .flatMap { None&lt;<span class="kw">Int</span>&gt;() }</a>
<a class="sourceLine" id="cb8-4" title="4">  .map { Option.wrap(it + <span class="dv">20</span>)}</a>
<a class="sourceLine" id="cb8-5" title="5">  .let(::flatten)</a></code></pre></div>
<p>Même si cette approche est, à l’usage, indéniablement satisfaisante, elle impose au développeur de garder dans son esprit ce qui est relié à l’instance, les méthodes, et ce qui est greffé à l’objet compagnon. Ce que l’on constate, c’est que les paramètres de fonctions permettent de décrire des structures paramétrés de manière plus fine. Heureusement, on a vu que les extensions ne sont, au final, que des fonctions, et dans la rubrique précédente, nous avons créé une méthode d’extension sur un type concret.</p>
<p>Vous vous en doutez, il est possible de décrire une méthode pour le type <code class="sourceCode kotlin">Option&lt;Option&lt;A&gt;&gt;</code> :</p>
<div class="sourceCode" id="cb9" data-roe-kind="code" data-line-number="true"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">fun</span> &lt;<span class="dt">A</span>&gt; <span class="fu">Option</span>&lt;<span class="dt">Option</span>&lt;<span class="dt">A</span>&gt;&gt;.<span class="fu">join</span>() = </a>
<a class="sourceLine" id="cb9-2" title="2">   flatMap { it }</a></code></pre></div>
<p>L’<em>import</em> de cette méthode permet de travailler avec <code class="sourceCode kotlin">flatten</code> directement comme une méthode sur une option d’option. Si par contre, on essaye d’appliquer la méthode à une valeur qui n’a pas le type <code class="sourceCode kotlin">Option&lt;Option&lt;...&gt;&gt;</code>, le programme ne compilera pas. Ce qui est exactement le comportement que l’on attend !</p>
<div class="sourceCode" id="cb10" data-roe-kind="code" data-line-number="true" data-line-start="18"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">val</span> <span class="va">x</span> = Option.wrap(<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb10-2" title="2">  .map { it + <span class="dv">10</span>}</a>
<a class="sourceLine" id="cb10-3" title="3">  .flatMap { None&lt;<span class="kw">Int</span>&gt;() }</a>
<a class="sourceLine" id="cb10-4" title="4">  .map { Option.wrap(it + <span class="dv">20</span>)}</a>
<a class="sourceLine" id="cb10-5" title="5">  .flatten()</a></code></pre></div>
<p>Cette utilisation des extensions peut sembler très naïve, mais elle couvre une problématique assez ancienne (et connue) de l’organisation en classes : <strong>l’absence de méthode <em>gardées</em></strong>. Soit des contraintes de sous-typage (ou de traits) sur certaines méthodes. Kotlin offre une solution via les extensions, en définissant les <em>guards</em> en dehors de la définition de la classe. Il existe d’autres approches, notamment l’utilisation de <strong>témoins d’égalité</strong>, en Scala, qui prennent le forme d’<em>implicits</em>.</p>
<p>En conclusion de cette première présentation très scolaire, les extensions offrent une manière de typer plus finement les receveurs de méthodes et c’est assez pratique pour définir des fonctions communes… comme <code class="sourceCode kotlin">flatten</code>. Concrètement, les extensions permettent d’ajouter des contraintes sur la disponibilité d’une méthode en fonction du type du générique. Ça peut paraitre assez anodin, mais ça permet d’implémenter des méthodes qu’il serait impossible d’écrire normalement et garder une approche d’appel (l’envoi de message) systématique.</p>
<h2 id="extensions-locales">Extensions locales</h2>
<p>Maintenant que nous avons observé un premier usage assez raisonnable des extensions, amusons-nous avec des exemples moins réalistes ! Le langage d’importation de Kotlin (et par extension de Java) est assez pauvre. On ne peut ouvrir/importer des fragments de bibliothèques que dans le <em>toplevel</em> d’un fichier. Il n’est pas possible de faire des ouverture au niveau de l’expression (ou de manière moins radicale, au niveau de la fonction).</p>
<p>Heureusement, avec un peu d’astuce, il est possible de ne rendre des extensions disponible que dans un <em>scope</em> spécifique, au moyen de la fonction <a href="https://kotlinlang.org/api/latest/jvhttps://kotlinlang.org/docs/reference/extensions.m/stdlib/kotlin/with.html">with</a>. Ce n’est probablement pas très utile, mais ça calme l’hystérie du programmeur OCaml que je suis, où chaque module peut être ouvert localement !</p>
<p>Concrètement, il est possible de définir des extensions au sein d’une classe (ou d’une interface). Par exemple :</p>
<div class="sourceCode" id="cb11" data-roe-kind="code" data-line-number="true" data-hl="2"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">class</span> MyContext {</a>
<a class="sourceLine" id="cb11-2" title="2">    <span class="kw">fun</span> <span class="fu">Int</span>.<span class="fu">successor</span>() = <span class="kw">this</span> + <span class="dv">1</span></a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="kw">fun</span> <span class="fu">succ</span>(<span class="va">x</span>: <span class="dt">Int</span>) = x.successor()</a>
<a class="sourceLine" id="cb11-4" title="4">}</a></code></pre></div>
<p>Ici, on défini une extension <code class="sourceCode kotlin">successor</code> sur les entiers et cette extension n’est accessible que dans notre classe. Mais est-il possible de mutualiser nos extensions pour que l’on puisse définir un ensemble d’extensions que l’on rend disponibles dans plusieurs classes ?</p>
<p>Pour cela, on peut utiliser une autre classe, mais ça introduirait une relation d’héritage directe entre la classe qui <em>applique les extensions</em> et je ne suis pas convaincu que ça serait très pertinent. Pas de panique, utilisons une interface !</p>
<div class="sourceCode" id="cb12" data-roe-kind="code" data-line-number="true"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">interface</span> IntExt {</a>
<a class="sourceLine" id="cb12-2" title="2">    <span class="kw">fun</span> <span class="fu">Int</span>.<span class="fu">successor</span>() = <span class="kw">this</span> + <span class="dv">1</span></a>
<a class="sourceLine" id="cb12-3" title="3">    <span class="kw">fun</span> <span class="fu">Int</span>.<span class="fu">predecessor</span>() = <span class="kw">this</span> - <span class="dv">1</span></a>
<a class="sourceLine" id="cb12-4" title="4">}</a>
<a class="sourceLine" id="cb12-5" title="5"></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="kw">class</span> MyContext : <span class="dt">IntExt</span> {</a>
<a class="sourceLine" id="cb12-7" title="7">    <span class="kw">fun</span> <span class="fu">succ</span>(<span class="va">x</span>: <span class="dt">Int</span>) = x.successor()</a>
<a class="sourceLine" id="cb12-8" title="8">    <span class="kw">fun</span> <span class="fu">pred</span>(<span class="va">x</span>: <span class="dt">Int</span>) = x.predecessor()</a>
<a class="sourceLine" id="cb12-9" title="9">}</a></code></pre></div>
<p>Nous pouvons facilement stocker nos extensions “à appliquer” dans une interface et les appliquer, au moyen de l’implémentation d’interface !</p>
<p>Les interfaces (ou les classes) nous permettent de transporter des collections d’extensions arbitraires. Dans les faits, ce n’est pas très utile car généralement, un fichier Kotlin n’expose pas “beaucoup de classe”, cependant, en utilisant la fonction <a href="https://kotlinlang.org/api/latest/jvhttps://kotlinlang.org/docs/reference/extensions.m/stdlib/kotlin/with.html">with</a>, il est possible d’appliquer une extension dans un <em>scope</em> spécifique, démonstration :</p>
<div class="sourceCode" id="cb13" data-roe-kind="code" data-line-number="true"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">interface</span> IntExt {</a>
<a class="sourceLine" id="cb13-2" title="2">    <span class="kw">fun</span> <span class="fu">Int</span>.<span class="fu">successor</span>() = <span class="kw">this</span> + <span class="dv">1</span></a>
<a class="sourceLine" id="cb13-3" title="3">    <span class="kw">fun</span> <span class="fu">Int</span>.<span class="fu">predecessor</span>() = <span class="kw">this</span> - <span class="dv">1</span></a>
<a class="sourceLine" id="cb13-4" title="4">}</a>
<a class="sourceLine" id="cb13-5" title="5"></a>
<a class="sourceLine" id="cb13-6" title="6"><span class="co">// On définit un contexte </span></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="kw">class</span> MyContext : <span class="dt">IntExt</span> </a>
<a class="sourceLine" id="cb13-8" title="8"></a>
<a class="sourceLine" id="cb13-9" title="9"><span class="kw">val</span> <span class="va">x</span> = with(MyContext()) {</a>
<a class="sourceLine" id="cb13-10" title="10">   <span class="co">// Dans ce scope, j'ai accès à mes extensions</span></a>
<a class="sourceLine" id="cb13-11" title="11">   <span class="fl">10.</span>successor()</a>
<a class="sourceLine" id="cb13-12" title="12">}</a></code></pre></div>
<p>La fonction <code class="sourceCode kotlin">with</code> nous permet d’exécuter une lambda dans le contexte de l’objet donné en argument. De ce fait, l’utilisation de cette fonction sur une instance d’une classe implémentant l’interface qui applique les extensions, rend ces extensions disponibles dans uniquement dans le <em>bloc</em> de la fonction.</p>
<p>Même si l’application locale des extensions peut paraitre inutile, le point essentiel de cette section est qu’il est possible de <strong>définir un ensemble</strong> <strong>d’extensions qui sera appliqué à la demande d’un utilisateur</strong> au niveau d’une classe (ou d’une autre interface) ou plus brutalement d’une expression au moyen de la construction <code class="sourceCode kotlin">with</code>.</p>
<h2 id="extensions-génériques">Extensions génériques</h2>
<p>Maintenant que nous pouvons appliquer des extensions à la volée en usant et abusant de l’incroyablement permissif <code class="sourceCode kotlin">with</code>, essayons d’aller plus loins ! Appliquons des extensions à sur des génériques ! C’est entièrement possible car Kotlin ne limite pas l’application d’extensions à des classes connues. Il est tout à fait possible d’appliquer une extension à une classe que l’on ne connait pas ! Par exemple :</p>
<div class="sourceCode" id="cb14" data-roe-kind="code" data-line-number="true" data-hl="11"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb14-1" title="1"><span class="co">// On défini notre extension de manière &quot;générique&quot;</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="kw">interface</span> Silly&lt;<span class="dt">T</span>&gt; {</a>
<a class="sourceLine" id="cb14-3" title="3">    <span class="kw">fun</span> <span class="fu">T</span>.<span class="fu">bang</span>() = <span class="st">&quot;Bang Bang&quot;</span></a>
<a class="sourceLine" id="cb14-4" title="4">}</a>
<a class="sourceLine" id="cb14-5" title="5"></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="co">// On défini un contexte pour profiter de [with]</span></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="kw">class</span> Context : <span class="dt">Silly</span>&lt;<span class="dt">String</span>&gt;</a>
<a class="sourceLine" id="cb14-8" title="8"></a>
<a class="sourceLine" id="cb14-9" title="9"><span class="kw">fun</span> <span class="fu">main</span>() {</a>
<a class="sourceLine" id="cb14-10" title="10">    <span class="kw">val</span> <span class="va">x</span> = with(Context()){</a>
<a class="sourceLine" id="cb14-11" title="11">        <span class="st">&quot;foo&quot;</span>.bang()</a>
<a class="sourceLine" id="cb14-12" title="12">    }</a>
<a class="sourceLine" id="cb14-13" title="13">    println(x)</a>
<a class="sourceLine" id="cb14-14" title="14">}</a></code></pre></div>
<p>Comme le montre l’exemple, on peut décider arbitrairement d’ajouter des méthodes à une classe que l’on ne connait pas. De plus, comme le langage des génériques permet de définir des contraintes de généricité, il est possible de contraindre les classes sur lesquelles on veut appliquer les extensions à la demande. Mais concrètement est-il possible de trouver des cas d’usages à cette utilisation spécifique des extensions ?</p>
<p>Pour être très honnête… je pense que cet usage spécifique relève plus de l’expérimentation et l’amusement. Il s’agit d’un encodage un peu particulier pour écrire autrement ce qu’il aurait été possible d’écrire de manière plus traditionnelle via des passages de fonctions ou de la répétition des implémentation manuelles. Mais pour le plaisir de l’exercice, implémentons l’inénarrable <strong>Monoïde</strong> de manière “presque générique”.</p>
<h3 id="un-fournisseur-de-reducers">Un fournisseur de <em>reducers</em></h3>
<p>L’objectif de l’article n’est pas de s’étendre sur une définition rigoureuse du monoïde, <a href="https://www.youtube.com/watch?v=srQt1NAHYC0">certains l’ont déjà fait de manière très claire</a>. Retenons juste que si une classe possède un élément neutre et que ses instances possèdent une méthode <code class="sourceCode kotlin">combine</code> qui prend deux instance de cette classe et retourne une valeur de cette classe (donc <code class="sourceCode kotlin">T.combine(x: T) : T</code> en respectant certaines lois :</p>
<ul>
<li><code class="sourceCode kotlin">combine</code> est associatif</li>
<li><code class="sourceCode kotlin">element_neutre.combine(x)</code> est égal à <code class="sourceCode kotlin">x</code></li>
<li><code class="sourceCode kotlin">x.combine(element_neutre)</code> est égal à <code class="sourceCode kotlin">x</code></li>
</ul>
<p>C’est lois permettent l’implémentation de combinateurs qui exploitent l’opération <code class="sourceCode kotlin">combine</code>. Il est par exemple possible de définir un monoïde sur les entiers pour qui l’opérateur <code class="sourceCode kotlin">combine</code> est simplement l’addition et l’élément neutre est … logiquement, <code class="sourceCode kotlin">zéro</code>. Ou alors un monoïde, lui aussi sur les entiers, mais où cette fois, l’élément neutre est <code class="sourceCode kotlin">un</code>. Un dernier exemple serait une monoïde sur les chaines de caractéres pour lesquels l’opérateur <code class="sourceCode kotlin">combine</code> serait la concatènation.</p>
<p>Quand on possède un monoïde, on possède aussi, <em>de facto</em> une fonction <code class="sourceCode kotlin">reduce</code> qui transforme un ensemble de valeur de notre monoïde en une seule. Dans le cas du monoïde des entiers adjoints à l’addition, le résultat serait la somme de tous les éléments.</p>
<p>Pour définir cette génériquement on voudrait pouvoir l’exprimer de cette manière :</p>
<div class="sourceCode" id="cb15" data-roe-kind="code" data-line-number="true"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">fun</span> &lt;<span class="dt">T</span>&gt; <span class="fu">Collection</span>&lt;<span class="dt">Monoid</span>&lt;<span class="dt">T</span>&gt;&gt;.<span class="fu">reduce</span>() = </a>
<a class="sourceLine" id="cb15-2" title="2">  Collection.fold(T.neutralElement) { accumulator, element -&gt; </a>
<a class="sourceLine" id="cb15-3" title="3">     accumulator.combine(element)</a>
<a class="sourceLine" id="cb15-4" title="4">  }</a></code></pre></div>
<p>Même si au survol, cette “implémentation” semble valide, elle pose tout de même plusieurs soucis :</p>
<ul>
<li>premièrement, elle n’est pas implémentable … (à cause du <code class="sourceCode kotlin">T.neutral_element</code>)</li>
<li>ensuite, elle considère que tout ce qui implémente <code class="sourceCode kotlin">Monoid</code> est “valide”, donc le monoïde des entiers sur l’addition serait compatible avec le monoïde des entiers sur le produit</li>
<li>il ne serait pas possible de “convertir” un type existant en monoïde (ou alors il faudrait <em>wrapper</em> le type dans une classe qui implémenterait l’interface <code class="sourceCode kotlin">Monoid</code>.</li>
</ul>
<p>Kotlin ne permettant pas d’exprimer du sous-typage structurel, je vous propose d’utiliser nos nouveaux super-pouvoirs pour fournir des <em>reducers</em> via des extensions !</p>
<div class="sourceCode" id="cb16" data-roe-kind="code" data-line-number="true"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">interface</span> Monoid&lt;<span class="dt">Subject</span>&gt; {</a>
<a class="sourceLine" id="cb16-2" title="2">    <span class="kw">fun</span> <span class="fu">Subject</span>.<span class="fu">neutralElement</span>() : <span class="dt">Subject</span></a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="kw">fun</span> <span class="fu">Subject</span>.<span class="fu">combine</span>(<span class="va">x</span>: <span class="dt">Subject</span>) : <span class="dt">Subject</span></a>
<a class="sourceLine" id="cb16-4" title="4">}</a></code></pre></div>
<p>Rien ne nous empêche de définir des extensions abstraites, dès lors que l’on contruira un <em>contexte</em> pour nos différents monoïdes, il faudra fournir une implémentation pour <code class="sourceCode kotlin">neutralElement</code> et <code class="sourceCode kotlin">combine</code>. Par exemple :</p>
<div class="sourceCode" id="cb17" data-roe-kind="code" data-line-number="true" data-line-start="5"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">class</span> AddMonoid : <span class="dt">Monoid</span>&lt;<span class="dt">Int</span>&gt; {</a>
<a class="sourceLine" id="cb17-2" title="2">    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">Int</span>.<span class="fu">combine</span>(<span class="va">x</span>: <span class="dt">Int</span>) = plus(x)</a>
<a class="sourceLine" id="cb17-3" title="3">    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">Int</span>.<span class="fu">neutralElement</span>() = <span class="dv">0</span></a>
<a class="sourceLine" id="cb17-4" title="4">}</a>
<a class="sourceLine" id="cb17-5" title="5"></a>
<a class="sourceLine" id="cb17-6" title="6"><span class="kw">class</span> StringMonoid : <span class="dt">Monoid</span>&lt;<span class="dt">String</span>&gt; {</a>
<a class="sourceLine" id="cb17-7" title="7">    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">String</span>.<span class="fu">combine</span>(<span class="va">x</span>: <span class="dt">String</span>) = <span class="st">&quot;${this}$x&quot;</span></a>
<a class="sourceLine" id="cb17-8" title="8">    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">String</span>.<span class="fu">neutralElement</span>() = <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb17-9" title="9">}</a></code></pre></div>
<p>Comme tout objet ne possède pas obligatoirement d’objet compagnon, je ne peux hélas pas intégrer “facilement” <code class="sourceCode kotlin">neutralElement</code> à un niveau superieur à celui de l’instance… ce qui impose tout de même quelques <em>hacks</em> un peu triste dans l’implémentation de <code class="sourceCode kotlin">reduce</code>.</p>
<div class="sourceCode" id="cb18" data-roe-kind="code" data-line-number="true" data-hl="5..10"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">interface</span> Monoid&lt;<span class="dt">Subject</span>&gt; {</a>
<a class="sourceLine" id="cb18-2" title="2">    <span class="kw">fun</span> <span class="fu">Subject</span>.<span class="fu">neutralElement</span>() : <span class="dt">Subject</span></a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="kw">fun</span> <span class="fu">Subject</span>.<span class="fu">combine</span>(<span class="va">x</span>: <span class="dt">Subject</span>) : <span class="dt">Subject</span></a>
<a class="sourceLine" id="cb18-4" title="4"></a>
<a class="sourceLine" id="cb18-5" title="5">    <span class="kw">fun</span> <span class="fu">Collection</span>&lt;<span class="dt">Subject</span>&gt;.<span class="fu">reduce</span>(<span class="va">initial</span>: <span class="dt">Subject?</span> = null) : <span class="dt">Subject?</span> {</a>
<a class="sourceLine" id="cb18-6" title="6">        <span class="kw">return</span> <span class="kw">this</span>.fold(initial) { acc, left -&gt;</a>
<a class="sourceLine" id="cb18-7" title="7">            <span class="kw">val</span> <span class="va">right</span> = acc ?: left.neutralElement()</a>
<a class="sourceLine" id="cb18-8" title="8">            right?.combine(left)</a>
<a class="sourceLine" id="cb18-9" title="9">        }</a>
<a class="sourceLine" id="cb18-10" title="10">    }</a>
<a class="sourceLine" id="cb18-11" title="11">}</a></code></pre></div>
<p>On ajoute dans notre interface qui transporte nos extensions une methode <code class="sourceCode kotlin">reduce</code> qui agit sur les <code class="sourceCode kotlin">Collection&lt;Subject&gt;</code>. On triche un peu pour accéder à l’élément neutre, et en supposant que si la liste est vide elle renverra <code class="sourceCode kotlin"><span class="kw">null</span></code> si l’utilisateur ne donne pas en argument l’élément neutre (si elle n’est pas vide par contre, ça fonctionnera). Il serait possible, moyennant plus d’encodage, de corriger le soucis de l’élément neutre, mais le code risquerait de devenir plus complexe (pour, au final, pas grand chose).</p>
<p>Quoi qu’il en soit, il est possible d’utiliser <code class="sourceCode kotlin">reduce</code> dans des contextes spécifiques :</p>
<div class="sourceCode" id="cb19" data-roe-kind="code" data-line-number="true"><pre class="sourceCode Kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">fun</span> <span class="fu">main</span>() {</a>
<a class="sourceLine" id="cb19-2" title="2">    <span class="kw">val</span> <span class="va">x</span> = with(AddMonoid()) {</a>
<a class="sourceLine" id="cb19-3" title="3">        listOf(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>).reduce()</a>
<a class="sourceLine" id="cb19-4" title="4">    } <span class="co">// x = 15</span></a>
<a class="sourceLine" id="cb19-5" title="5"></a>
<a class="sourceLine" id="cb19-6" title="6">    <span class="kw">val</span> <span class="va">y</span> = with(StringMonoid()) {</a>
<a class="sourceLine" id="cb19-7" title="7">        listOf(<span class="st">&quot;Hello &quot;</span>, <span class="st">&quot;World &quot;</span>, <span class="st">&quot;!&quot;</span>).reduce()</a>
<a class="sourceLine" id="cb19-8" title="8">    } <span class="co">// y = &quot;Hello World !&quot;</span></a>
<a class="sourceLine" id="cb19-9" title="9">}</a></code></pre></div>
<p>Concrètement, on rend possible, dans le contexte de nos monoïdes, des extensions sur les collections implémentant <code class="sourceCode kotlin">reduce</code>. Malgré que l’implémentation de l’élément neutre ne soit pas vraiment satisfaisante, la solution propose tout de même très peu de <em>boilerplate</em>.</p>
<p>Même si dans des exemples plus réalistes, il est probable que ce genre d’encodage ne soit pas d’une très grande aide, j’ai l’intuition qu’ils offrent des exemples acceptables (et un peu amusant tout de même) de ce qu’offrent les extensions. D’ailleurs, en en parlant avec <a href="https://twitter.com/fteychene">Francois Teychene</a> et <a href="https://twitter.com/dplaindoux">Didier Plaindoux</a>, ils m’ont fait remarquer que c’était un encodage similaire (complété par de la génération de code pour simplifier l’usage et les capacités) qu’utilisait <em><a href="https://arrow-kt.io/" class="uri">https://arrow-kt.io/</a></em> pour simuler les classe de types “à la Haskell”. Les développeurs de la bibliothèque ont d’ailleurs ouvert une <a href="https://github.com/Kotlin/KEEP/pull/87">proposition d’évolution</a> du langage qui est encore active, très populaire, mais … hélas, pas dans la <em>roadmap</em> du langage à l’heure actuelle.</p>
<h2 id="pour-conclure">Pour conclure</h2>
<p>En conclusion, les extensions sont un mécanisme puissant qui permet, dans un premier temps, d’éviter l’abus de modules utilitaires qui cassent l’envoi de message (l’appel de méthode classique) pour ajouter des fonctionnalités. Elles permettent aussi de typer plus finement les receveurs de méthodes, comme nous l’avons vu avec la méthode <code class="sourceCode kotlin">flatten()</code>. Et elles permettent aussi d’encoder des constructions génériques un peu plus farfelues.</p>
<p>Même si mes deux derniers points étaient un peu exentriques, l’utilisation d’une approche similaire dans Arrow.kt démontre qu’elles reposent, tout de même, sur une bonne intention (aha) et c’était assez amusant à expérimenter !</p>
<p>J’espère que cet article aura, au mieux, permis de comprendre quelques usages complémentaires à l’utilisation des extensions et au mieux, du mieux, d’avoir eu envie de regarder Arrow.kt en profondeur ! Pour aller un peu plus loins, <a href="https://twitter.com/dplaindoux">Didier Plaindoux</a> à rédigé un <a href="https://gist.github.com/d-plaindoux/ec3dd2b705a551342713fc6437dab15b">Gist</a> qui tire partit d’une approche similaire mais qui, moyennant un peu plus de plomberie, gère des types un peu plus complexes.</p>
<p>Pour tout ceux concernés, je vous souhaite beaucoup de courage pour la suite du confinement ! <strong>#stayHome</strong>.</p>
        <div id="eof-page"></div>
      </div>
      <div class="content-rightbar">
        <div id="major-content-right" class="small-refutable">
          <div class="loading">
            <img src="../picto/loader.black.svg" alt="loading..." />
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="major-content-bottom">
    <div class="loading">
      <img src="../picto/loader.black.svg" alt="loading..." />
    </div>
  </div>
</div>
<script>
  planet.suspend(function() {
    planet.story.boot({
      path: "/longs/kotlin_extensions.html",
      eof: document.getElementById("eof-page"),
      story: document.querySelector(
        "textarea[data-planet-qexp='story']"
      ),
      rightContainer: document.getElementById(
        "major-content-right"
      ),
      bottomContainer: document.getElementById(
        "major-content-bottom"
      ),
      resumeDetails: document.getElementById(
        "resume-details"
      )
    });
  });
  planet.suspend(function() {
    planet.roe.mount(
      document.getElementById("roe-container")
    );
  });
</script>

      </div>
    </main>
    <footer>
      <div class="container">
        <div class="left">
          <button id="random-page-btn" class="small-button-gray">
            Page aléatoire
          </button>
          <br /><br />
          Cette page est construite avec
          <a href="https://jaspervdj.be/hakyll/">Hakyll</a> et
          <a href="../projects/planet.html">Planet</a>.
          <br />
          Le contenu est distribué sous licence
          <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>.
        </div>
        <div class="center">
          <a href="http://webring.xxiivv.com/#random" target="_blank">
            <img class="pictogram" src="../picto/webring.black.svg" alt="webring-logo" />
          </a>
        </div>
        <div class="right">
          <a href="../xavier.html">Xavier Van de Woestyne</a> ©<br />
          2017-2020
        </div>
      </div>
    </footer>
    <div id="planet-sectors-metadata">
      <span class="planet-metadata sector-data" data-name="programming" data-desc="Programmation (code) relative ou non à des projets" data-color="rgb(34, 34, 34)"><!-- Planet metadata --></span>
<span class="planet-metadata sector-data" data-name="visual" data-desc="Dessin/Peinture/Design" data-color="rgb(68, 68, 68)"><!-- Planet metadata --></span>
<span class="planet-metadata sector-data" data-name="audio" data-desc="Musique/Sound design" data-color="rgb(221, 221, 221)"><!-- Planet metadata --></span>
<span class="planet-metadata sector-data" data-name="writing" data-desc="Ecriture d'articles, de livres, de notes" data-color="rgb(136, 136, 136)"><!-- Planet metadata --></span>
<span class="planet-metadata sector-data" data-name="research" data-desc="Expériences variées liées à l'apprentissage" data-color="rgb(85, 85, 85)"><!-- Planet metadata --></span>
<span class="planet-metadata sector-data" data-name="maintenance" data-desc="Correctif, maintenance d'infrastructures" data-color="rgb(204, 204, 204)"><!-- Planet metadata --></span>
<span class="planet-metadata sector-data" data-name="reading" data-desc="Activité liées à la lecture" data-color="rgb(192, 192, 192)"><!-- Planet metadata --></span>

    </div>
    <script>
      planet.suspend(function() {
        planet.tags.random({
          button: document.getElementById('random-page-btn')
        });
      });
      planet.start();
    </script>
  </body>
</html>
