<!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="author" content="Xavier Van de Woestyne">
    
    
    <meta name="description" content="Tests unitaires de fonctions impures - Une introduction aux effets algébriques par le biais des tests unitaires.">
    
    <title>Tests unitaires de fonctions impures - Une introduction aux effets algébriques par le biais des tests unitaires. </title>
    <link rel="stylesheet" href="../css/fonts.css" />
    <link rel="stylesheet" href="../css/hl.css" />
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="alternate" type="application/atom+xml" title="xvw-planet" href="../atom.xml" />
    <script src="../facade.bc.js"></script>
  </head>
  <body>
    <header>
      <div class="container">
        <div>
          <div class="header-bar">
            <h1>Xavier Van de Woestyne</h1>
            
            <h2>Tentative</h2>
            
          </div>
        </div>
      </div>
    </header>
    <main>
      <div class="navbar">
        <nav class="container">
          <a href="../">Accueil</a>
          <a href="../tags.html">Tags</a>
          <a href="../longs.html">Articles</a>
          <a href="../projects.html">Projets</a>
          <a href="../galleries.html">Galeries</a>
          <a href="../journal.html">Activité</a>
        </nav>
      </div>
      <div class="main-block">
        <div id="resume-details" class="page-small-cover black-block small-refutable"></div>
<div class="container base-content uniq-content">

  <div class="content-page">
    <div class="major-header">
      <div class="major-details">
        <h1>Tests unitaires de fonctions impures</h1>
        <span class="synopsis">
          Une introduction aux effets algébriques par le biais des tests unitaires.
        </span>
        <div>
          <span class="badge published">2020-03-10</span>
          <span class="badge">programmation</span>
        </div>
      </div>
    </div>
    <div class="major-content">
      <div class="long-text structured-text" id="roe-container">
        <blockquote>
<p>La programmation fonctionnelle pure offre beaucoup de bénéfices. Elle n’utilise que des fonctions pures qui sont faciles à tester, faciles à raisonner et qui permettent au compilateur de les optimiser.</p>
<p>Ce serait vraiment plus confortable de ne travailler qu’avec des fonctions pures, malheureusement, dans la construction de logiciels “utiles”, cela semble impossible. En effet <strong>les programmes du monde réel produisent des effets</strong>, il est donc, a priori, impossible de représenter un programme utile à coup de fonctions pures.</p>
<p>Dans <del>ce très court</del> cet article, je vous propose de découvrir <strong>les effets algébriques</strong> <strong>et leurs gestionnaires</strong> pour construire des programmes qui exécutent des effets, dans le contexte d’un langage de programmation fonctionnel, que l’on peut composer (pour construire des programmes plus complexes) tout en restant facilement testables unitairement.</p>
<p>Cet article n’est pas du tout un article technique et son objectif vise à donner une intuition sur l’utilisation des effets algébriques. Il ne va volontairement pas très loin dans l’exercice de la construction d’un système d’effets (j’en suis malheureusement incapable). Si vous êtes familiers avec la gestion des effets dans un langage de programmation, il y a fort à parier que cet article ne vous intéressera pas beaucoup… désolé !</p>
<p><strong>Donc, amateur de la théorie, ou personne exaspérée par les approximations,</strong> <strong>je vous invite à passer votre chemin</strong> (en toute amitié).</p>
</blockquote>
<p>Cela fait très longtemps que l’importance des tests unitaires n’est plus remise en question. Ils permettent de garantir, au mieux, la non-régression de la base de code, mais aussi servir de spécification. Couplés avec des méthodes fines, comme par exemple, les tests dirigés par les propriétés, qui, sur base d’une collection d’invariants (les propriétés), génèrent une collection de tests “aléatoirement”. Il est donc nécéssaire de fournir un maximum de tests, clairs et facilement maintenables.</p>
<p>Concrètement, il est possible de facilement tester unitairement les <strong>fonctions</strong> <strong>pures</strong>, alors que les <strong>fonctions impures</strong> infligent généralement l’usage de <em>hacks</em> (par exemples, des <em>mocks</em> contruits à coup de <em>réflecteur</em>) pour capturer l’essence de la fonctionnalité testée.</p>
<h2 id="fonctions-pures-et-impures">Fonctions pures et impures</h2>
<p>Dans un premier temps, observons cette fonction, implémentée en <strong>Kotlin</strong>, dont le rôle principal est de calculer le successeur d’un nombre :</p>
<div class="sourceCode" id="cb1" data-roe-kind="code" data-pellet="Kotlin" data-line-number="true"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">import</span> <span class="im">java.util.Scanner</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">fun</span> <span class="fu">successor</span>() {</a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="kw">val</span> <span class="va">reader</span> = Scanner(System.`in`)</a>
<a class="sourceLine" id="cb1-5" title="5">  print(<span class="st">&quot;Enter a number: &quot;</span>)</a>
<a class="sourceLine" id="cb1-6" title="6">  <span class="kw">val</span> <span class="va">input</span> = reader.nextInt()</a>
<a class="sourceLine" id="cb1-7" title="7">  <span class="kw">val</span> <span class="va">result</span> = input + <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-8" title="8">  println(<span class="st">&quot;The successor of [$input] is [$result] &quot;</span>)</a>
<a class="sourceLine" id="cb1-9" title="9">}</a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="kw">fun</span> <span class="fu">main</span>() {</a>
<a class="sourceLine" id="cb1-12" title="12">  successor()</a>
<a class="sourceLine" id="cb1-13" title="13">}</a></code></pre></div>
<p>Concrètement, cette fonction est potentiellement correcte, cependant, elle pose, selon moi (et selon beaucoup de personnes, probablement) énormément de soucis. Elle est impossible à tester unitairement facilement. En admettant que je veuille tester cette fonction, je devrais capturer l’écriture sur <code class="sourceCode bash"><span class="ex">stdin</span></code> et la lecture sur <code class="sourceCode bash"><span class="ex">stdout</span></code> pour être capable de fournir une collection de tests sur l’essence de mon algorithme, soit le fait que pour un nombre entier, je peux avoir son successeur. La fonction n’est pas pure, donc complexe à tester.</p>
<p>Une piste d’amélioration serait d’extraire l’essence du programme dans une fonction dédiée, dont le seul rôle serait de calculer le successeur d’un nombre entier. Par exemple :</p>
<div class="sourceCode" id="cb2" data-roe-kind="code" data-pellet="Kotlin" data-line-number="true"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">import</span> <span class="im">java.util.Scanner</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">fun</span> <span class="fu">successor</span>(<span class="va">x</span>: <span class="dt">Int</span>) : <span class="dt">Int</span> {</a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="kw">val</span> <span class="va">result</span> = x + <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="kw">return</span> result</a>
<a class="sourceLine" id="cb2-6" title="6">}</a>
<a class="sourceLine" id="cb2-7" title="7"></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="kw">fun</span> <span class="fu">main</span>() {</a>
<a class="sourceLine" id="cb2-9" title="9">  <span class="kw">val</span> <span class="va">reader</span> = Scanner(System.`in`)</a>
<a class="sourceLine" id="cb2-10" title="10">  print(<span class="st">&quot;Enter a number: &quot;</span>)</a>
<a class="sourceLine" id="cb2-11" title="11">  <span class="kw">val</span> <span class="va">input</span> = reader.nextInt()</a>
<a class="sourceLine" id="cb2-12" title="12">  <span class="kw">val</span> <span class="va">result</span> = successor(input)</a>
<a class="sourceLine" id="cb2-13" title="13">  println(<span class="st">&quot;The successor of [$input] is [$result] &quot;</span>)</a>
<a class="sourceLine" id="cb2-14" title="14">}</a></code></pre></div>
<p>Cette amélioration est très naïve, mais elle représente tout de même un sacré pas en avant. La fonction <code class="sourceCode kotlin">successor(x)</code> est facilement testable, et ça tombe assez bien, car c’est elle qui est au cœur de notre programme.</p>
<p>Même s’il serait possible d’écrire un test unitaire pour la fonction <code class="sourceCode kotlin">main()</code> moyennant quelques tours de magie… est-ce réellement nécessaire ? En effet, comme évoqué précédemment, l’essence de notre programme (discutablement intéressant) est de calculer un successeur pour un entier donné. Cette partie du programme est correctement testée, le reste du programme ne fait qu’exploiter des bibliothèques et des fonctions éprouvées de la <em>JVM</em>. A l’instar des démonstrations mathématiques, qui visent à réduire une collection de propositions à des axiomes, on ne cherche pas à tester ce qui a déjà été testé.</p>
<p>Mais tout ceci nous amène à une chose, depuis le début de cet article, j’utilise les adjectifs <strong>pure</strong> et <strong>impure</strong> pour qualifier les fonctions, sans avoir pris le temps de tâcher de fournir une définition compréhensible de fonctions pures et impures ! Concrètement, dès que l’on parle de fonctions pures, on entend généralement des fonctions <strong>dans le sens mathématique du terme</strong>, soit des fonctions qui sont :</p>
<ul>
<li><strong>totales</strong> : pour chaque entrée, elles produisent un résultat. (Doté d’un système de vérification statique des types, il est possible de restreindre le domaine de valeurs acceptées par une fonction) ;</li>
<li><strong>déterministes</strong> : pour des arguments donnés à une fonction, elle renvoie toujours le même résultat ;</li>
<li><strong>sans effets</strong> : elles ne produisent aucun effet. Elle ne peuvent que calculer des choses, sans dépendre, par exemple d’un environnement. Dans la partie suivante, nous tâcherons de donner une meilleur définition d’effets.</li>
</ul>
<p>Ce que l’on pourrait réduire en une phrase, une fonction pure est une fonction qui retourne constamment la même valeur pour la même entrée, mettant en lumière un comportement déterministe et ne provoquant aucun effet extérieur. Une fonction pure est <strong>référentiellement transparente</strong>, ce qui veut dire que l’on peut remplacer chacun de ses appels par son résultat, dès qu’on le connait.</p>
<p>Les fonctions impures sont toutes les fonctions qui ne sont pas pures. Comme évoqué rapidement en introduction, sans fonctions impures, il est a priori impossible de faire un programme utile. En effet, à moins que l’exécution du programme ne soit pas nécéssaire (par exemple lorsque l’on utilise un logiciel de démonstration assisté par ordinateur), construire un programme sans fonctions impures, donc sans effets, semble impossible.</p>
<p>Une première approche pour rendre nos logiciels testables et prédictibles consiste à fractionner le programme en <strong>deux parties</strong>, sa partie pure et sa partie impure. Idéalement, repoussant les fragments impurs aux extrémités du programme (ses entrées et ses sorties) pour n’avoir ensuite, plus qu’un noyau de fonctions pures, facilement testables.</p>
<h2 id="effets-et-effets-de-bords">Effets et effets de bords</h2>
<p>Comme une grande partie des langages de programmation populaires manipulent des effets de manière implicite, s’interroger sur ce qu’est un effet peut être assez peu commode. D’ailleurs, je trouve qu’il est assez complexe de donner une définition acceptable et claire d’un effet, généralement, on trouve des exemples d’effets :</p>
<ul>
<li>du non déterminisme ;</li>
<li>le fait de lire un environnement (une base de données par exemple) ;</li>
<li>le fait de modifier cet environnement ;</li>
<li>de l’aléatoire ;</li>
<li>etc.</li>
</ul>
<p>Une manière assez <em>simple</em> de caractériser un effet serait de l’opposer à un calcul. Dans la programmation fonctionnelle pure, l’exécution d’un programme (sans effets donc) consiste “simplement” à calculer sa <strong>forme normale</strong>, soit son résultat final, un effet serait donc quelque chose que l’on ne peut pas calculer.</p>
<p>Pour donner plus de précisions, il s’agirait de définir un effet comme une action qui a besoin d’être exécutée en <strong>référant une autorité centrale qui devra <em>gérer</em> cet effet</strong>. Par exemple, un programme qui lance une exception implique que cette exception soit gérée (via une construction, par exemple, en Java, <code class="sourceCode java"><span class="kw">try</span>/<span class="kw">catch</span></code> ou par le <em>runtime</em> de l’environnement d’exécution), une exception est donc un exemple d’effet.</p>
<p>Observons un exemple. Voici un programme qui permet d’afficher (de manière un peu vétuste) une liste des <em>Meilleurs scores</em> d’un jeu quelconque:</p>
<div class="sourceCode" id="cb3" data-roe-kind="code" data-pellet="Kotlin" data-line-number="true" data-hl="2;5;9;12"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">fun</span> <span class="fu">displayScore</span>() {</a>
<a class="sourceLine" id="cb3-2" title="2">   println(<span class="st">&quot;Score</span><span class="sc">\t</span><span class="st">User</span><span class="sc">\t</span><span class="st">Date&quot;</span>)</a>
<a class="sourceLine" id="cb3-3" title="3">   <span class="kw">val</span> <span class="va">scores</span> = </a>
<a class="sourceLine" id="cb3-4" title="4">      scoreRepository</a>
<a class="sourceLine" id="cb3-5" title="5">        .findAll()</a>
<a class="sourceLine" id="cb3-6" title="6">        .sortBy { it.scoreValue }</a>
<a class="sourceLine" id="cb3-7" title="7"></a>
<a class="sourceLine" id="cb3-8" title="8">   <span class="cf">if</span>(scores.isEmpty()) {</a>
<a class="sourceLine" id="cb3-9" title="9">     <span class="kw">throw</span> EmptyScoreException()</a>
<a class="sourceLine" id="cb3-10" title="10">   }</a>
<a class="sourceLine" id="cb3-11" title="11">   scores.forEach {</a>
<a class="sourceLine" id="cb3-12" title="12">      println(<span class="st">&quot;${it.scoreValue}</span><span class="sc">\t</span><span class="st">${it.username}</span><span class="sc">\t</span><span class="st">${it.date}&quot;</span>)</a>
<a class="sourceLine" id="cb3-13" title="13">   }</a>
<a class="sourceLine" id="cb3-14" title="14">}</a></code></pre></div>
<p>Concrètement, les fonctions <code class="sourceCode kotlin">println</code> (et consorts) doivent se référer au système d’exploitation pour être exécutées (en général, ce genre de fonctions, qui écrivent sur la sortie standard ou qui lisent sur l’entrée standard exécutent des effets dans le domaine de l’<strong>IO</strong>). La méthode <code class="sourceCode kotlin">findAll</code> sur <code class="sourceCode kotlin">scoreRepository</code> se réfère à une base de données et le lancement de l’exception <code class="sourceCode kotlin">EmptyScoreException</code> devra se référer au gestionnaire que l’on écrira pour elle dans la fonction qui utilisera <code class="sourceCode kotlin">displayScore</code>.</p>
<p>Dans cette fonction, nous observons 3 effets différents. Une intuition viable pour savoir si une fonction produit des effets consiste en général à se demander si la fonction doit se référer à une autorité centrale externe à la fonction. Et c’est généralement la présence de cette autorité centrale externe qui rend l’implémentation d’un test unitaire complexe.</p>
<h3 id="les-effets-de-bord">Les effets de bord</h3>
<p>Maintenant que nous avons une idée (un peu abstraite) de ce qu’est un effet, tâchons de définir un effet de bord. Ma prise de position pourrait être un poil polémique parce que la définition que l’on pourrait attacher à un effet de bord peut énormément varier en fonction du contexte. Il arrive souvent de lire le raccourci qu’un effet est un effet de bord. Pour ma part, je préfère distinguer l’effet de l’effet de bord en donnant une définition assez naïve mais, à mon sens, compréhensible, adaptée à la programmation statiquement typée : <strong>un effet de bord est un effet qui n’est pas reflété dans la signature</strong> <strong>de type de la fonction qui l’exécute</strong>.</p>
<p>Un exemple assez explicite pour saisir la nuance entre un effet et un effet de bord est la fonction <code class="sourceCode kotlin">println</code> dont le type pourrait être <code class="sourceCode kotlin">println(x: <span class="kw">String</span>) : <span class="kw">Unit</span></code>. En lisant la signature de type de cette fonction, on a très peu d’information sur ce que <strong>fait</strong> la fonction. On pourrait croire qu’elle “prend une chaine de caractères” et “n’en fait rien”. Même si le nom de la fonction peut nous transmettre une intuition assez précise sur “ce que fait réellement la fonction”, la signature de type n’est pas suffisante.</p>
<p>On voudrait (idéalement) que toute nos signatures nous offrent la clareté de la signature de <code class="sourceCode kotlin">map</code>, par exemple : <code class="sourceCode kotlin">List&lt;A&gt;.map(f : (A) -&gt; B) : List&lt;B&gt;</code> (qui exprime assez clairement que, l’application de la méthode <code class="sourceCode kotlin">map</code> sur une liste de <code class="sourceCode kotlin">A</code> avec une fonction qui va de <code class="sourceCode kotlin">A</code> vers <code class="sourceCode kotlin">B</code>, produira une liste de <code class="sourceCode kotlin">B</code>, donc que l’on va appliquer la fonction donnée en argument sur tous les éléments de la liste).</p>
<p>Un autre exemple serait la distinction entre l’utilisation d’exceptions vérifiées contre l’utilisation d’exceptions non vérifiées. Par exemple, voici l’implémentation, en Java, suivi d’en Kotlin, d’une fonction qui mime l’implémentation d’une division :</p>
<div class="sourceCode" id="cb4" data-roe-kind="code" data-pellet="Java" data-line-number="true"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">public</span> <span class="dt">int</span> <span class="fu">divide</span>(numerator: <span class="dt">int</span>, denominator: <span class="dt">int</span>) </a>
<a class="sourceLine" id="cb4-2" title="2">   <span class="kw">throws</span> DivisionByZeroException {</a>
<a class="sourceLine" id="cb4-3" title="3">   <span class="kw">if</span> (denominator == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb4-4" title="4">      <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">DivisionByZeroException</span>();</a>
<a class="sourceLine" id="cb4-5" title="5">   }</a>
<a class="sourceLine" id="cb4-6" title="6">   <span class="kw">return</span> numerator / denominator;</a>
<a class="sourceLine" id="cb4-7" title="7">}</a></code></pre></div>
<p>Ici, l’exception que la fonction peut émettre est reflétée dans la signature de type. En Kotlin, on écrit généralement des fonctions qui émettent des exceptions non vérifiées :</p>
<div class="sourceCode" id="cb5" data-roe-kind="code" data-pellet="Kotlin" data-line-number="true"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">fun</span> <span class="fu">divide</span>(<span class="va">numerator</span>: <span class="dt">Int</span>, <span class="va">denominator</span>: <span class="dt">Int</span>) : <span class="dt">Int</span> {</a>
<a class="sourceLine" id="cb5-2" title="2">   <span class="cf">if</span> (denominator == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb5-3" title="3">     <span class="kw">throw</span> DivisionByZeroException()</a>
<a class="sourceLine" id="cb5-4" title="4">   }</a>
<a class="sourceLine" id="cb5-5" title="5">   <span class="kw">return</span> numerator / denominator</a>
<a class="sourceLine" id="cb5-6" title="6">}</a></code></pre></div>
<p>Dans cet exemple, la signature de type ne reflète pas l’exception pouvant être émise par la fonction. Par contre, je ne fais pas l’apologie des exceptions vérifiées qui <a href="http://radio-weblogs.com/0122027/stories/2003/04/01/JavasCheckedExceptionsWereAMistake.html">posent beaucoup de soucis</a> (pour beaucoup de raisons). De plus, les exceptions vérifiées ne couvrent le reflet que d’un seul type d’effets (l’exception) et l’on voudrait plus de précision.</p>
<p>Certains pourraient voir, en cette envie de refléter les effets dans la signature de type, de l’hystérie de fanatiques des systèmes de types… c’est probable. Mon opinion est que l’on voudrait que nos systèmes de types expriment le plus de choses possibles, dans la mesure de la <em>turing-complétude</em> (mais pas toujours). De ce fait, mettre en lumière les effets dans la signature de types permet de transformer des effets de bord en effets, ce qui est à mon sens bénéfique. Les fonctions ne mentiront plus sur ce qu’elles font !</p>
<p>Plus formellement, dans beaucoup de langages statiquement typés :</p>
<ul>
<li>on propose <strong><code class="sourceCode haskell">Γ ⊢ e <span class="fu">:</span> τ</code></strong> soit “<em>une variable dans l’environnement</em> <em><code class="sourceCode haskell">Γ</code>, une expression <code class="sourceCode haskell">e</code> à le type <code class="sourceCode haskell">τ</code></em>”.</li>
<li>on voudrait <strong><code class="sourceCode haskell">Γ ⊢ e <span class="fu">:</span> τ <span class="fu">&amp;</span> effects</code></strong> soit “<em>une variable dans</em> <em>l’environnement <code class="sourceCode haskell">Γ</code>, une expression <code class="sourceCode haskell">e</code> à le</em> <em>type <code class="sourceCode haskell">τ</code> et produit les effets <code class="sourceCode haskell">effects</code></em>”.</li>
</ul>
<p>Ce qui donnerait, par exemple, pour une fonction dont le rôle serait d’écrire sur la sortie standard un message et qui a généralement le type :</p>
<div class="sourceCode" id="cb6" data-roe-kind="code"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">val</span> <span class="dt">print_string</span> : <span class="dt">string</span> -&gt; <span class="dt">unit</span></a></code></pre></div>
<p>Nous aurions plutôt cette signature :</p>
<div class="sourceCode" id="cb7" data-roe-kind="code"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">val</span> <span class="dt">print_string</span> : <span class="dt">string</span> -&gt; <span class="dt">unit</span> &amp; <span class="dt">output</span></a></code></pre></div>
<p>ce qui correspond à dire, au travers de la signature de type que même si la fonction ne renvoie rien, elle écrit aussi sur la sortie standard.</p>
<p>Pour résumer, un effet de bord est un effet qui n’est pas mis en lumière dans le programme, qui arrive donc de manière non contrôlé et que l’on voudrait éviter (dans la mesure du possible, il existe des effets que l’on ne peut pas du tout contrôler dans le programme, par exemple, si l’ordinateur qui l’exécute n’a plus assez de mémoire pour exécuter le programme). Une manière d’informer l’utilisateur ou l’utilisatrice qu’une fonction produit un effet serait de faire refléter les effets produits par une fonction dans sa signature de type. Les systèmes d’effets répondent en grande partie à ce genre problèmes et c’est ce que nous tâcherons de découvrir dans les rubriques suivantes !</p>
<h2 id="transformation-de-fonctions-impures-en-fonctions-pures">Transformation de fonctions impures en fonctions pures</h2>
<p>Maintenant que nous avons une idée globale de ce qu’est un effet, de ce que sont les fonctions pures et impures, nous allons pouvoir observer une première technique de “contrôle des effets” qui consiste <em>simplement</em> à transformer une fonction impure en fonction pure.</p>
<p>Lorsque nous avons tâché de définir une fonction pure, nous avons évoqué le fait qu’une fonction devait être <strong>totale</strong>, soit que pour tout paramètre, elle doit avoir un résultat. Comme toute fonction qui n’est pas pure est impure, une fonction qui n’est pas totale est impure, donc on pourrait considérer que la non-totalité d’une fonction est un effet. De ce fait, prendre une fonction non-totale et la rendre totale serait une forme de gestion d’effets. Prenons par exemple la fonction OCaml <code class="sourceCode ocaml"><span class="dt">List</span>.hd</code> qui prend une liste et renvoie sa tête (son premier élément) et dont le type serait <code class="sourceCode ocaml"><span class="kw">val</span> hd : 'a <span class="dt">list</span> -&gt; 'a</code> :</p>
<div class="sourceCode" id="cb8" data-roe-kind="code" data-pellet="OCaml" data-line-number="true"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">let</span> hd <span class="dt">list</span> = </a>
<a class="sourceLine" id="cb8-2" title="2">  <span class="kw">match</span> <span class="dt">list</span> <span class="kw">with</span> </a>
<a class="sourceLine" id="cb8-3" title="3">  | [] -&gt; <span class="dt">failwith</span> <span class="st">&quot;List.hd empty list&quot;</span></a>
<a class="sourceLine" id="cb8-4" title="4">  | x :: _ -&gt; x</a></code></pre></div>
<p>Concrètement, le type de cette fonction nous dit <em><strong>pour une liste de</strong></em> <em><strong><code class="sourceCode ocaml">'a</code> (donc de “quelque chose”), je renvoie un élément <code class="sourceCode ocaml">'a</code></strong></em>. Cette fonction n’est pas totale car il existe, ici, un cas pour lequel il n’existe pas de valeur possible. Le cas où la liste est vide, et qui engendre le lancement d’une exception.</p>
<p>Pour rendre cette fonction totale, il suffit de trouver un nouveau type capable de représenter l’ensemble des valeurs possibles. Les langages fonctionnels statiquement typés ont popularisé l’utilisation d’un type spécifique qui permet de représenter la disjonction entre la présence de valeur ou son absence :</p>
<div class="sourceCode" id="cb9" data-roe-kind="code" data-pellet="OCaml" data-line-number="true"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">type</span> 'a <span class="dt">option</span> = </a>
<a class="sourceLine" id="cb9-2" title="2">  | <span class="dt">Some</span> <span class="kw">of</span> 'a </a>
<a class="sourceLine" id="cb9-3" title="3">  | <span class="dt">None</span></a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="kw">let</span> hd <span class="dt">list</span> = </a>
<a class="sourceLine" id="cb9-6" title="6">  <span class="kw">match</span> <span class="dt">list</span> <span class="kw">with</span> </a>
<a class="sourceLine" id="cb9-7" title="7">  | [] -&gt; <span class="dt">None</span></a>
<a class="sourceLine" id="cb9-8" title="8">  | x :: _ -&gt; <span class="dt">Some</span> x</a></code></pre></div>
<p>Concrètement, le type <code class="sourceCode ocaml">'a <span class="dt">option</span></code> (qui exprime “<em>une option de quelque chose</em>”) est défini par deux constructeurs :</p>
<ul>
<li><code class="sourceCode ocaml"><span class="dt">Some</span> x</code> pour représenter la présence d’une valeur ;</li>
<li><code class="sourceCode ocaml"><span class="dt">None</span></code> pour représenter l’absence de valeur.</li>
</ul>
<p>L’utilisation du type <code class="sourceCode ocaml"><span class="dt">option</span></code> altère le type de notre fonction, qui devient : <code class="sourceCode ocaml"><span class="kw">val</span> hd : 'a <span class="dt">list</span> -&gt; 'a <span class="dt">option</span></code> et rend notre fonction <strong>totale</strong>.</p>
<p>Même si cette modification semble anodine, nous avons transformé une fonction impure en fonction pure. Cependant, le changement de type change sensiblement la sémantique de la fonction <code class="sourceCode ocaml">hd</code>. De ce fait, si l’on veut exécuter un programme qui utilise notre nouvelle fonction <code class="sourceCode ocaml">hd</code>, il faudra <strong>gérer manuellement le cas où nous n’avons pas de valeur</strong>.</p>
<p>Construisons un programme qui affiche, sur la sortie standard, un message de bienvenue au premier prénom d’une liste de prénoms :</p>
<div class="sourceCode" id="cb10" data-roe-kind="code" data-pellet="OCaml" data-line-number="true" data-line-start="9"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">let</span> () = </a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="kw">match</span> hd [<span class="st">&quot;Xavier&quot;</span>; <span class="st">&quot;Nicolas&quot;</span>] <span class="kw">with</span> </a>
<a class="sourceLine" id="cb10-3" title="3">  | <span class="dt">None</span> -&gt; <span class="dt">Format</span>.printf <span class="st">&quot;Hello anonymous !&quot;</span></a>
<a class="sourceLine" id="cb10-4" title="4">  | <span class="dt">Some</span> user -&gt; <span class="dt">Format</span>.printf <span class="st">&quot;Hello %s !&quot;</span> user</a></code></pre></div>
<p>A ce stade, notre fonction <code class="sourceCode ocaml">hd</code> a beau être pure, notre exécution ne l’est pas. Cependant, cela se rapproche de ce que l’on a esquissé en début d’article, la séparation entre <strong>la partie pure</strong> et <strong>la partie impure</strong>. Concrètement, on a <strong>un programme</strong>, dont le rôle est de décrire les opérations, et un <strong>gestionnaire de programme</strong> dont le rôle est d’exécuter la description du programme.</p>
<p>C’est typiquement ce genre de transformation qu’utilise le langage <strong>Haskell</strong> pour ne permettre la manipulation que de fonctions pures.</p>
<h3 id="aparté-sur-haskell">Aparté sur Haskell</h3>
<p>Quand on se rend sur le <a href="https://haskell.org">site web de Haskell</a>, on peut y lire que Haskell est un langage de programmation fonctionnelle pure avancé.</p>
<p>Haskell est l’archétype du langage fonctionnel pur, qui fait intensivement usage de la technique présentée dans la rubrique précédente, visant à transformer les effets en valeurs. Cependant, contrairement à l’exemple que nous avons présenté, le langage interdit les effets de bords, y comprit dans la fonction qui va <strong>interpréter</strong> une fonction produisant un effet. Pour comprendre où la magie opère, observons un “Hello World” en Haskell.</p>
<div class="sourceCode" id="cb11" data-roe-kind="code" data-pellet="Haskell" data-line-number="true"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-2" title="2">main <span class="fu">=</span> </a>
<a class="sourceLine" id="cb11-3" title="3">  <span class="fu">putStrLn</span> <span class="st">&quot;Hello World!&quot;</span></a></code></pre></div>
<p>Ici, <code class="sourceCode haskell">main</code> est une valeur de type <code class="sourceCode haskell"><span class="dt">IO</span> ()</code>, on peut donc deviner le type de la fonction <code class="sourceCode haskell"><span class="fu">putStrLn</span></code> : <code class="sourceCode haskell"><span class="fu">putStrLn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code>. En fait, <code class="sourceCode haskell">main</code> est une fonction qui ne produit aucun effet, il s’agit simplement d’une variable de type <code class="sourceCode haskell"><span class="dt">IO</span> ()</code> ne <strong>faisant rien</strong>, comme l’indique le site web de Haskell sur sa page d’accueil (rubrique <strong>Purely functional</strong>) :</p>
<div class="roe" data-roe-kind="quote" data-where="https://haskell.org">
<p>Every function in Haskell is a function in the <strong>mathematical</strong> sense (i.e., “pure”). Even side-effecting IO operations are but a <strong>description</strong> of what to do, produced by <strong>pure</strong> code. There are no statements or instructions, only expressions which cannot mutate variables (local or global) nor access state like time or random numbers.</p>
</div>
<p>Cette explication met en lumière quelque chose d’assez important. En Haskell, on n’écrit pas de programme “qui fait quelque chose”, on <strong>écrit des</strong> <strong>descriptions de programmes</strong>. En compilant un programme, on vérifie statiquement la cohérence des types, et ensuite on attache la description du programme au <em>runtime</em> Haskell, et ce sera lui qui exécutera les effets. Cette approche permet la <strong>séparation systématique</strong> entre la partie pure et la partie impure du programme, ce que l’on cherche à faire depuis le début de cet article et le fait de déléguer au <em>runtime</em> ! Le programme devient donc facilement testable, et il délègue à une pièce logicielle éprouvée et correctement testée l’exécution d’effets.</p>
<p>Plus formellement, l’ensemble des effets communs auquel on fait face quand on construit un logiciel est transformé en valeurs, ces valeurs correspondent à la description d’effets :</p>
<ul>
<li><code class="sourceCode haskell"><span class="dt">List</span> a</code> pour le non-déterminisme ;</li>
<li><code class="sourceCode haskell"><span class="dt">Maybe</span> a</code> pour l’absence potentielle de valeur ;</li>
<li><code class="sourceCode haskell"><span class="dt">Either</span> <span class="fu">error</span> a</code> pour l’équivalent des exceptions ;</li>
<li><code class="sourceCode haskell"><span class="dt">IO</span> a</code> pour les entrées sorties ;</li>
<li>et bien d’autres, il est même possible de construire ses propres effets.</li>
</ul>
<p>Et l’objectif du développeur est de réduire ces représentations jusqu’à un <code class="sourceCode haskell"><span class="dt">IO</span> ()</code> qui correspondra à la description finale du programme et qui sera interprétée par le <em>runtime</em> Haskell. En complément de cette fragmentation systématique entre les parties pures et impures du programme, Haskell permet de refléter dans la signature de type l’effet que produira une fonction. Pour y arriver, Haskell utilise son système de type, sans y apporter de modification, donc <code class="sourceCode haskell">unit <span class="fu">&amp;</span> io</code> s’écrirait <code class="sourceCode haskell"><span class="dt">IO</span> ()</code>, <code class="sourceCode haskell">()</code> voulant dire <code class="sourceCode haskell">unit</code>. Parallèlement, la fonction lisant l’entrée standard sera exprimé de cette manière <code class="sourceCode haskell"><span class="fu">getLine</span><span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">String</span></code>.</p>
<p>Cette manière de transformer un calcul qui doit produire une valeur de type <code class="sourceCode haskell">a</code> en un <code class="sourceCode haskell"><span class="dt">T</span> a</code> (qui sera ensuite interprété) utilise généralement deux types (parfois plus) de constructions : <a href="https://wiki.haskell.org/Monad">des monades</a> ou <a href="https://wiki.haskell.org/Applicative_functor">des foncteurs applicatifs</a>. C’est une technique qui s’inspire de la <a href="https://en.wikipedia.org/wiki/Category_theory">théorie des catégories</a> et qui peut très souvent être intimidante quand on débute en programmation fonctionnelle, spécifiquement avec le langage Haskell. Cependant, au delà de la cérémonie engendrée par cette approche, elle peut sembler idéale pour plusieurs raisons :</p>
<ul>
<li>elle fait refléter dans le système de type, le type de l’effet produit par une fonction ;</li>
<li>elle ne permet de décrire que des fragments de programme pure, donc facilement testables ;</li>
<li>la partie impure du programme, n’interprétant que la partie pure, étant éprouvée et testée ;</li>
</ul>
<p>Rien que pour ces bénéfices (et Haskell possède beaucoup d’autres atouts), apprendre Haskell est, pédagogiquement, très intéressant. De plus, le langage dispose de beaucoup de <em>success-stories</em> et de ressources.</p>
<p>Cependant, même si nous semblons, au vue de mes propos, avoir trouvé, en Haskell, la panacée, on pourrait tout de même reprocher plusieurs chose à cette approche sans compléments. La première est que comme <code class="sourceCode haskell"><span class="dt">IO</span> a</code> est ce vers quoi toute expression à effets doit être réduit. De ce fait, <code class="sourceCode haskell"><span class="dt">IO</span></code> n’est, au final, qu’un marqueur sur une fonction, on se contente de rendre compte que la fonction produira un effet (ou plusieurs) si elle renvoie un <code class="sourceCode haskell"><span class="dt">IO</span></code>. Sémantiquement, on détient très peu d’informations sur quels effets seront produits par la fonction.</p>
<p>Haskell propose plusieurs solutions, dont certaines qui miment l’API des effets algébriques dont je parlerai dans la section suivante. Ces solutions proposent chacunes des avantages différents.</p>
<h2 id="les-effets-algébriques-et-leurs-gestionnaires">Les effets algébriques et leurs gestionnaires</h2>
<p>Nous avons vu qu’Haskell, en ne permettant que d’écrire des descriptions de programmes, force le fait que chaque fonction soit pure. Par défaut, Haskell force la réduction en une expression de type <code class="sourceCode haskell"><span class="dt">IO</span> ()</code> qui sera ensuite interprétée par le <em>runtime</em> de Haskell. Les effets algébriques proposent une approche similaire, reposant sur de solides fondations issues de la théorie des catégories. Cependant, pour que l’article tâche de rester le plus digeste possible, je tâcherai de placer la focale sur leur utilisation !</p>
<p>Concrètement, les effets algébriques munis de gestionnaires proposent de découper un programme en trois parties distinctes :</p>
<ul>
<li>la description des effets possibles ;</li>
<li>la description du programme exécutant les effets ;</li>
<li>un interpréteur capable d’effectuer une action concrète pour un effet donné (le fameux gestionnaire).</li>
</ul>
<p>Il serait possible de faire une projection très naïve de cette approche en Java, au moyen d’exceptions. Premièrement, on déclare les effets d’un programme :</p>
<div class="sourceCode" id="cb12" data-roe-kind="code" data-pellet="Java" data-line-number="true" data-file="description des effets"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">public</span> <span class="kw">interface</span> MyEffects {} <span class="co">// Si seulement nous avions des familles</span></a>
<a class="sourceLine" id="cb12-2" title="2">                              <span class="co">// scellées !</span></a>
<a class="sourceLine" id="cb12-3" title="3"></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="kw">public</span> <span class="kw">class</span> MyFirstEffect <span class="kw">extends</span> <span class="bu">Exception</span> <span class="kw">implements</span> MyEffects {</a>
<a class="sourceLine" id="cb12-5" title="5">  <span class="kw">public</span> <span class="fu">MyFirstEffect</span>(<span class="bu">String</span> message) {</a>
<a class="sourceLine" id="cb12-6" title="6">    <span class="kw">super</span>(message);</a>
<a class="sourceLine" id="cb12-7" title="7">  }</a>
<a class="sourceLine" id="cb12-8" title="8">}</a>
<a class="sourceLine" id="cb12-9" title="9"><span class="kw">public</span> <span class="kw">class</span> MySecondEffect <span class="kw">extends</span> <span class="bu">Exception</span> <span class="kw">implements</span> MyEffects {</a>
<a class="sourceLine" id="cb12-10" title="10">  <span class="kw">public</span> <span class="fu">MySecondEffect</span>(<span class="bu">String</span> message) {</a>
<a class="sourceLine" id="cb12-11" title="11">    <span class="kw">super</span>(message);</a>
<a class="sourceLine" id="cb12-12" title="12">  }</a>
<a class="sourceLine" id="cb12-13" title="13">}</a></code></pre></div>
<p>Ensuite on décrit notre programme, et chaque fois qu’il doit exécuter un effet, il lance une exception :</p>
<div class="sourceCode" id="cb13" data-roe-kind="code" data-pellet="Java" data-line-number="true" data-line-start="14" data-file="description du programme"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">public</span> <span class="dt">void</span> <span class="fu">myProgram</span>(a: <span class="dt">int</span>) <span class="kw">throws</span> MyEffects {</a>
<a class="sourceLine" id="cb13-2" title="2">   <span class="kw">if</span>(a == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb13-3" title="3">     <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">MyFirstEffect</span>(<span class="st">&quot;a first effect&quot;</span>);</a>
<a class="sourceLine" id="cb13-4" title="4">   } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb13-5" title="5">     <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">MySecondEffect</span>(<span class="st">&quot;a second effect&quot;</span>);</a>
<a class="sourceLine" id="cb13-6" title="6">   }</a>
<a class="sourceLine" id="cb13-7" title="7">}</a></code></pre></div>
<p>Et une fois que notre programme est décrit, on peut facilement en écrire son interpréteur, qui ici, ne consiste qu’en une succession de captures d’exception.</p>
<div class="sourceCode" id="cb14" data-roe-kind="code" data-pellet="Java" data-line-number="true" data-line-start="21" data-file="interprétation du programme"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">public</span> <span class="dt">void</span> <span class="fu">main</span>() {</a>
<a class="sourceLine" id="cb14-2" title="2">  <span class="kw">try</span> {</a>
<a class="sourceLine" id="cb14-3" title="3">    <span class="fu">myProgram</span>();</a>
<a class="sourceLine" id="cb14-4" title="4">  } <span class="kw">catch</span>(effect: MyFirstEffect) {</a>
<a class="sourceLine" id="cb14-5" title="5">    <span class="co">// Do something with my first effect</span></a>
<a class="sourceLine" id="cb14-6" title="6">  } <span class="kw">catch</span>(effect: MySecondEffect) {</a>
<a class="sourceLine" id="cb14-7" title="7">   <span class="co">// Do something with my second effect</span></a>
<a class="sourceLine" id="cb14-8" title="8">  }</a>
<a class="sourceLine" id="cb14-9" title="9">}</a></code></pre></div>
<p>Ce programme à l’air de respecter les objectifs que nous avons posés car il reflète, dans sa signature, l’effet exécuté par le programme (au moyen de <code class="sourceCode java"><span class="kw">throws</span></code>) et on interpréte, ici dans <code class="sourceCode java">main</code> la description du programme, ce qui permettrait assez facilement de le tester unitairement.</p>
<p>Malheureusement (et de manière assez prévisible), notre exemple fonctionne plus ou moins uniquement parce que l’exemple est incroyablement biaisé. L’expression <code class="sourceCode java"><span class="kw">throw</span> <span class="kw">new</span> ...</code> interrompt la fonction et remonte jusqu’a un gestionnaire qui prend en charge l’exception émise par l’appel de <code class="sourceCode java"><span class="kw">throw</span></code>. De ce fait, nous ne pouvons pas utiliser les exceptions pour exprimer l’exécution d’effets séquentiels, de cette manière :</p>
<div class="sourceCode" id="cb15" data-roe-kind="code" data-pellet="Java" data-line-number="true"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">public</span> <span class="dt">void</span> <span class="fu">myProgram</span>(a: <span class="dt">int</span>) <span class="kw">throws</span> MyEffects {</a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">MyFirstEffect</span>(<span class="st">&quot;a first effect&quot;</span>);</a>
<a class="sourceLine" id="cb15-3" title="3">  <span class="kw">throw</span> <span class="kw">new</span> <span class="fu">MySecondEffect</span>(<span class="st">&quot;a second effect&quot;</span>);</a>
<a class="sourceLine" id="cb15-4" title="4">}</a></code></pre></div>
<p>Dans cet exemple, l’exécution du second effet n’aura jamais lieu, parce que la capture de l’effet ne permet jamais de revenir à l’endroit où l’effet a été exécuté. Cela s’explique parce que la primitive <code class="sourceCode java"><span class="kw">throw</span></code> ne <strong>capture pas la continuation qui représente la suite du calcul</strong>. Rassurez-vous, les effets algébriques, eux, le font !</p>
<p>Mais concrètement, qu’est ce qu’une continuation ? Informellement, la continuation d’un programme (ou d’une fonction) correspond à ce qu’il reste à évaluer. Par exemple :</p>
<div class="sourceCode" id="cb16" data-roe-kind="code" data-pellet="Kotlin" data-line-number="true" data-hl="3;4"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">fun</span> <span class="fu">f</span>() {</a>
<a class="sourceLine" id="cb16-2" title="2">   println(<span class="st">&quot;Hello&quot;</span>)</a>
<a class="sourceLine" id="cb16-3" title="3">   println(<span class="st">&quot;World&quot;</span>)</a>
<a class="sourceLine" id="cb16-4" title="4">   println(<span class="st">&quot;How are you?&quot;</span>)</a>
<a class="sourceLine" id="cb16-5" title="5">}</a></code></pre></div>
<p>Après avoir exécuté la première ligne de la fonction, et avoir affiché <code class="sourceCode java"><span class="st">&quot;Hello&quot;</span></code>, la continuation correspond aux deux lignes suivantes. Dans certains langages, comme <strong>JavaScript</strong>, il est parfois nécéssaire d’abuser des continuations pour synchroniser un programme. En effet, comme chaque appel de fonction est exécuté de manière asynchrone, une pratique courante à vu le jour, le passage de <strong><em>callbacks</em></strong>, qui n’est, au final, qu’un autre nom pour <strong>continuation</strong>, par exemple :</p>
<div class="sourceCode" id="cb17" data-roe-kind="code" data-pellet="JavaScript" data-line-number="true"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb17-1" title="1"><span class="at">performAsyncComputation</span>(x<span class="op">,</span> <span class="kw">function</span>(result) <span class="op">{</span></a>
<a class="sourceLine" id="cb17-2" title="2">   <span class="cf">return</span> <span class="at">performAnotherAsyncComputation</span>(result<span class="op">,</span> <span class="kw">function</span>(newResult) <span class="op">{</span></a>
<a class="sourceLine" id="cb17-3" title="3">      <span class="va">console</span>.<span class="at">log</span>(newResult)<span class="op">;</span></a>
<a class="sourceLine" id="cb17-4" title="4">   <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb17-5" title="5"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>Dans cet exemple, on spécifie explicitement les continuations au moyen du passage de fonction par argument. Comme chaque étape d’un calcul par continuation engendre généralement un niveau d’indentation pouvant vite devenir illisible (le fameux <em>callback hell</em>), il existe des techniques d’encodages pour éviter cet ajout de niveau à chaque étape. Dans certains langages, cela se fait au moyen d’opérateurs, en JavaScript, c’est généralement au moyen d’une méthode <code class="sourceCode javascript"><span class="at">then</span>(callback)</code>. Oui, les promesses sont une forme spécifique de continuation.</p>
<p>Observons maintenant l’utilisation concrète des effets algébriques au moyen d’un petit programme à effets, a priori compliqué à tester !</p>
<h3 id="un-petit-programme-à-effets">Un petit programme à effets</h3>
<p>Prenons un premier programme, assez simple à implémenter, mais autrement plus compliqué à rendre pur :</p>
<div class="sourceCode" id="cb18" data-roe-kind="code" data-pellet="Kotlin" data-line-number="true"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">fun</span> <span class="fu">sayHello</span>() {</a>
<a class="sourceLine" id="cb18-2" title="2">  println(<span class="st">&quot;What is your name?&quot;</span>)</a>
<a class="sourceLine" id="cb18-3" title="3">  <span class="kw">val</span> <span class="va">name</span> = readLine()!!</a>
<a class="sourceLine" id="cb18-4" title="4">  println(<span class="st">&quot;Hello $name&quot;</span>)</a>
<a class="sourceLine" id="cb18-5" title="5">}</a>
<a class="sourceLine" id="cb18-6" title="6"></a>
<a class="sourceLine" id="cb18-7" title="7"><span class="kw">fun</span> <span class="fu">main</span>() {</a>
<a class="sourceLine" id="cb18-8" title="8">  sayHello()</a>
<a class="sourceLine" id="cb18-9" title="9">}</a></code></pre></div>
<p>Le programme se contente de demander à l’utilisateur de saisir son nom et ensuite affiche un message de bienvenue !</p>
<p>Pour tâcher de transformer ce programme en une description que nous interpréterons dans le <code class="sourceCode kotlin">main()</code> nous pourrions tenter de le transformer en une liste d’actions (qui décrirons nos effets). Par exemple :</p>
<div class="sourceCode" id="cb19" data-roe-kind="code" data-pellet="Kotlin" data-line-number="true"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">sealed</span> <span class="kw">class</span> Effect</a>
<a class="sourceLine" id="cb19-2" title="2"><span class="kw">data</span> <span class="kw">class</span> Print(<span class="kw">val</span> <span class="va">message</span>: <span class="dt">String</span>) : <span class="dt">Effect</span>()</a>
<a class="sourceLine" id="cb19-3" title="3"><span class="kw">data</span> <span class="kw">class</span> Ask() : <span class="dt">Effect</span>()</a></code></pre></div>
<p>Ensuite, nous pouvons décrire notre programme au moyen d’une liste :</p>
<div class="sourceCode" id="cb20" data-roe-kind="code" data-pellet="Kotlin" data-line-number="true" data-line-start="4"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">val</span> <span class="va">program</span> : List&lt;Effect&gt; = listOf(</a>
<a class="sourceLine" id="cb20-2" title="2">   Print(<span class="st">&quot;What is your name&quot;</span>)</a>
<a class="sourceLine" id="cb20-3" title="3">,  Ask()</a>
<a class="sourceLine" id="cb20-4" title="4">,  Print(<span class="st">&quot;Hello you&quot;</span>)</a>
<a class="sourceLine" id="cb20-5" title="5">)</a></code></pre></div>
<p>Et il ne nous reste plus qu’a interpréter notre programme :</p>
<div class="sourceCode" id="cb21" data-roe-kind="code" data-pellet="Kotlin" data-line-number="true" data-line-start="9"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">fun</span> <span class="fu">run</span>(<span class="va">e</span>: <span class="dt">Effect</span>) {</a>
<a class="sourceLine" id="cb21-2" title="2">  <span class="cf">when</span> (e) {</a>
<a class="sourceLine" id="cb21-3" title="3">    <span class="kw">is</span> Print -&gt; println(e.message)</a>
<a class="sourceLine" id="cb21-4" title="4">    <span class="kw">is</span> Ask   -&gt; {</a>
<a class="sourceLine" id="cb21-5" title="5">       <span class="kw">val</span> <span class="va">name</span> = readLine()!!</a>
<a class="sourceLine" id="cb21-6" title="6">       println(name)</a>
<a class="sourceLine" id="cb21-7" title="7">    } </a>
<a class="sourceLine" id="cb21-8" title="8">  }</a>
<a class="sourceLine" id="cb21-9" title="9">}</a>
<a class="sourceLine" id="cb21-10" title="10"></a>
<a class="sourceLine" id="cb21-11" title="11"><span class="kw">fun</span> <span class="fu">List</span>&lt;<span class="dt">Effect</span>&gt;.<span class="fu">run</span>() = forEach { run(it) }</a></code></pre></div>
<p>Même si notre programme semble à peu près correct, il diffère tout de même du programme présenté en exemple. Comme chaque état à effet est interprété de manière indépendante, je ne peux pas transmettre le résultat de <code class="sourceCode kotlin">Ask()</code> à <code class="sourceCode kotlin">Print(x)</code>.</p>
<p>Il existe plusieurs manières de transformer ces séquences d’instructions en une séquence chainée. Les deux plus populaires, dans le monde de la programmation fonctionnelle sont <strong>les monades gratuites</strong> et les <strong>transformations de monades</strong>. Les deux approches proposent des avantages et des inconvénients. Heureusement, il existe une approche qui, selon moi, a le mérite d’être claire et facile à appréhender : <strong>les effets algébriques</strong> et leurs <strong>gestionnaires</strong>.</p>
<h2 id="a-la-découverte-de-koka">A la découverte de Koka</h2>
<p>Pour nous initier aux effets algébriques, nous allons utiliser un langage expérimental développé dans les laboratoires de <strong>Microsoft</strong> qui s’appelle <a href="https://koka-lang.github.io/koka/doc/kokaspec.html">Koka</a> et qui a été développé pour expérimenter l’utilisation des effets algébriques (<em>Koka</em> est le mot Japonais pour <strong>effet</strong>). Le langage propose une syntaxe proche de celle de JavaScript et offre un support <em>first-class</em> des effets algébriques, il peut compiler vers du JavaScript, offre un système de types avec de l’inférence et, à mon sens, est un excellent candidat pour s’initier aux effets algébriques par la pratique !</p>
<p>Comme nous l’avions dit à maintes reprises, une des premières étapes pour la gestion efficace (du point de vue utilisateur) des effets est d’évincer les effets de bords. Koka propose de fournir trois informations sur une fonction :</p>
<ul>
<li>son type d’entrée ;</li>
<li>son type de retour ;</li>
<li>l’ensemble des effets que produit la fonction.</li>
</ul>
<p>Par exemple, la fonction <code class="koka">hello(name)</code>, implémentée de la sorte :</p>
<div class="sourceCode" id="cb22" data-roe-kind="code" data-pellet="Koka" data-line-number="true"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">fun</span> hello(name) {</a>
<a class="sourceLine" id="cb22-2" title="2">  println(<span class="st">&quot;Hello &quot;</span> + name + <span class="st">&quot;!&quot;</span>)</a>
<a class="sourceLine" id="cb22-3" title="3">}</a></code></pre></div>
<p>Aura le type <code class="sourceCode ocaml">(name: <span class="dt">string</span>) -&gt; console ()</code>. Ici <code class="sourceCode ocaml">console ()</code> indique que la fonction ne renvoie rien (<code class="sourceCode ocaml">()</code>) mais qu’elle produit l’effet <code class="sourceCode ocaml">console</code> (un effet capable d’interagir avec la console).</p>
<p>La fonction <code class="sourceCode ocaml">hello</code> est exécutable par Koka car la bibliothèque standard du langage offre un gestionnaire pour l’effet <code class="sourceCode ocaml">console</code>. Quand on tente d’exécuter une fonction qui exécute des effets, le compilateur va d’abord vérifier s’il existe un gestionnaire pour l’effet que l’on essaie d’exécuter. Si aucun gestionnaire n’est trouvé, le programme ne compilera pas. Si par contre il existe un gestionnaire, Koka s’en servira pour exécuter un programme. Ne vous en faites pas, nous allons tout de suite montrer un exemple.</p>
<h3 id="notre-premier-effet">Notre premier effet</h3>
<p>Un premier effet assez simple à modeliser est l’effet qui dit d’afficher un message. Koka offre une construction pour modeliser un ensemble d’effets attaché à un même type. On peut voir cette construction comme une interface. Par exemple :</p>
<div class="sourceCode" id="cb23" data-roe-kind="code" data-pellet="Koka" data-line-number="true"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb23-1" title="1">effect mumble {</a>
<a class="sourceLine" id="cb23-2" title="2">  <span class="kw">fun</span> grumble(message: <span class="dt">string</span>) : ()</a>
<a class="sourceLine" id="cb23-3" title="3">}</a></code></pre></div>
<p>On déclare un effet <strong>grumble(message)</strong> qui propagera le type <strong>mumble</strong>. Je peux maintenant utiliser la fonction <code class="sourceCode ocaml">grumble</code> dans une fonction, qui deviendra alors la description d’un programme :</p>
<div class="sourceCode" id="cb24" data-roe-kind="code" data-pellet="Koka" data-line-number="true" data-line-start="4"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">fun</span> mumbling() : mumble () {</a>
<a class="sourceLine" id="cb24-2" title="2">  // A noter que la spécification du <span class="kw">type</span> est assez </a>
<a class="sourceLine" id="cb24-3" title="3">  // inutile, Koka est capable d'inférer le <span class="kw">type</span> de la fonction</a>
<a class="sourceLine" id="cb24-4" title="4">  grumble(<span class="st">&quot;Hello World!&quot;</span>)</a>
<a class="sourceLine" id="cb24-5" title="5">}</a></code></pre></div>
<p>Notre fonction a le type <code class="sourceCode ocaml">() -&gt; mumble ()</code>, c’est-à-dire qu’elle ne prend aucun argument, ne renvoie aucune valeur mais son exécution propagera l’effet <code class="sourceCode ocaml">mumble</code>. Que se passe-t-il si j’essaie d’exécuter cette fonction ?</p>
<div class="sourceCode" id="cb25" data-roe-kind="code" data-pellet="Koka"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb25-1" title="1">(<span class="dv">1</span>, <span class="dv">0</span>): error: there are unhandled effects <span class="cf">for</span> the main expression</a>
<a class="sourceLine" id="cb25-2" title="2">  inferred effect: test/mumble</a>
<a class="sourceLine" id="cb25-3" title="3">  hint           : wrap the main function <span class="kw">in</span> a handler</a></code></pre></div>
<p>La fonction n’est pas exécutable car Koka ne sait pas comment interpréter notre effet <code class="sourceCode ocaml">grumble</code>. Il faut donc lui fournir un gestionnaire.</p>
<h3 id="notre-premier-gestionnaire">Notre premier gestionnaire</h3>
<p>Maintenant que nous avons déclaré notre premier effet, nous allons l’interpréter ! Pour ça, Koka offre une construction syntaxique : <code class="sourceCode ocaml">my_handler_for_mumble{mumbling()</code>}</p>
<p>Pour laquelle il faudra fournir une valeur pour <code class="sourceCode ocaml">my_handler_for_mumble</code>. L’inteprétation d’un effet est assez simple, il suffit de traiter les branches possibles de l’effet. Ici nous n’en avons qu’une seule :</p>
<div class="sourceCode" id="cb26" data-roe-kind="code" data-pellet="Koka" data-line-number="true" data-line-start="9"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">val</span> mumble_handler = handler {</a>
<a class="sourceLine" id="cb26-2" title="2">  grumble(message) -&gt; println(message)</a>
<a class="sourceLine" id="cb26-3" title="3">}</a>
<a class="sourceLine" id="cb26-4" title="4"></a>
<a class="sourceLine" id="cb26-5" title="5">// On peut maintenant exécuter notre programme à effet !</a>
<a class="sourceLine" id="cb26-6" title="6">mumble_handler{ mumbling() }</a>
<a class="sourceLine" id="cb26-7" title="7">// Affichera sur la sortie standard <span class="st">&quot;Hello World!&quot;</span></a></code></pre></div>
<p>Concrètement, on définit une variable qui va, pour chaque effet possible, proposer <strong>une réaction à l’émission d’un effet</strong>. L’application de notre gestionnaire n’est pas pure, par contre, la description de notre programme l’est entièrement. Si dans mon gestionnaire, j’avais propagé un effet n’ayant pas de gestionnaire, j’aurais dû fournir un gestionnaire à mon gestionnaire ! Un peu à la manière de Haskell, utilisé <em>normalement</em>, l’écriture d’un gestionnaire implique de <strong>réduire un effet jusqu’a arriver</strong> <strong>à un effet attaché à un gestionnaire</strong>.</p>
<p>Essayons de voir si notre propagation/gestion d’effets est supérieure à ce que l’on avait écrit à base d’exceptions en émettant, dans notre fonction, deux fois l’effet <code class="sourceCode ocaml">grumble</code> :</p>
<div class="sourceCode" id="cb27" data-roe-kind="code" data-pellet="Koka" data-line-number="true"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb27-1" title="1">effect mumble {</a>
<a class="sourceLine" id="cb27-2" title="2">  <span class="kw">fun</span> grumble(message: <span class="dt">string</span>) : ()</a>
<a class="sourceLine" id="cb27-3" title="3">}</a>
<a class="sourceLine" id="cb27-4" title="4"></a>
<a class="sourceLine" id="cb27-5" title="5"><span class="kw">fun</span> mumbling() : mumble () {</a>
<a class="sourceLine" id="cb27-6" title="6">  grumble(<span class="st">&quot;Hello World!&quot;</span>)</a>
<a class="sourceLine" id="cb27-7" title="7">  grumble(<span class="st">&quot;Good bye World!&quot;</span>)</a>
<a class="sourceLine" id="cb27-8" title="8">}</a>
<a class="sourceLine" id="cb27-9" title="9"></a>
<a class="sourceLine" id="cb27-10" title="10"><span class="kw">val</span> mumble_handler = handler {</a>
<a class="sourceLine" id="cb27-11" title="11">  grumble(message) -&gt; println(message)</a>
<a class="sourceLine" id="cb27-12" title="12">}</a>
<a class="sourceLine" id="cb27-13" title="13"></a>
<a class="sourceLine" id="cb27-14" title="14"><span class="kw">fun</span> main() {</a>
<a class="sourceLine" id="cb27-15" title="15">   mumble_handler{ mumbling() }</a>
<a class="sourceLine" id="cb27-16" title="16">}</a>
<a class="sourceLine" id="cb27-17" title="17"></a></code></pre></div>
<p>Ici, le résultat attendu serait que d’abord, le programme affiche <code class="sourceCode ocaml"><span class="st">&quot;Hello World!&quot;</span></code> et qu’ensuite, il affiche à la ligne <code class="sourceCode ocaml"><span class="st">&quot;Good bye World!&quot;</span></code>… malheureusement, ce n’est pas le cas, l’inteprétation de <code class="sourceCode ocaml">mumbling()</code> se contente de n’afficher que <code class="sourceCode ocaml"><span class="st">&quot;Hello World!&quot;</span></code>.</p>
<p>Concrètement, ce qu’il se passe ici, c’est qu’on gère l’effet, et on arrête le programme. Vu comme ça, les effets algébrique semblent assez proche des exceptions. Heureusement, adjoint à la gestion des effets via les gestionnaires, les effets algébriques proposent une fonctionnalité complémentaire : <strong>la capture de la continuation</strong>. En Koka, dans chaque branche de la gestion d’un effet dans un gestionnaire, il existe une fonction <em>ad-hoc</em> qui offre la possibilité de <strong>reprendre</strong> l’interprétation du programme. Contrairement à beaucoup de langages, l’encodage de la continuation est implicite, il n’est pas nécessaire de séquencer des <em>callback</em> ou des successions de <code class="sourceCode javascript">then</code>. Démonstration :</p>
<div class="sourceCode" id="cb28" data-roe-kind="code" data-pellet="Koka" data-line-number="true" data-hl="13" data-line-start="10"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">val</span> mumble_handler = handler {</a>
<a class="sourceLine" id="cb28-2" title="2">  grumble(message) -&gt; {</a>
<a class="sourceLine" id="cb28-3" title="3">     println(message)</a>
<a class="sourceLine" id="cb28-4" title="4">     resume(()) // Reprend le calcul où l'effet a été émis</a>
<a class="sourceLine" id="cb28-5" title="5">  }</a>
<a class="sourceLine" id="cb28-6" title="6">}</a></code></pre></div>
<p>Ce qui nous amène à une définition des effets algébriques relativement accessibles, ce sont <strong>des exceptions <em>resumables</em></strong>. Concrètement, quand on inteprète la description d’un programme au moyen d’un gestionnaire, ce dernier peut décider de continuer l’interprétation du calcul, ou l’interrompre.</p>
<p>Reprenons notre exemple initial, le programme qui demande le nom et qui affiche ensuite <code class="sourceCode ocaml"><span class="st">&quot;Hello $nom&quot;</span></code> et essayons de l’implémenter avec les effets algébriques de Koka. Premièrement, on défini les effets du programme :</p>
<div class="sourceCode" id="cb29" data-roe-kind="code" data-pellet="Koka" data-line-number="true"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb29-1" title="1">effect interaction {</a>
<a class="sourceLine" id="cb29-2" title="2">  <span class="kw">fun</span> show(message: <span class="dt">string</span>) : ()</a>
<a class="sourceLine" id="cb29-3" title="3">  <span class="kw">fun</span> ask(message: <span class="dt">string</span>) : <span class="dt">string</span></a>
<a class="sourceLine" id="cb29-4" title="4">}</a></code></pre></div>
<p>Maintenant, la description du programme devient assez facile à écrire :</p>
<div class="sourceCode" id="cb30" data-roe-kind="code" data-pellet="Koka" data-line-number="true" data-line-start="5"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">fun</span> program() : interaction () {</a>
<a class="sourceLine" id="cb30-2" title="2">  <span class="kw">val</span> name = ask(<span class="st">&quot;What's your name? &quot;</span>)</a>
<a class="sourceLine" id="cb30-3" title="3">  show(<span class="st">&quot;Hello &quot;</span> + name)</a>
<a class="sourceLine" id="cb30-4" title="4">}</a></code></pre></div>
<p>Et il ne nous reste plus qu’à écrire un interpréteur !</p>
<div class="sourceCode" id="cb31" data-roe-kind="code" data-pellet="Koka" data-line-number="true" data-line-start="9"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">val</span> hello_handler = handler {</a>
<a class="sourceLine" id="cb31-2" title="2">  ask(message) -&gt; {</a>
<a class="sourceLine" id="cb31-3" title="3">    <span class="kw">val</span> name = question(message)</a>
<a class="sourceLine" id="cb31-4" title="4">    resume(name)</a>
<a class="sourceLine" id="cb31-5" title="5">  }</a>
<a class="sourceLine" id="cb31-6" title="6">  show(message) -&gt; {</a>
<a class="sourceLine" id="cb31-7" title="7">    println(message)</a>
<a class="sourceLine" id="cb31-8" title="8">    resume(())</a>
<a class="sourceLine" id="cb31-9" title="9">  }</a>
<a class="sourceLine" id="cb31-10" title="10">}</a></code></pre></div>
<p>Concrètement :</p>
<ul>
<li><p>si le programme propage un <code class="sourceCode ocaml">show</code>, on affiche le message transporté par l’exécution de l’effet <code class="sourceCode ocaml">show</code> et on <strong>continue le programme</strong> en lui donnant <code class="sourceCode ocaml"><span class="dt">unit</span></code> ;</p></li>
<li><p>si le programme propage un <code class="sourceCode ocaml">ask</code>, on utilise la primitive <code class="sourceCode ocaml">question</code> (qui existe dans la bibliothèque standard de Koka) et on <strong>continue le programme</strong> en lui passant le résultat de la lecture !</p></li>
</ul>
<p>Attention, si par mégarde, j’avais oublié de gérer un des cas, le compilateur aurait <strong>refusé de compiler</strong> mon programme. Par exemple, cet intepréteur :</p>
<div class="sourceCode" id="cb32" data-roe-kind="code" data-pellet="Koka"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">val</span> hello_handler = handler {</a>
<a class="sourceLine" id="cb32-2" title="2">  ask(message) -&gt; {</a>
<a class="sourceLine" id="cb32-3" title="3">    <span class="kw">val</span> name = question(message)</a>
<a class="sourceLine" id="cb32-4" title="4">    resume(name)</a>
<a class="sourceLine" id="cb32-5" title="5">  }</a>
<a class="sourceLine" id="cb32-6" title="6">}</a>
<a class="sourceLine" id="cb32-7" title="7"></a>
<a class="sourceLine" id="cb32-8" title="8">// Aurait généré cette erreur :</a>
<a class="sourceLine" id="cb32-9" title="9">test.kk(<span class="dv">13</span>,<span class="dv">21</span>): error: operator show is <span class="dt">not</span> handled</a></code></pre></div>
<p>Il ne reste plus qu’a interpréter notre programme !</p>
<div class="sourceCode" id="cb33" data-roe-kind="code" data-pellet="Koka" data-line-number="true" data-line-start="19"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb33-1" title="1"><span class="kw">fun</span> main() {</a>
<a class="sourceLine" id="cb33-2" title="2">  hello_handler{ program() }</a>
<a class="sourceLine" id="cb33-3" title="3">}</a></code></pre></div>
<p>Nous avons exactement ce que nous désirions au début de l’article :</p>
<ul>
<li><p>la séparation du programme entre sa partie pure et sa partie impure est explicite. Les déclarations de programmes sont pures et les gestionnaires de programmes sont impurs ;</p></li>
<li><p>les effets propagés par nos descriptions de programmes sont reflétés dans la signature de type de nos descriptions ;</p></li>
<li><p>un gestionnaire doit gérer tous les effets que la description de programme peut propager.</p></li>
</ul>
<h3 id="tester-un-programme">Tester un programme</h3>
<p>Comme notre programme n’est plus qu’une description, on peut donc très facilement le tester. En effet, il suffit de lui implémenter un interpréteur de test ! Par exemple, une manière <em>naïve</em> de tester ce programme serait simplement de lui demander de stocker toutes les étapes dans une chaîne de caractères (il existe des manières autrement plus pertinentes, mais le but de l’exemple n’est pas de trop alourdir le code).</p>
<p>Comme la mutation de données est aussi un calcul à effet, je vous propose de commencer par implémenter un effet <code class="sourceCode ocaml">State</code> pour manipuler un état mutable :</p>
<div class="sourceCode" id="cb34" data-roe-kind="code" data-pellet="Koka" data-line-number="true"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb34-1" title="1">effect state&lt;s&gt; {</a>
<a class="sourceLine" id="cb34-2" title="2">  <span class="kw">fun</span> get()    : s</a>
<a class="sourceLine" id="cb34-3" title="3">  <span class="kw">fun</span> set(i:s) : ()</a>
<a class="sourceLine" id="cb34-4" title="4">}</a></code></pre></div>
<p><code class="sourceCode ocaml">state&lt;s&gt;</code> est un état mutable, il est paramétré par le type qu’il va stocker. Dans notre cas, ce sera une chaîne de caractères. Maintenant que nous avons les briques pour faire des mutations, nous allons construire un interpréteur pour notre programme originel :</p>
<div class="sourceCode" id="cb35" data-roe-kind="code" data-pellet="Koka" data-line-number="true" data-line-start="5"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb35-1" title="1"><span class="kw">val</span> test_handler = handler {</a>
<a class="sourceLine" id="cb35-2" title="2">  ask(_) -&gt; {</a>
<a class="sourceLine" id="cb35-3" title="3">    <span class="kw">val</span> accumulator = get()</a>
<a class="sourceLine" id="cb35-4" title="4">    set(accumulator + <span class="st">&quot;;Xavier&quot;</span>)</a>
<a class="sourceLine" id="cb35-5" title="5">    resume(<span class="st">&quot;Xavier&quot;</span>)</a>
<a class="sourceLine" id="cb35-6" title="6">  }</a>
<a class="sourceLine" id="cb35-7" title="7">  show(message) -&gt; {</a>
<a class="sourceLine" id="cb35-8" title="8">    <span class="kw">val</span> accumulator = get()</a>
<a class="sourceLine" id="cb35-9" title="9">    set(accumulator + <span class="st">&quot;;&quot;</span> + message)</a>
<a class="sourceLine" id="cb35-10" title="10">    resume(())</a>
<a class="sourceLine" id="cb35-11" title="11">  }</a>
<a class="sourceLine" id="cb35-12" title="12">}</a></code></pre></div>
<p>Concrètement, cet interpréteur va <em>hooker</em> l’effet <code class="sourceCode ocaml">ask</code> pour toujours renvoyer <code class="sourceCode ocaml"><span class="st">&quot;Xavier&quot;</span></code>, et il va le concaténer à notre état courant. Le gestionnaire pour <code class="sourceCode ocaml">show</code>, lui, va simplement concaténer le message à notre état courant. Notre gestionnaire aura donc le type :</p>
<div class="sourceCode" id="cb36" data-roe-kind="code"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb36-1" title="1">(() -&gt; &lt;interaction, state&lt;<span class="dt">string</span>&gt;&gt; ()) -&gt; state&lt;<span class="dt">string</span>&gt; () </a></code></pre></div>
<p>Soit que le gestionnaire s’applique à une fonction qui ne renvoie rien mais peut exécuter des effets de type <code class="sourceCode ocaml">interaction</code> et <code class="sourceCode ocaml">state&lt;<span class="dt">string</span>&gt;</code>. Et que ce gestionnaire, une fois appliqué, ne renvoie rien mais peut exécuter l’effet <code class="sourceCode ocaml">state&lt;<span class="dt">string</span>&gt;</code>. Il faudra donc l’éliminer via un gestionnaire destiné à implémenter notre état mutable.</p>
<p>(Cet interpréteur donne un exemple de la manière dont Koka compose des programmes qui émettent plusieurs types d’effets, une fonction peut donc exécuter plusieurs types d’effets, il suffit juste de donner plusieurs interpréteurs pour éliminer les effets non-gérés.)</p>
<p>On peut donc implémenter un petit interpréteur dont le rôle sera uniquement de maintenir un état mutable :</p>
<div class="sourceCode" id="cb37" data-roe-kind="code" data-pellet="Koka" data-line-number="true" data-line-start="17"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb37-1" title="1"><span class="kw">val</span> state_handler = handler(state) {</a>
<a class="sourceLine" id="cb37-2" title="2">  return x -&gt; state + <span class="st">&quot;;end&quot;</span></a>
<a class="sourceLine" id="cb37-3" title="3">  get()  -&gt; resume(state, state)</a>
<a class="sourceLine" id="cb37-4" title="4">  set(j) -&gt; resume((), j)</a>
<a class="sourceLine" id="cb37-5" title="5">}</a></code></pre></div>
<p>La branche <code class="sourceCode ocaml">return x</code> applique une dernière transformation une fois que le programme est terminé. Ici, on lui demande simplement de renvoyer l’état final, auquel on concatène la chaine <code class="sourceCode ocaml"><span class="st">&quot;;end&quot;</span></code>. Maintenant que c’est fait, il suffit d’appliquer nos deux interpréteurs à notre programme (qui n’a pas changé) et de calculer son résultat final :</p>
<div class="sourceCode" id="cb38" data-roe-kind="code" data-pellet="Koka" data-line-number="true" data-line-start="22"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb38-1" title="1"><span class="kw">fun</span> test() {</a>
<a class="sourceLine" id="cb38-2" title="2">  <span class="kw">val</span> result = state_handler(<span class="st">&quot;start&quot;</span>){</a>
<a class="sourceLine" id="cb38-3" title="3">    test_handler{ </a>
<a class="sourceLine" id="cb38-4" title="4">       program() </a>
<a class="sourceLine" id="cb38-5" title="5">    }</a>
<a class="sourceLine" id="cb38-6" title="6">  }</a>
<a class="sourceLine" id="cb38-7" title="7">  <span class="kw">assert</span>(</a>
<a class="sourceLine" id="cb38-8" title="8">    <span class="st">&quot;String should be equals&quot;</span>, </a>
<a class="sourceLine" id="cb38-9" title="9">    result == <span class="st">&quot;start;Xavier;Hello Xavier;end&quot;</span>)</a>
<a class="sourceLine" id="cb38-10" title="10">         // Au final, voici à quoi devrait ressembler notre</a>
<a class="sourceLine" id="cb38-11" title="11">         // résultat accumulé</a>
<a class="sourceLine" id="cb38-12" title="12">}</a></code></pre></div>
<p>Comme notre programme est une fonction pure, il est assez simple de la tester unitairement. C’est une des grande force des effets algébriques, ils séparent systématiquement la partie pure de la partie impure d’un programme !</p>
<h2 id="notes-complémentaires-sur-le-contrôle-du-flot-du-programme">Notes complémentaires sur le contrôle du flot du programme</h2>
<p>Nous avons, au moyen des effets algébriques, une manière systématique de séparer un programme en une description (une fonction qui propage des effets) et son interpréteur (un gestionnaire). Nous pouvons donc facilement tester nos fonctions impures en les transformant “<em>simplement</em>” en fonctions pures ! Cependant, la force des effets algébriques ne réside pas uniquement dans cette séparation et dans le reflet, dans le système de types, des effets propagés par une fonction. Le fait de pouvoir contrôler le flot du programme offre aussi beaucoup de possibilités. Notamment le fait de pouvoir modifier la sémantique opérationnelle du programme. Imaginons ce scénario :</p>
<div class="sourceCode" id="cb39" data-roe-kind="code" data-pellet="Koka" data-line-number="true" data-hl="7"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb39-1" title="1"><span class="kw">val</span> hello_handler_reversed = handler {</a>
<a class="sourceLine" id="cb39-2" title="2">  ask(message) -&gt; {</a>
<a class="sourceLine" id="cb39-3" title="3">    <span class="kw">val</span> name = question(message)</a>
<a class="sourceLine" id="cb39-4" title="4">    resume(name)</a>
<a class="sourceLine" id="cb39-5" title="5">  }</a>
<a class="sourceLine" id="cb39-6" title="6">  show(message) -&gt; {</a>
<a class="sourceLine" id="cb39-7" title="7">    resume(())</a>
<a class="sourceLine" id="cb39-8" title="8">    println(message)</a>
<a class="sourceLine" id="cb39-9" title="9">  }</a>
<a class="sourceLine" id="cb39-10" title="10">}</a>
<a class="sourceLine" id="cb39-11" title="11"></a>
<a class="sourceLine" id="cb39-12" title="12"><span class="kw">fun</span> program() {</a>
<a class="sourceLine" id="cb39-13" title="13">  show(<span class="st">&quot;Hello World&quot;</span>)</a>
<a class="sourceLine" id="cb39-14" title="14">  <span class="kw">val</span> x = ask(<span class="st">&quot;What is your name?&quot;</span>)</a>
<a class="sourceLine" id="cb39-15" title="15">  show(<span class="st">&quot;Hello &quot;</span> + x)</a>
<a class="sourceLine" id="cb39-16" title="16">}</a></code></pre></div>
<p>On demande d’exécuter la continuation capturée avant d’exécuter la gestion de l’effet. Ça a pour effet d’inverser le flot du programme.</p>
<div class="sourceCode" id="cb40" data-roe-kind="code"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb40-1" title="1"><span class="ex">What</span> is your name? <span class="op">&lt;</span>input<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb40-2" title="2"><span class="ex">Hello</span> <span class="op">&lt;</span>input<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb40-3" title="3"><span class="ex">Hello</span> World</a></code></pre></div>
<p>De même que l’interprétation concrète d’un programme vise à fournir, pour chaque effet propagé, un interpréteur, il est possible de choisir dans quel ordre on veut appliquer des interpréteurs. De ce fait, pour une fonction de type <code class="sourceCode kotlin">() -&gt; &lt;effectA, effectB&gt; a</code>, il serait possible :</p>
<ul>
<li>d’appliquer <code class="koka">handler_for_a</code>{<code class="koka">handler_for_b</code>{program}} ;</li>
<li>ou d’appliquer <code class="koka">handler_for_b</code>{<code class="koka">handler_for_a</code>{program}}.</li>
</ul>
<p>Cette grande liberté sur la manière et l’ordre d’interprétation permet, par exemple, d’enrichir un programme.</p>
<h3 id="enrichissement-de-programmes">Enrichissement de programmes</h3>
<p>Dans <a href="./introduction_aux_monades.html">l’article sur les monades</a>, nous avions évoqué que l’un des bienfaits de leur utilisation était la séparation systématique entre l’algorithme et son outillage. Soit, une séparation entre l’algorithme et la plomberie nécéssaire à l’utilisation de cet algorithme. Les effets algébriques et leurs gestionnaires proposent une manière encore plus explicite de greffer des fonctionnalités à un programme. Par exemple, imaginons ce programme naïf :</p>
<div class="sourceCode" id="cb41" data-roe-kind="code" data-pellet="Koka" data-line-number="true"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb41-1" title="1">effect user_database {</a>
<a class="sourceLine" id="cb41-2" title="2">  <span class="kw">fun</span> create_user(username: <span class="dt">string</span>) : ()</a>
<a class="sourceLine" id="cb41-3" title="3">  <span class="kw">fun</span> update_user(old_username: <span class="dt">string</span>, new_username: <span class="dt">string</span>) : ()</a>
<a class="sourceLine" id="cb41-4" title="4">  <span class="kw">fun</span> drop_user(username: <span class="dt">string</span>) : ()</a>
<a class="sourceLine" id="cb41-5" title="5">}</a>
<a class="sourceLine" id="cb41-6" title="6"></a>
<a class="sourceLine" id="cb41-7" title="7"><span class="kw">fun</span> program() {</a>
<a class="sourceLine" id="cb41-8" title="8">  create_user(<span class="st">&quot;xavier&quot;</span>)</a>
<a class="sourceLine" id="cb41-9" title="9">  update_user(<span class="st">&quot;xavier&quot;</span>, <span class="st">&quot;xvw&quot;</span>)</a>
<a class="sourceLine" id="cb41-10" title="10">  drop_user(<span class="st">&quot;xvw&quot;</span>)</a>
<a class="sourceLine" id="cb41-11" title="11">}</a></code></pre></div>
<p>Le type de <code class="sourceCode ocaml">program()</code> est : <code class="sourceCode ocaml">() -&gt; user_database ()</code>, je peux très facilement fournir un gestionnaire dont le rôle sera de <em>logger</em> chaque action effectuée. Utiliser un gestionnaire permet d’éviter de changer le programme originel, tout en lui greffant des fonctionnalités :</p>
<div class="sourceCode" id="cb42" data-roe-kind="code" data-pellet="Koka" data-line-number="true" data-line-start="12"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><a class="sourceLine" id="cb42-1" title="1"><span class="kw">val</span> logger_user_handler = handler {</a>
<a class="sourceLine" id="cb42-2" title="2">  create_user(username) -&gt; {</a>
<a class="sourceLine" id="cb42-3" title="3">    println(<span class="st">&quot;LOG: create_user [&quot;</span> + username + <span class="st">&quot;]&quot;</span>)</a>
<a class="sourceLine" id="cb42-4" title="4">    create_user(username)</a>
<a class="sourceLine" id="cb42-5" title="5">    resume(())</a>
<a class="sourceLine" id="cb42-6" title="6">  }</a>
<a class="sourceLine" id="cb42-7" title="7">  update_user(old, <span class="kw">new</span>) -&gt; {</a>
<a class="sourceLine" id="cb42-8" title="8">    println(<span class="st">&quot;LOG: update_user [&quot;</span> + old + <span class="st">&quot;] by [&quot;</span>+ <span class="kw">new</span> +<span class="st">&quot;]&quot;</span>)</a>
<a class="sourceLine" id="cb42-9" title="9">    update_user(old, <span class="kw">new</span>)</a>
<a class="sourceLine" id="cb42-10" title="10">    resume(())</a>
<a class="sourceLine" id="cb42-11" title="11">  }</a>
<a class="sourceLine" id="cb42-12" title="12">  drop_user(username) -&gt; {</a>
<a class="sourceLine" id="cb42-13" title="13">    println(<span class="st">&quot;LOG: drop_user [&quot;</span> + username + <span class="st">&quot;]&quot;</span>)</a>
<a class="sourceLine" id="cb42-14" title="14">    drop_user(username)</a>
<a class="sourceLine" id="cb42-15" title="15">    resume(())</a>
<a class="sourceLine" id="cb42-16" title="16">  }</a>
<a class="sourceLine" id="cb42-17" title="17">}</a></code></pre></div>
<p>Comme ce gestionnaire re-propage les effets qu’il capture, on ne devra pas modifier le code du gestionnaire qui s’occupe de réellement gérer nos utilisateurs. Cette approche est très proche d’une <strong>Monade Writer</strong>. En utilisant cette approche, nos descriptions de programmes peuvent se <strong>contenter d’exprimer ce qu’ils font</strong> et les gestionnaires <strong>ajoutent des capacités supplémentaires</strong> pour l’exécution du programme.</p>
<h3 id="une-base-pour-des-constructions-plus-complexes">Une base pour des constructions plus complexes</h3>
<p>Un peu à l’instar des fonctions d’ordre supérieur, qui permettent de modéliser des encodages, par exemple <code class="sourceCode javascript"><span class="cf">for</span> <span class="kw">const</span> x <span class="kw">of</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>] <span class="op">{</span> <span class="at">f</span>(x) </code>} qui pourrait être exprimé comme <code class="sourceCode javascript">[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>].<span class="at">forEach</span>(f)</code> et donc réduire la taille de la grammaire du langage, les effets algébriques (et leurs gestionnaires) permettent d’exprimer des constructions complexes, qu’il serait difficile d’exprimer sans et que l’on considère généralement comme des éléments du langage. Par exemple :</p>
<ul>
<li>des lancements (l’exécution d’un effet) et des captures (un gestionnaire) d’exceptions ;</li>
<li>l’expression de programmes asynchrones que l’on pourrait synchroniser <code class="sourceCode javascript"><span class="kw">async</span><span class="ss">/await</span></code> ;</li>
<li>des boucles qui profitent d’effets ;</li>
<li>de la concurrence ;</li>
<li>etc.</li>
</ul>
<p>L’intégration d’effets algébriques et de gestionnaires permet donc, moyennant le coup d’ajout dans un langage, la réduction d’encodages initiaux pour d’autres expressions communes dans le langages de programmations classiques. Ces constructions complémentaires pourrait donc appartenir, pourquoi pas, à des bibliothèques tierces.</p>
<p>Dans le cadre de la construction d’un <em>runtime</em> multi-cœurs pour le langage OCaml, l’intégration d’effets algébriques fait partie de la feuille de route pour pouvoir correctement modéliser l’expression de programmes concurrents dans un <em>runtime</em> multi-cœurs.</p>
<h2 id="et-quest-ce-quil-y-a-dalgébrique-là-dedans">Et qu’est-ce qu’il y a d’algébrique là-dedans ?</h2>
<p>Très souvent, les objets que l’on manipule en programmation fonctionnelle sont construits sur la base d’une théorie solide. Parfois, il s’agit d’une application pratique d’un objet de la théorie des catégories. Les effets algébriques ont été exprimés, initialement, en terme de relations avec des catégories. (Ce qui est assez logique car la théorie des catégories à été initialement utilisée en extension au λ-calcul pour exprimer les effets. Cette utilisation a donné, approximativement, naissance aux monades en programmation fonctionnelle.)</p>
<p>La définition des opérations (nos exemples <code class="sourceCode ocaml">Ask</code> et <code class="sourceCode ocaml">Show</code>) produisant des effets, via, en Koka, la construction <code class="sourceCode ocaml">effect</code>, décrit <strong>un algèbre libre</strong> et les gestionnaires décrivent des <code class="sourceCode ocaml">fold</code> sur l’algèbre des opérations. Il faut prendre le terme “algébrique”, dans “effets algébriques” comme le fait que les opérations qui décrivent des effets sont définies par des <strong>règles</strong> <strong>équationnelles</strong>, de la même manière que l’on décrirait les lois de compositions pour des structures algébriques.</p>
<p>Si jamais une explication plus détaillée et intelligente vous intéresse, le papier “<a href="https://arxiv.org/pdf/1807.05923.pdf">What is algebraic about algebraic effects and handler</a>” de Andrej Bauer est incroyablement détaillé (et progressif) sur le “pourquoi algébrique”), je vous invite donc à le lire !</p>
<h2 id="des-effets-algébriques-partout">Des effets algébriques PARTOUT</h2>
<p>Dans les rubriques précédentes, nous avons détaillé quelques cas d’usages aux effets algébriques et à leurs gestionnaires. Si vous êtes aussi emballé que moi, c’est normal, les effets algébriques, c’est trop cool ! Donc qu’attendons-nous pour n’utiliser que des langages qui supportent les effets algébriques ?</p>
<p>Actuellement, il n’existe pas de langage <em>production-ready</em> qui offre le support des effets algébriques <em>built-in</em>. Cela s’explique, entre autre, par la difficulté de compiler efficacement des continuations délimitées, ce qui permet d’exprimer la primitive <code class="sourceCode ocaml">resume</code> de Koka. Par contre, plusieurs équipes de recherches sont assez impliquées dans ce domaine, donc il existe plusieurs expériences intéressantes, en plus de Koka, qui valent le coup d’œil (selon moi), en voici quelques unes :</p>
<ul>
<li><p><strong><a href="https://www.eff-lang.org/">Eff</a></strong> est un langage à la syntaxe proche de OCaml qui propose des effets algébriques et des gestionnaires. Il est très proche de la théorie car deux de ses auteurs principaux sont très actifs dans les publications relatives aux effets algébriques ;</p></li>
<li><p><strong><a href="https://links-lang.org/">Links</a></strong> est un langage pour le développement web (qui offre beaucoup de fonctionnalités à la pointe de la recherche) et qui propose des effets algébriques et des gestionnaires pour le développement web (où les continuations peuvent être très utiles) ;</p></li>
<li><p><strong><a href="https://github.com/ocaml-multicore/ocaml-multicore/wiki">OCaml multicore</a></strong> est l’implémentation d’un <em>runtime</em> multi-cœurs pour OCaml, auquel seront liés des effets algébriques et des gestionnaires pour modéliser des programmes concurrents ;</p></li>
<li><p><strong><a href="https://github.com/frank-lang/frank">Frank</a></strong> propose une alternative aux gestionnaires d’effets tels qu’on l’a entendu dans cet article. Cependant, il n’existe que des embryons de prototypes.</p></li>
</ul>
<p>Certains langages proposent la gestion des effets au moyen de monades avec une interface agréable à utiliser, on pourrait citer, entre autres, <a href="https://www.fstar-lang.org/#introduction">FStar</a> et <a href="https://www.idris-lang.org/">Idris</a>. Il semble que les effets algébriques sont assez confidentiels.</p>
<p>Heureusement, dans le monde des langages <em>mainstream</em>, comme Haskell, on trouve des bibliothèques très convaincantes, comme par exemple :</p>
<ul>
<li><a href="https://hackage.haskell.org/package/fused-effects">Fused-effect</a> développé par une équipe de chez Github pour le développement de <a href="https://github.com/github/semantic">Semantic</a> ;</li>
<li><a href="https://hackage.haskell.org/package/polysemy">Polysemy</a> qui est très prometteur, et qui est utilisé chez Decathlon (oui oui, ils font aussi du Haskell) et qui m’a été chaudement recommandé par <a href="https://sir4ur0n.github.io/">Julien Debon</a> et qui en parle sur son blog !</li>
</ul>
<p>Cette dernière approche semble celle à explorer en vue de faire de la production, attendant impatiemment l’intgération des effets algébriques comme des citoyens de premier ordre, dans nos langages favoris !</p>
<h2 id="pour-conclure">Pour conclure</h2>
<p>Les effets algébriques et leurs gestionnaires sont une façon de séparer systématiquement la description d’un programme et son interprétation. Cette séparation permet de tester facilement ces descriptions de programmes, en ne fournissant qu’un gestionnaire spécifique au contexte des tests.</p>
<p>Cette séparation offre des avantages assez, à mon sens, impressionnants :</p>
<ul>
<li>on fait refléter, dans la signature de type, les effets propagés par un programme, <strong>ce qui élimine les effets de bords</strong> ;</li>
<li>on donne à l’interpréteur du programme un <strong>grand contrôle sur le flot du</strong> <strong>programme</strong> ;</li>
<li>il devient possible d’encoder une zoologie de constructions complexes (comme par exemple des exceptions ou des programmes concurrents). Et donc <strong>réduire</strong> <strong>les constructions internes du langages</strong>.</li>
</ul>
<p>Le mot de la fin serait, si un programme est difficile à tester unitairement, parce qu’il exécute une collection d’effets… il suffit de transformer les fonctions impures en fonctions pures, soit de fournir une description de programme qui sera interprétée.</p>
<p>Même si les effets algébriques ne sont pas encore standards dans les langages de programmation <em>mainstream</em> (comme Haskell ou OCaml), il est tout de même possible d’utiliser “leur interface” au moyen, par exemple, de <strong>Monades gratuites</strong>, et même si dans d’autres langages (encore plus <em>mainstream</em>) ce genre de pratique n’est pas habituel, je vous assure qu’elle facilite grandement l’expérience développeur et qu’elle permet de rendre les programmes plus facile à raisonner, à déboguer, et à tester unitairement ! Donc n’hésitez pas à aller voir du côté de <a href="https://arrow-kt.io/">Arrow</a>, pour Kotlin, pour observer la manière dont ils utilisent les coroutines pour modéliser des effets ! N’hésitez pas à jouer avec des prototypes comme Koka, ou Eff pour vous familiariser avec cette manière de programmer, je vous assure qu’elle est inspirante !</p>
<p>J’espère que cet article (assez naïf) vous aura transmis l’envie de vous intéresser aux effets algébriques et d’en espérer leur avènement. Je vous souhaite à tous d’agréables expériences en développement et j’espère que l’objectif de cette présentation a été correctement transmis, soit, séparez au maximum la description de l’interprétation et abusez des fonctions pures, elles sont plus faciles à tester !</p>
<p>Je remercie chaleureusement Gaston Lemaire, <a href="https://github.com/tsnobip">Paul Tsnobiladzé</a>, <a href="https://twitter.com/riduidel">Nicolas Delsaux</a>, <a href="https://twitter.com/NicolasRinaudo">Nicolas Rinaudo</a>, <a href="https://twitter.com/Sir4ur0n">Julien Debon</a>, <a href="https://twitter.com/dplaindoux">Didier Plaindoux</a> ainsi que la communauté <strong>Lambda Lille</strong> pour leurs conseils, leurs relectures et leur bienveillance ! Merci les gens, sans vous je n’aurais sûrement pas eu le courage d’écrire cet article.</p>
        <div id="eof-page"></div>
      </div>
      <div class="content-rightbar">
        <div id="major-content-right" class="small-refutable">
          <div id="dynamic-right">
          </div>
          <div class="project-block tag-list"><h3><span>Tags</span><span class="label">7</span></h3><ul><li><a href="../tags.html#programmation">programmation</a></li><li><a href="../tags.html#fonctionnelle">fonctionnelle</a></li><li><a href="../tags.html#pure">pure</a></li><li><a href="../tags.html#effets algébriques">effets algébriques</a></li><li><a href="../tags.html#test unitaire">test unitaire</a></li><li><a href="../tags.html#koka">koka</a></li><li><a href="../tags.html#kotlin">kotlin</a></li></ul></div>
        </div>
      </div>
    </div>
  </div>
  <div id="major-content-bottom">
    <div class="list-of-links"><div class="project-block link-list"><h3><span>Langages</span></h3><ul><li><a href="https://koka-lang.github.io/koka/doc/kokaspec.html">Koka</a></li><li><a href="https://www.eff-lang.org/">Eff</a></li><li><a href="https://links-lang.org/">Links</a></li><li><a href="https://fstar-lang.org">F*</a></li><li><a href="https://github.com/frank-lang/frank">Frank</a></li><li><a href="https://bitbucket.org/pl-uwr/helium/src/master/">Helium</a></li><li><a href="https://www.idris-lang.org/">Idris</a></li><li><a href="https://github.com/ocaml-multicore/ocaml-multicore/wiki">OCaml multicore</a></li><li><a href="https://github.com/pigworker/shonky">Shonky</a></li></ul></div><div class="project-block link-list"><h3><span>Bibliothèques intéressantes</span></h3><ul><li><a href="https://github.com/polysemy-research/polysemy">Polysemy (Haskell)</a></li><li><a href="https://github.com/fused-effects/fused-effects">Fused effects (Haskell)</a></li><li><a href="https://github.com/palladin/Eff">Eff in F#</a></li><li><a href="https://arrow-kt.io/docs/fx/">Arrow Fx (Kotlin)</a></li></ul></div><div class="project-block link-list"><h3><span>Bibliographie</span></h3><ul><li><a href="https://github.com/yallop/effects-bibliography">Une bibliographie sur les effets</a></li><li><a href="https://arxiv.org/pdf/1807.05923.pdf">What is algebraic about algebraic effects and handlers?</a></li><li><a href="http://www.eff-lang.org/handlers-tutorial.pdf">An Introduction to Algebraic Effects and Handlers</a></li><li><a href="https://eb.host.cs.st-andrews.ac.uk/drafts/effects.pdf">Programming and Reasoning with Algebraic Effects and Dependent Types</a></li></ul></div></div>
  </div>
</div>
<script>
  planet.suspend(function() {
    planet.story.boot({
      path: "/longs/introduction_algebraic_effects.html",
      eof: document.getElementById("eof-page"),
      rightContainer: document.getElementById(
        "major-content-right"
      ),
      resumeDetails: document.getElementById(
        "resume-details"
      )
    });
  });
  planet.suspend(function() {
    planet.roe.mount(
      document.getElementById("roe-container")
    );
  });
</script>

      </div>
    </main>
    <footer>
      <div class="container">
        <div class="left">
          <button id="random-page-btn" class="small-button-gray">
            Page aléatoire
          </button>
          <br /><br />
          Cette page est construite avec
          <a href="https://jaspervdj.be/hakyll/">Hakyll</a> et
          <a href="../projects/planet.html">Planet</a>.
          <br />
          Le contenu est distribué sous licence
          <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA</a>.
        </div>
        <div class="center">
          <a href="http://webring.xxiivv.com/#random" target="_blank">
            <img class="pictogram" src="../picto/webring.black.svg" alt="webring-logo" />
          </a>
        </div>
        <div class="right">
          <a href="../xavier.html">Xavier Van de Woestyne</a> ©<br />
          2017-2020
        </div>
      </div>
    </footer>
    <div id="planet-sectors-metadata">
      <span class="planet-metadata sector-data" data-name="programming" data-desc="Programmation (code) relative ou non à des projets" data-color="rgb(34, 34, 34)"><!-- Planet metadata --></span>
<span class="planet-metadata sector-data" data-name="visual" data-desc="Dessin/Peinture/Design" data-color="rgb(68, 68, 68)"><!-- Planet metadata --></span>
<span class="planet-metadata sector-data" data-name="audio" data-desc="Musique/Sound design" data-color="rgb(221, 221, 221)"><!-- Planet metadata --></span>
<span class="planet-metadata sector-data" data-name="writing" data-desc="Ecriture d'articles, de livres, de notes" data-color="rgb(136, 136, 136)"><!-- Planet metadata --></span>
<span class="planet-metadata sector-data" data-name="research" data-desc="Expériences variées liées à l'apprentissage" data-color="rgb(85, 85, 85)"><!-- Planet metadata --></span>
<span class="planet-metadata sector-data" data-name="maintenance" data-desc="Correctif, maintenance d'infrastructures" data-color="rgb(204, 204, 204)"><!-- Planet metadata --></span>
<span class="planet-metadata sector-data" data-name="reading" data-desc="Activité liées à la lecture" data-color="rgb(192, 192, 192)"><!-- Planet metadata --></span>

    </div>
    <script>
      planet.suspend(function() {
        planet.tags.random({
          button: document.getElementById('random-page-btn')
        });
      });
      planet.start();
    </script>
  </body>
</html>
